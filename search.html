<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[2019]]></title>
      <url>http://codingxiaxw.cn/2019/02/04/71-2019/</url>
      <content type="html"><![CDATA[<p>hi，大家新年快乐，这次冒泡有点话想说。依旧收到很多朋友的私信关心我最近在忙些什么，还有的提醒我博客图床挂了。借此两个问题都回答下，本人目前专心专研工作，暂时不打算维护此博客了，谢谢大家一直以来的陪伴，希望大家2019事业有成，早日过上自己想要的生活。<br><a id="more"></a></p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some infos by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[nodeclub源码学习笔记]]></title>
      <url>http://codingxiaxw.cn/2018/05/23/70-nodeClub-study-notes/</url>
      <content type="html"><![CDATA[<p>正式工作以后才知道，原来系统的去学习一门语言是多么的奢侈。本篇文章通过学习nodeclub项目的源码来学习nodejs的express框架开发。此篇文章建议在了解nodejs基本语法后再来观看，我反正是在菜鸟教程过了一遍nodejs有关的知识再来学习这个项目的。</p>
<a id="more"></a>
<h2 id="1-nodeclub介绍"><a href="#1-nodeclub介绍" class="headerlink" title="1.nodeclub介绍"></a>1.nodeclub介绍</h2><p>Nodeclub 是使用 Node.js + Express 框架和 MongoDB 开发的一个社区系统,是 <a href="https://cnodejs.org/" target="_blank" rel="external">cnodejs.org</a> 的<a href="https://github.com/cnodejs/nodeclub" target="_blank" rel="external">源码</a>，算是一个基本的博客系统，包含文章发布，关注，评论等功能。这些功能可以说是任何一个网站的基础。那么我们从 nodeclub 里可以学到什么？</p>
<ol>
<li>基本的架构</li>
<li>开发测试过程</li>
<li>MVC 的设计</li>
<li>middleware 的正确用法</li>
<li>如何设计 Mongodb schema</li>
<li>如何正确的使用 Mongoose</li>
<li>如何实现一个标签系统</li>
<li>plugins? services ?</li>
<li>如何正确的使用 EJS helper</li>
<li>到底该怎样写路由， restful？</li>
<li>如何做基本的控制验证</li>
<li>如何发邮件</li>
<li>session</li>
<li>GitHub 用户登录</li>
<li>图片上传</li>
<li>消息发送</li>
</ol>
<h2 id="2-nodeclub中用到了哪些开源技术"><a href="#2-nodeclub中用到了哪些开源技术" class="headerlink" title="2.nodeclub中用到了哪些开源技术"></a>2.nodeclub中用到了哪些开源技术</h2><p>下载nodeclub源码，打开package.json文件，找到里面的<code>dependencies</code>&amp;<code>devDependencies</code>，可以看到这个项目所有的依赖。下面我将对这些模块一一做简单说明。</p>
<h3 id="2-1dependencies"><a href="#2-1dependencies" class="headerlink" title="2.1dependencies"></a>2.1dependencies</h3><ul>
<li><code>async</code>: async模块是为了解决嵌套金字塔,和异步流程控制而生。参考:<a href="http://blog.fens.me/nodejs-async/" target="_blank" rel="external">传送门</a></li>
<li><code>bcryptjs</code>: 该模块用于开发登录注册模块时对密码进行加密。资料参考：<a href="https://segmentfault.com/a/1190000013165651" target="_blank" rel="external">传送门</a></li>
<li><code>body-parser</code>: body-parser是一个HTTP请求体解析中间件，使用这个模块可以解析JSON、Raw、文本、URL-encoded格式的请求体，Express框架中就是使用这个模块做为请求体解析中间件。<a href="https://www.jianshu.com/p/ea0122ad1ac0" target="_blank" rel="external">传送门</a></li>
<li><code>bytes</code>: </li>
<li><code>colors</code>: 通过这个模块我们输出各种带颜色、方面区分或者更酷的日志以及 CLI 工具提示。<a href="https://github.com/Marak/colors.js" target="_blank" rel="external">传送门</a></li>
<li><code>compression</code>:该模块用于压缩gzip文件，我们在Linux中经常会用到后缀为.gz的文件，它们就是GZIP格式的。 <a href="https://www.jianshu.com/p/1c9909f9b0e9" target="_blank" rel="external">传送门</a></li>
<li><code>connect-busboy</code>:文件上传模块，用来解析post请求，实现文件的上传。 <a href="https://www.bbsmax.com/A/x9J2ZElNJ6/" target="_blank" rel="external">传送门</a></li>
<li><code>connect-redis</code>: 该模块用来连接redis，往往结合redis模块和express-session模块来实现session持久化解决方案。<a href="https://itbilu.com/nodejs/npm/VJw-hEBhx.html" target="_blank" rel="external">传送门</a></li>
<li><code>cookie-parser</code>: 解析Cookie的工具。通过req.cookies可以取到传过来的cookie，并把它们转成对象。<a href="">传送门</a></li>
<li><code>cors</code>:跨域模块，只有 Web 才有跨域 CORS，移动端 iOS 与 Android 就没有，谁让 Web 能看源代码呢，如果想让XmlHttpRequest 按照自己意愿（域名、协议、端口）请求数据，那就需要跨域。<a href="https://www.jianshu.com/p/f650dfad5574" target="_blank" rel="external">传送门</a></li>
<li><code>csurf</code>: csrf，跨站请求伪造，令牌模块，防止csurf攻击，该模块依赖express-session包。<a href="http://www.cnblogs.com/y-yxh/p/5761941.html" target="_blank" rel="external">传送门</a></li>
<li><code>data2xml</code>: <a href="">传送门</a></li>
<li><code>ejs-mate</code>:ejs-mate 属于NodeJs Express 的一个母版页模块，可以方便的把页面公共部分放入ejs-mate设定的母版页内，实现代码公用。 <a href="https://my.oschina.net/TOW/blog/704962" target="_blank" rel="external">传送门</a></li>
<li><code>eventproxy</code>:一个控制并发的模块。 <a href="https://github.com/JacksonTian/eventproxy" target="_blank" rel="external">传送门</a></li>
<li><code>express</code>:nodejs用于构建web服务的框架。</li>
<li><code>express-session</code>: 用于实现session持久化的模块。<a href="https://www.cnblogs.com/htoooth/p/7340628.html" target="_blank" rel="external">传送门</a></li>
<li><code>helmet</code>:给你的express应用加上帽子，即保护你的应用。 <a href="https://juejin.im/post/5a24fd8f51882509e5438247" target="_blank" rel="external">传送门</a></li>
<li><code>ioredis</code>:</li>
<li><code>jpush-sdk</code>: </li>
<li><code>loader-builder</code>: </li>
<li><code>loader</code>: Loader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过 require 来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。<a href="http://zhaoda.net/webpack-handbook/loader.html" target="_blank" rel="external">传送门</a></li>
<li><code>lodash</code>:lodash是一个提供模块化、高性能和额外功能的实用工具库。 <a href="http://hao.jobbole.com/lodash/" target="_blank" rel="external">传送门</a></li>
<li><code>log4js</code>: 日志管理模块。<a href="http://blog.fens.me/nodejs-log4js/" target="_blank" rel="external">传送门</a></li>
<li><code>markdown-it</code>:能够快速将.md文件转换为html文件的一个模块。<a href="https://www.npmjs.com/package/markdown-it#usage-examples" target="_blank" rel="external">传送门</a></li>
<li><code>memory-cache</code>:缓存管理模块。 <a href="https://exp-team.github.io/blog/2017/11/04/js/node-cache/" target="_blank" rel="external">传送门</a></li>
<li><code>method-override</code>:改模块主要用于form表单的处理，可以将表单的GET或者POST方法转化为PUT或者DELETE方法。<a href="https://blog.csdn.net/boyzhoulin/article/details/40146197" target="_blank" rel="external">传送门</a></li>
<li><code>moment</code>:格式化时间模块，moment提供了一个函数，可用于将JavaScript的date对象包装到moment对象中。 <a href="">传送门</a></li>
<li><code>mongoose</code>: Mongoose是MongoDB的一个对象模型工具，是基于node-mongodb-native开发的MongoDB nodejs驱动，可以在异步的环境下执行。同时它也是针对MongoDB操作的一个对象模型库，封装了MongoDB对文档的的一些增删改查等常用方法，让NodeJS操作Mongodb数据库变得更加灵活简单。因为封装了对MongoDB对文档操作的常用处理方法，可以高效的操作mongodb,同时可以理解mongoose是一个简易版的orm ，提供了类似schema定义，hook、plugin、virtual、populate等机制，让NodeJS操作Mongodb数据库变得特别简单。<a href="https://i5ting.github.io/wechat-dev-with-nodejs/db/mongoose.html" target="_blank" rel="external">传送门</a></li>
<li><code>multiline</code>: 该模块可以帮助我们在js中实现多行文本。<a href="https://jarvys.github.io/2014/05/29/multilinejs/" target="_blank" rel="external">传送门</a></li>
<li><code>node-uuid</code>:使用该模块可以生成唯一标识符。 <a href="https://blog.csdn.net/dai_jing/article/details/47276921" target="_blank" rel="external">传送门</a></li>
<li><code>nodemailer</code>:该模块用来发送邮件。<a href="https://www.jianshu.com/p/f8d330d9911a" target="_blank" rel="external">传送门</a></li>
<li><code>nodemailer-smtp-transport</code>:与nodemailer类似，在之前的开发中往往和nodemailer配合，但现在凭借nodemailer一个包就可以实现邮件的发送了。</li>
<li><code>oneapm</code>: oneAPM是一个平台，可以用来对nodejs的项目做测试和监控。 <a href="https://cnodejs.org/topic/55ffca43272b724e5efefb79" target="_blank" rel="external">传送门</a></li>
<li><code>passport</code>:该模块可用来做后台用户验证。<a href="https://juejin.im/entry/57638f286be3ff006a171870" target="_blank" rel="external">传送门</a></li>
<li><code>passport-github</code>:该模块用来做github登陆的鉴权。 <a href="https://www.npmjs.com/package/passport-github" target="_blank" rel="external">传送门</a></li>
<li><code>pm2</code>:网站发布工具模块，pm2 是一个带有负载均衡功能的Node应用的进程管理器。PM2 为 Node.js 的应用提供负载管理，保持应用程序永远在线，重新启动而无需停止服务，并提供应用的管理服务。当你要把你的独立代码利用全部的服务器上的所有CPU，并保证进程永远都活着，0秒的重载， PM2是完美的。 <a href="http://www.xgllseo.com/?p=5468" target="_blank" rel="external">传送门</a></li>
<li><code>qn</code>: 这个应该是和七牛云的相关衔接模块。</li>
<li><code>ready</code>:</li>
<li><code>request</code>: </li>
<li><code>response-time</code>: </li>
<li><code>superagent</code>:http模块superagent，它是一个强大并且可读性很好的轻量级ajaxAPI，是一个关于HTTP方面的一个库，而且它可以将链式写法玩的出神入化。 <a href="https://www.jianshu.com/p/98b854322260" target="_blank" rel="external">传送门</a></li>
<li><code>utility</code>:该模块用来实现字符串加密，utility有两个很重要的方法，一个是sha1，一个是md5，通常使用他们对字符串进行加密处理。 <a href="https://www.jianshu.com/p/dd9cbcf5a02a" target="_blank" rel="external">传送门</a></li>
<li><code>validator</code>: 顾名思义，用来验证字符串合法性的npm模块。<a href="https://blog.csdn.net/zzwwjjdj1/article/details/52042194" target="_blank" rel="external">传送门</a></li>
<li><code>xmlbuilder</code>:用来创建xml文件的一个模块。 <a href="https://www.npmjs.com/package/xmlbuilder" target="_blank" rel="external">传送门</a></li>
<li><code>xss</code>: </li>
</ul>
<h3 id="2-2devDependencies"><a href="#2-2devDependencies" class="headerlink" title="2.2devDependencies"></a>2.2devDependencies</h3><ul>
<li>测试框架：<code>mocha</code>, <code>should</code></li>
<li>运行： <code>forever</code></li>
<li>请求模拟: <code>supertest</code></li>
</ul>
<h2 id="3-目录结构"><a href="#3-目录结构" class="headerlink" title="3.目录结构"></a>3.目录结构</h2><p>通过查看nodeclub的目录结构，如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- api/</span><br><span class="line">- bin/</span><br><span class="line">- common/</span><br><span class="line">- controllers/  对应mvc模式的c层</span><br><span class="line">- logs/  记录项目运行的目录</span><br><span class="line">- middlewares/  express中间件， 基本的auth， session 验证</span><br><span class="line">- models/   对应mvc的m层</span><br><span class="line">- node_module/  通过<span class="built_in">require</span>下载的包放在这个文件夹下</span><br><span class="line">- proxy/  可以看做是对model处理的加工库</span><br><span class="line">- public/  对外资源访问路径，包括web端所用的js、css和图片资源</span><br><span class="line">- test/  测试文件，用于对项目功能的单元测试，文件都是.test.js形式</span><br><span class="line">- views/   对应mvc的v层</span><br><span class="line">- api_route_v1.js  </span><br><span class="line">- app.js   应用入口</span><br><span class="line">- config.js  应用配置文件，用来记录一些配置信息</span><br><span class="line">- oneapm.js   对项目做测试和监控</span><br><span class="line">- package.json  </span><br><span class="line">- web_router.js</span><br></pre></td></tr></table></figure></p>
<p>通过目录结构可以发现，nodeclub 是以 express + mongodb + mongoose 作为基本框架的一个典型的 MVC 应用：</p>
<ul>
<li>Model: 对应目录中的model目录。涉及到这层的技术有 mongoose orm。</li>
<li>View: 对应目录中的view目录。涉及到这层的还有ejs模板。</li>
<li>Controller: 对应目录中的controller目录，涉及到的目录还有middleware目录。</li>
</ul>
<h2 id="4-应用入口app-js"><a href="#4-应用入口app-js" class="headerlink" title="4.应用入口app.js"></a>4.应用入口app.js</h2><p>神圣的入口文件，几乎每个项目都会有一个 entry，对于了解一个应用熟悉入口逻辑很重要。 下面将分步看看nodeclub 的 app.js 做了什么：</p>
<h3 id="4-1require-config"><a href="#4-1require-config" class="headerlink" title="4.1require(./config)"></a>4.1require(./config)</h3><p>通过该语句导入config.js的配置文件，后续通过<code>config.xxx</code>的语法即可调用config文件中的属性。该文件主要用于应用相关配置的设置， 主要分为：</p>
<ul>
<li>1.应用全局数据配置</li>
<li>2.数据库连接配置</li>
<li>3.session，auth 相关配置</li>
<li>4.rss配置</li>
<li>5.mail配置</li>
<li>6.第三方连接相关配置， github， weibo</li>
</ul>
<p>配置文件也是了解应用的一个好地方， 在 config.default.js 中可以看到以下信息:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debug 为 true 时，用于本地调试</span></span><br><span class="line">  debug: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  get mini_assets() &#123; <span class="keyword">return</span> !<span class="keyword">this</span>.debug; &#125;, <span class="comment">// 是否启用静态文件的合并压缩，详见视图中的Loader</span></span><br><span class="line"></span><br><span class="line">  name: <span class="string">'Nodeclub'</span>, <span class="comment">// 社区名字</span></span><br><span class="line">  description: <span class="string">'CNode：Node.js专业中文社区'</span>, <span class="comment">// 社区的描述</span></span><br><span class="line">  keywords: <span class="string">'nodejs, node, express, connect, socket.io'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加到 html head 中的信息</span></span><br><span class="line">  site_headers: [</span><br><span class="line">    <span class="string">'&lt;meta name="author" content="EDP@TAOBAO" /&gt;'</span></span><br><span class="line">  ],</span><br><span class="line">  site_logo: <span class="string">'/public/images/cnodejs_light.svg'</span>, <span class="comment">// default is `name`</span></span><br><span class="line">  site_icon: <span class="string">'/public/images/cnode_icon_32.png'</span>, <span class="comment">// 默认没有 favicon, 这里填写网址</span></span><br><span class="line">  <span class="comment">// 右上角的导航区</span></span><br><span class="line">  site_navs: [</span><br><span class="line">    <span class="comment">// 格式 [ path, title, [target=''] ]</span></span><br><span class="line">    [ <span class="string">'/about'</span>, <span class="string">'关于'</span> ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// cdn host，如 http://cnodejs.qiniudn.com</span></span><br><span class="line">  site_static_host: <span class="string">''</span>, <span class="comment">// 静态文件存储域名</span></span><br><span class="line">  <span class="comment">// 社区的域名</span></span><br><span class="line">  host: <span class="string">'localhost'</span>,</span><br><span class="line">  <span class="comment">// 默认的Google tracker ID，自有站点请修改，申请地址：http://www.google.com/analytics/</span></span><br><span class="line">  google_tracker_id: <span class="string">''</span>,</span><br><span class="line">  <span class="comment">// 默认的cnzz tracker ID，自有站点请修改</span></span><br><span class="line">  cnzz_tracker_id: <span class="string">''</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mongodb 配置</span></span><br><span class="line">  db: <span class="string">'mongodb://127.0.0.1/node_club_dev'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// redis 配置，默认是本地</span></span><br><span class="line">  redis_host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  redis_port: <span class="number">6379</span>,</span><br><span class="line">  redis_db: <span class="number">0</span>,</span><br><span class="line">  redis_password: <span class="string">''</span>,</span><br><span class="line"></span><br><span class="line">  session_secret: <span class="string">'node_club_secret'</span>, <span class="comment">// 务必修改</span></span><br><span class="line">  auth_cookie_name: <span class="string">'node_club'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 程序运行的端口</span></span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 话题列表显示的话题数量</span></span><br><span class="line">  list_topic_count: <span class="number">20</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RSS配置</span></span><br><span class="line">  rss: &#123;</span><br><span class="line">    title: <span class="string">'CNode：Node.js专业中文社区'</span>,</span><br><span class="line">    link: <span class="string">'http://cnodejs.org'</span>,</span><br><span class="line">    language: <span class="string">'zh-cn'</span>,</span><br><span class="line">    description: <span class="string">'CNode：Node.js专业中文社区'</span>,</span><br><span class="line">    <span class="comment">//最多获取的RSS Item数量</span></span><br><span class="line">    max_rss_items: <span class="number">50</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  log_dir: path.join(__dirname, <span class="string">'logs'</span>),</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 邮箱配置</span></span><br><span class="line">  mail_opts: &#123;</span><br><span class="line">    host: <span class="string">'smtp.126.com'</span>,</span><br><span class="line">    port: <span class="number">25</span>,</span><br><span class="line">    auth: &#123;</span><br><span class="line">      user: <span class="string">'club@126.com'</span>,</span><br><span class="line">      pass: <span class="string">'club'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    ignoreTLS: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//weibo app key</span></span><br><span class="line">  weibo_key: <span class="number">10000000</span>,</span><br><span class="line">  weibo_id: <span class="string">'your_weibo_id'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// admin 可删除话题，编辑标签。把 user_login_name 换成你的登录名</span></span><br><span class="line">  admins: &#123; user_login_name: <span class="literal">true</span> &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// github 登陆的配置</span></span><br><span class="line">  GITHUB_OAUTH: &#123;</span><br><span class="line">    clientID: <span class="string">'your GITHUB_CLIENT_ID'</span>,</span><br><span class="line">    clientSecret: <span class="string">'your GITHUB_CLIENT_SECRET'</span>,</span><br><span class="line">    callbackURL: <span class="string">'http://cnodejs.org/auth/github/callback'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 是否允许直接注册（否则只能走 github 的方式）</span></span><br><span class="line">  allow_sign_up: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// oneapm 是个用来监控网站性能的服务</span></span><br><span class="line">  oneapm_key: <span class="string">''</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面两个配置都是文件上传的配置</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 7牛的access信息，用于文件上传</span></span><br><span class="line">  qn_access: &#123;</span><br><span class="line">    accessKey: <span class="string">'your access key'</span>,</span><br><span class="line">    secretKey: <span class="string">'your secret key'</span>,</span><br><span class="line">    bucket: <span class="string">'your bucket name'</span>,</span><br><span class="line">    origin: <span class="string">'http://your qiniu domain'</span>,</span><br><span class="line">    <span class="comment">// 如果vps在国外，请使用 http://up.qiniug.com/ ，这是七牛的国际节点</span></span><br><span class="line">    <span class="comment">// 如果在国内，此项请留空</span></span><br><span class="line">    uploadURL: <span class="string">'http://xxxxxxxx'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 文件上传配置</span></span><br><span class="line">  <span class="comment">// 注：如果填写 qn_access，则会上传到 7牛，以下配置无效</span></span><br><span class="line">  upload: &#123;</span><br><span class="line">    path: path.join(__dirname, <span class="string">'public/upload/'</span>),</span><br><span class="line">    url: <span class="string">'/public/upload/'</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  file_limit: <span class="string">'1MB'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 版块</span></span><br><span class="line">  tabs: [</span><br><span class="line">    [<span class="string">'share'</span>, <span class="string">'分享'</span>],</span><br><span class="line">    [<span class="string">'ask'</span>, <span class="string">'问答'</span>],</span><br><span class="line">    [<span class="string">'job'</span>, <span class="string">'招聘'</span>],</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 极光推送</span></span><br><span class="line">  jpush: &#123;</span><br><span class="line">    appKey: <span class="string">'YourAccessKeyyyyyyyyyyyy'</span>,</span><br><span class="line">    masterSecret: <span class="string">'YourSecretKeyyyyyyyyyyyyy'</span>,</span><br><span class="line">    isDebug: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  create_post_per_day: <span class="number">1000</span>, <span class="comment">// 每个用户一天可以发的主题数</span></span><br><span class="line">  create_reply_per_day: <span class="number">1000</span>, <span class="comment">// 每个用户一天可以发的评论数</span></span><br><span class="line">  create_user_per_ip: <span class="number">1000</span>,</span><br><span class="line">  visit_per_day: <span class="number">1000</span>, <span class="comment">// 每个 ip 每天能访问的次数</span></span><br></pre></td></tr></table></figure></p>
<p>当数据过多的时候，我们可以将配置文件可以放在一个 config 的文件夹下面，用多个文件的方式来整理。比如运营数据配置和其他数据配置分开，因为很有可能需要做一个小的工具来让非技术人员配置相关参数。这时候可以用一个 index.js 作为 facade，相当于一个大的 node module。</p>
<h3 id="4-2require-‘-models’"><a href="#4-2require-‘-models’" class="headerlink" title="4.2require(‘./models’)"></a>4.2require(‘./models’)</h3><p>model目录对应MVC模式的m层，目录下面有个index.js文件，所以<code>require(&#39;./models&#39;)</code>相当于<code>require(&#39;./models/index&#39;)</code>，index 相当于一个模型的 facade, 做的事情分别是:</p>
<ul>
<li>1.connect mongodb</li>
<li>2.require 各个 model 模块</li>
<li>3.exports 所有的 model</li>
</ul>
<p>简而言之就是初始化了应用 model 层，模型使用 orm 框架 mogoose 来写，了解 mogoose 过后， models 部分的代码也就是秒懂了。我说的只是代码，literaly, 一个项目的核心就是 model 的设计，以前做过的任何项目都是一样， 数据库 table 的设计好坏直接影响应用的开发以及性能。</p>
<p>model目录下的文件意思为:</p>
<ul>
<li>base_model.js 基础模型</li>
<li>index.js 相当于一个模型的facade，作用上面说到过</li>
<li>message.js  消息模型，对于一个 blog 来说， 基本的只有回复消息， 这里加了关注和@消息。</li>
<li>reply.js  回复模型</li>
<li>topic.js  话题模型</li>
<li>topic_collect.js  话题集合模型</li>
<li>user.js  用户模型</li>
</ul>
<h3 id="4-3require-‘-middlewares’"><a href="#4-3require-‘-middlewares’" class="headerlink" title="4.3require(‘./middlewares’)"></a>4.3require(‘./middlewares’)</h3><p>express 的基础是 middleware，或者说 express 的基础是 connect，connect 的基础是 middleware。middleware 模式在 professional nodejs 中有一个专门的章节来讲解。何为 middleware 呢？ middleware 模式 相当于一个加工流水线（大家叫 middleware stack），每一个 middleware 相当于一个加工步骤，当出现一个 http 请求的时候，http 请求会挨着每个 middleware 执行下去。  </p>
<p>express 里处理一个请求的过程基本上就是请求通过 middleware stack 的过程： <code>* -&gt; middleware stack -&gt; 路由 -&gt; controllers -&gt; errorhandlering</code>。</p>
<p>middleware 怎样做到的， 异步的方法呢？ middleware 使用 promise 的方式来处理异步，所有每个 middleware 都有三个参数 req, res, next, 对于异步的情况， 必须要调用 <code>next()</code> 方法。不然后续的 middleware 就无法执行。 ps: debug 的时候没调用 <code>next()</code> 还不会报错，一定注意。</p>
<h4 id="4-3-1auth-js"><a href="#4-3-1auth-js" class="headerlink" title="4.3.1auth.js"></a>4.3.1auth.js</h4><p><code>auth.js</code> exports 出来的函数全部都是中间件，从变量名就完全清楚的知道到底在做什么了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-- 需要admin权限</span></span><br><span class="line">exports.adminRequired = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 需要有用户</span></span><br><span class="line">exports.userRequired = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 需要有用户并登录</span></span><br><span class="line">exports.signinRequired = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!req.session.user) &#123;</span><br><span class="line">        res.render(<span class="string">'notify/notify'</span>, &#123;error: <span class="string">'未登入用户不能发布话题。'</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-- 屏蔽用户 -_-</span></span><br><span class="line">exports.blockUser = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实就可以看到中间件的作用了，我们以前写 php 的时候每次都需要判断用户是否登录， 没登陆 redirect 到 index.php ，只不过这里的方式是通过中间件来处理。明白这里什么意思，其他的中间件模块也就秒懂了。</p>
<h3 id="4-4-require-‘-web-router-js’-和require-‘-api-router-v1-js’"><a href="#4-4-require-‘-web-router-js’-和require-‘-api-router-v1-js’" class="headerlink" title="4.4 require(‘./web_router.js’)和require(‘./api_router_v1.js’)"></a>4.4 require(‘./web_router.js’)和require(‘./api_router_v1.js’)</h3><p>express 的世界里另外一个很重要的就是route， Node.js 启动的是服务， 监听了某一端口， 接受 http or https or socket 请求,   那 url 中像 /index.php?blabla 这一串的存在怎么处理呢， express 的 router 功能就可以帮我们解析。</p>
<p>MVC 中如何将一个请求和 controller 联系起来呢， router 就是这样的纽带</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--get, post 请求</span></span><br><span class="line">app.get(<span class="string">'/signin'</span>, sign.showLogin);</span><br><span class="line">app.post(<span class="string">'/signin'</span>, sign.login);</span><br><span class="line"><span class="comment">//--使用中间件</span></span><br><span class="line">app.get(<span class="string">'/signup'</span>, configMiddleware.github, passport.authenticate(<span class="string">'github'</span>));</span><br><span class="line">app.post(<span class="string">'/:topic_id/reply'</span>, auth.userRequired, limit.postInterval, reply.add);</span><br></pre></td></tr></table></figure>
<p>router 是了解一个应用最佳的地方，一个请求如何处理， 到相应的 controller 去看就知道了。 </p>
<h3 id="4-5initialization"><a href="#4-5initialization" class="headerlink" title="4.5initialization"></a>4.5initialization</h3><p>experess initialize: app.js 中其他大多部分就是express的初始化了， 初始化流程如下：</p>
<ul>
<li>1.配置上传 upload_dir</li>
<li>2.模板引擎设置</li>
<li>3.express 通用中间件设置</li>
<li>4.pasport 中间件</li>
<li>5.自定义中间件<ul>
<li>1.auth_user</li>
<li>2.block_user</li>
<li>3.staticfile: upload</li>
<li>4.staticfile: user_data</li>
</ul>
</li>
<li>6.csrf</li>
<li>7.errorhandler</li>
<li>8.set view cache</li>
</ul>
<p>配置的顺序很重要， 中间件的执行顺序是按照定义顺序来执行的， 如果一个中间件依赖另外的中间件， 而自己先执行了， 这种情况就会错误。 常见的问题就是session配置， 一定要记得配置 session 中间件的时候， 要先配置 cookieParser。</p>
<h4 id="4-5-1session-设置"><a href="#4-5-1session-设置" class="headerlink" title="4.5.1session 设置"></a>4.5.1session 设置</h4><p>这个步骤在 initialize 里边已经有了， 不过再单独讲一下， nodeclub 使用的是 connect-mongo 来作为 session 的存储.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--cookieParser一定要在前面， 因为session的设置依赖cookie</span></span><br><span class="line">app.use(express.cookieParser());</span><br><span class="line">app.use(express.session(&#123;</span><br><span class="line">  secret: config.session_secret,</span><br><span class="line">  store: <span class="keyword">new</span> MongoStore(&#123;</span><br><span class="line">    db: config.db_name,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<h4 id="4-5-2view-helpers"><a href="#4-5-2view-helpers" class="headerlink" title="4.5.2view helpers"></a>4.5.2view helpers</h4><p>使用过 ejs 的肯定知道， ejs 里边 view helper 设置很简单， 就像赋值变量一样。 当对于一些通用的 helper 可以这样设置：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.helpers(&#123;</span><br><span class="line">      config: config,</span><br><span class="line">      Loader: Loader,</span><br><span class="line">      assets: assets</span><br><span class="line">    &#125;);</span><br><span class="line">    app.dynamicHelpers(<span class="built_in">require</span>(<span class="string">'./common/render_helpers'</span>));</span><br></pre></td></tr></table></figure></p>
<h4 id="4-5-3github-pasport-initialize"><a href="#4-5-3github-pasport-initialize" class="headerlink" title="4.5.3github pasport initialize"></a>4.5.3github pasport initialize</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// github oauth</span></span><br><span class="line">    passport.serializeUser(<span class="function"><span class="keyword">function</span> (<span class="params">user, done</span>) </span>&#123;</span><br><span class="line">      done(<span class="literal">null</span>, user);</span><br><span class="line">    &#125;);</span><br><span class="line">    passport.deserializeUser(<span class="function"><span class="keyword">function</span> (<span class="params">user, done</span>) </span>&#123;</span><br><span class="line">      done(<span class="literal">null</span>, user);</span><br><span class="line">    &#125;);</span><br><span class="line">    passport.use(<span class="keyword">new</span> GitHubStrategy(config.GITHUB_OAUTH, githubStrategyMiddleware));</span><br></pre></td></tr></table></figure>
<h2 id="5-用户注册"><a href="#5-用户注册" class="headerlink" title="5.用户注册"></a>5.用户注册</h2><p>user 是每个应用都会处理的基本， 注册登录登出， 看看 nodeclub 做了哪些事情：</p>
<p>1.路由：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--设置能否直接注册， 不能的话通过github注册</span></span><br><span class="line"><span class="keyword">if</span> (config.allow_sign_up) &#123;</span><br><span class="line">  app.get(<span class="string">'/signup'</span>, sign.showSignup);</span><br><span class="line">  app.post(<span class="string">'/signup'</span>, sign.signup);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  app.get(<span class="string">'/signup'</span>, configMiddleware.github, passport.authenticate(<span class="string">'github'</span>));</span><br><span class="line">&#125;</span><br><span class="line">app.post(<span class="string">'/signout'</span>, sign.signout);</span><br><span class="line">app.get(<span class="string">'/signin'</span>, sign.showLogin);</span><br><span class="line">app.post(<span class="string">'/signin'</span>, sign.login);</span><br></pre></td></tr></table></figure>
<p>2.controller &amp; model：sign.signup:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">sanitize = validator.sanitize;</span><br><span class="line">check = validator.check;</span><br><span class="line">exports.signup = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//--xss 消毒</span></span><br><span class="line">  <span class="keyword">var</span> name = sanitize(req.body.name).trim();</span><br><span class="line">  name = sanitize(name).xss();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//--validations</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    check(name, <span class="string">'用户名只能使用0-9，a-z，A-Z。'</span>).isAlphanumeric();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    res.render(<span class="string">'sign/signup'</span>, &#123;error: e.message, name: name, email: email&#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">//--用用户名登录或者email登录</span></span><br><span class="line">  query = &#123;<span class="string">'$or'</span>: [&#123;<span class="string">'loginname'</span>: loginname&#125;, &#123;<span class="string">'email'</span>: email&#125;]&#125;</span><br><span class="line">  User.getUserByQuery(query, &#123;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    pass = md5(pass);</span><br><span class="line">    ...</span><br><span class="line">    User.newAndSave(name, loginname, pass, email, avatar_url, <span class="literal">false</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 发送激活邮件</span></span><br><span class="line">      mail.sendActiveMail(email, md5(email + config.session_secret), name);</span><br><span class="line">      res.render(<span class="string">'sign/signup'</span>, &#123;</span><br><span class="line">        success: <span class="string">'欢迎加入 '</span> + config.name + <span class="string">'！我们已给您的注册邮箱发送了一封邮件，请点击里面的链接来激活您的帐号。'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-mongoose的使用"><a href="#6-mongoose的使用" class="headerlink" title="6.mongoose的使用"></a>6.mongoose的使用</h2><p>一个应用通常会遇到这样的情景， 一个页面需要的数据包括， 文章列表， 评论列表，用户数据，广告数据， other stuff…   问题是每个都是异步的， 怎么办。 user 数据获取过后的 callback 调用文章列表获取， 文章列表获取的 callback 调用评论列表的获取… 这样就太蛋疼了。  nodeclub 使用了 eventproxy 模块优雅的解决这样的问题：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> proxy = EventProxy.create(<span class="string">'tags'</span>, <span class="string">'topics'</span>, <span class="string">'hot_topics'</span>, <span class="string">'stars'</span>, <span class="string">'tops'</span>, <span class="string">'no_reply_topics'</span>, <span class="string">'pages'</span>, render);</span><br><span class="line">  proxy.fail(next);</span><br><span class="line">  Tag.getAllTags(proxy.done(<span class="string">'tags'</span>));</span><br><span class="line">  Topic.getTopicsByQuery(query, options, proxy.done(<span class="string">'topics'</span>));</span><br><span class="line">  User.getUsersByQuery(&#123; is_star: <span class="literal">true</span> &#125;, &#123; limit: <span class="number">5</span> &#125;, proxy.done(<span class="string">'stars'</span>));</span><br></pre></td></tr></table></figure></p>
<p>当然异步处理的方法有很多:</p>
<ol>
<li>基于事件的：eventProxy</li>
<li>基于promise的：Async.js Q.js, when.js</li>
<li>基于编译的：continuation, wind</li>
<li>基于语言语法的：yield， livescript</li>
</ol>
<h2 id="7-消息"><a href="#7-消息" class="headerlink" title="7.消息"></a>7.消息</h2><p>原先以为有动态的消息推送， 有队列处理， 但是没有</p>
<p>在 Sublime text 里边全局搜索 sendReply2Message 会发现是在 controller/reply.js 里边调用的， 也就是说，消息是直接触发的。</p>
<h2 id="8-开发"><a href="#8-开发" class="headerlink" title="8.开发"></a>8.开发</h2><h3 id="8-1测试"><a href="#8-1测试" class="headerlink" title="8.1测试"></a>8.1测试</h3><p>一个项目必定离不开测试， nodeclub基于mocha BDD测试框架， 一切的前提假设至少能看懂jasmine或者mocha或者任何一个BDD风格的测试代码。</p>
<p>所有的测试文件都在test文件夹下，文件名以test.js结尾，打开即看到app.js:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'../app'</span>);</span><br><span class="line">describe(<span class="string">'app.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//--before， 执行it的前面会执行</span></span><br><span class="line">  before(<span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//--done, 异步方法</span></span><br><span class="line">    app.listen(<span class="number">3001</span>, done);</span><br><span class="line">  &#125;);</span><br><span class="line">  after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    app.close();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'should / status 200'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//--使用 app.request()就可以模拟请求了？ 这个api哪里来的， 求解释？</span></span><br><span class="line">    app.request().get(<span class="string">'/'</span>).end(<span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">      res.should.status(<span class="number">200</span>);</span><br><span class="line">      done();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//--按理说应该是可以正常运行了但是我一直出现这个错误:</span></span><br><span class="line"><span class="comment">//--connect ADDRNOTAVAIL 知道的求解释</span></span><br><span class="line"><span class="comment">//--我尝试用supertest直接测试， 但是也是一直timeout， mocha</span></span><br><span class="line"><span class="comment">//--里边加大timeout时间， 结果就是一直没反应。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--分析原因， express版本问题， nodeclub中express的版本还是2.x, 所以才会有</span></span><br><span class="line"><span class="comment">//--app.request(), app.close()这些api</span></span><br><span class="line"><span class="comment">//--第二个原因， 到supertest官网， 发现人家都已经转战到superagent项目了， 于是我写了下面这个测试脚本， 可以通过了</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> should = <span class="built_in">require</span>(<span class="string">'should'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> superagent = <span class="built_in">require</span>(<span class="string">'superagent'</span>);</span><br><span class="line"><span class="keyword">var</span> app = express()</span><br><span class="line">app.get(<span class="string">'/user'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">    res.send(<span class="number">200</span>, &#123;</span><br><span class="line">        name: <span class="string">'tobi'</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">describe(<span class="string">'myapp.js'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.timeout(<span class="number">5000</span>)</span><br><span class="line">    before(<span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">        app.listen(<span class="number">21</span>, done);</span><br><span class="line">    &#125;)</span><br><span class="line">    after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// app.close()</span></span><br><span class="line">    &#125;)</span><br><span class="line">    it(<span class="string">'should /status 200'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">        agent = superagent.agent()</span><br><span class="line">        agent.get(<span class="string">'http://localhost:21/user'</span>).end(<span class="function"><span class="keyword">function</span>(<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(err, res)</span><br><span class="line">          res.should.have.status(<span class="number">200</span>);</span><br><span class="line">          res.text.should.include(<span class="string">'tobi'</span>);</span><br><span class="line">          <span class="keyword">return</span> done();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="8-2运行"><a href="#8-2运行" class="headerlink" title="8.2运行"></a>8.2运行</h2><p>nodejs 是单线程应用， 如果我们用 node 命令来运行我们的应用， 当出现一个小错误， 它就挂了。 然后没有然后了。 避免这种问题的方法有如下工具：</p>
<ol>
<li>forever</li>
<li>nodemon</li>
<li>supervisor nodeclub 使用 forever 来运行项目， 使用这类工具的好处就是， 当有代码改动过后， 会自动的重启应用。 不必每次自己去运行 node *.js</li>
</ol>
<p>总的来说看起来还是很吃力的，需要学习的还有很多，希望自己快速成长，早日成为团队里能够独当一面的大侠吧。接下来学习这个教程：<a href="https://github.com/chyingp/nodejs-learning-guide" target="_blank" rel="external">nodejs学习笔记</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[想对大家说的话]]></title>
      <url>http://codingxiaxw.cn/2017/11/21/69-the-words-want-to-say/</url>
      <content type="html"><![CDATA[<p>一路走来很不容易，刚好收到很多朋友的私信问我最近在忙些什么，趁着现在没事做、时间多，脑子里还有点货，就借这个机会在博客上记录一路走来的历程，很励志，希望能给那些正在或准备走编程行业的人一些正能量。内容有点长，感兴趣的就当做励志小说阅读吧。</p>
<a id="more"></a>
<hr>
<h2 id="这篇博客背后的故事"><a href="#这篇博客背后的故事" class="headerlink" title="这篇博客背后的故事"></a>这篇博客背后的故事</h2><p>收到一些朋友的微博私信，说能不能给 Java 开发的新手们一些指导，我只能说指导谈不上，毕竟我也很多东西正在学习中，与此同时一大学同学准备转行 JavaWeb ，可以说是从头开始，那么我就姑且以一个过来人的身份给一些建议，只希望大家在学习的过程中能够少走写弯路。</p>
<hr>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><blockquote>
<p>没错我就是别人眼中的那个“offer收割机”</p>
</blockquote>
<p>很多朋友好奇我的年龄，那么我今天就透露下，本人在读大四学生，就读于武汉一所普通 211 高校， 2018 届毕业生。经历过秋招后的自己，如今收获了<strong>美团、滴滴出行、斗鱼、拼多多</strong>以及<strong>苏宁</strong>的校招 offer ，因为不太喜欢北上广的生活节奏，所以选择了<strong>南京苏宁</strong>的 offer ，以后就是苏宁集团的<strong>Java研发工程师</strong>了。(2018.1.20日再更：已弃坑，和苏宁毁约并赶在春招前签了另一家更好的公司)  </p>
<hr>
<h2 id="写在前边的话"><a href="#写在前边的话" class="headerlink" title="写在前边的话"></a>写在前边的话</h2><p>早前自学 Android 开发，在知乎上搜到 stormzhang 给大家写的 Android 自学方向，对于当时没有一点 Android 方向及基础的我甚至于一些新手来学习 Android 都受益匪浅。如今3年多后，自己也来写篇博客记录自己的 Java 学习之路，以便给后来初学者提供一点方向上的参考。(划重点了  </p>
<p>想写这篇文章很久了，一方面是为了记录自己大学的奋斗历程供以后回味，让以后稍有成就的自己感谢现在努力的自己；另一方面也是为了给那些不知道如何学习 Java 的人提供自己的学习路线以供参考。</p>
<p>为了证实自己脑中还是有点货的，所以先附上自己大二、大三两年来看过的书籍吧:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/java_study.jpeg" alt=""></p>
<p>可以看出我看过的书籍比较杂，大三下学期从寝室搬出去住了，后来看过的一些例如高并发、多线程啥的进阶书籍都分散放在不同的地方了，我也懒得再把这些书籍都拼凑在一起重新拍照了。  </p>
<p>想了想有必要给下上述图片的出处——来自 2017 年 1 月 21 号朋友圈的截图:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/WechatIMG24.jpeg" alt=""></p>
<p><strong>(日常打广告):</strong>对于很多还不知道我 Github 地址的朋友们，特地为你们附上 Github 传送门:<strong><a href="https://github.com/codingXiaxw" target="_blank" rel="external"> codingXiaxw 的 github </a></strong>  (也可以直接拉到文章最后面查看链接 </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-11-22%20%E4%B8%8A%E5%8D%8812.11.14.png" alt=""></p>
<p>有人问我 Github 上怎么不活跃了，因为我已经很久没有写项目了呀，目前也已经拿到了想要的 offer ，剩下的大四时光当然要好好珍惜和朋友们一起玩耍 + 打游戏了呢。</p>
<p>先来说说我的故事吧。</p>
<hr>
<h2 id="我的故事"><a href="#我的故事" class="headerlink" title="我的故事"></a>我的故事</h2><blockquote>
<p>灯光师准备，舞台准备，麦克风准备。</p>
</blockquote>
<h3 id="1-高考-—-年少轻狂"><a href="#1-高考-—-年少轻狂" class="headerlink" title="1.高考 — 年少轻狂"></a>1.高考 — 年少轻狂</h3><p>都说高考前是一个分手季，所以高考前一个月别人忙着分手，而我却因为沉浸在新结的一段恋爱中忘乎所以不能自拔，所以高考后不幸被告知分数只能上一所普通的 211 高校，坐标武汉，学校叫<strong>华中师范大学</strong>(我们校友一般称呼它<strong>广埠屯女子大学</strong>或是<strong>雄楚大道停水大学</strong>。  </p>
<p>既然是师范大学，所以学校的名牌专业肯定就是师范专业，顶尖的教育资源肯定也是师范，所以对于我们这种计科专业的学生，老师教的专业知识其实都是一些基础一些皮毛，进阶的道路当然都需要靠自己的自学。(以至于我上了大二以后就没去教室听课了，大四的时候成绩单发下来才发现自己曾今挂了好多科，当然了这些都是后话</p>
<h3 id="2-大一-—-彷徨"><a href="#2-大一-—-彷徨" class="headerlink" title="2.大一 — 彷徨"></a>2.大一 — 彷徨</h3><p>大一一年算是过的很迷茫，参加了点社团，打了打篮球，中国各地到处走了走，刷了刷美剧，谈了谈恋爱，这一年也就昏过去了。以至于我到现在都还在抱怨那时候的自己，”要是自己从大一开始就自学 Java 编程，那我现在不早就成大神了啊”。当然也不能算是白过，学校大一给开的c语言我学的挺认真，期末考 100 分的总分我拿了 98 分，算是为自己的 Java 编程道路开了一个好头吧。另外参加的社团有滑板社、街舞社、粤语社、魔术社、 B-Box 社，所以大一过去后的自己也算是学到了不少的特长吧。</p>
<p>大一的暑假，才算是揭开了自己在 Java 编程道路上的帷幕吧。那时候学校给开的Java课程安排在大二下学期，我在一哥们的带领下就自己自学起了 Java ，当时买的一个叫《 Java 从入门到精通》的书籍，对自己入门 Java 也起到了不少的帮助。花了一个月的时间用来看完这本书，当然我说的看完不只是单单的看完了，而是在自己的电脑上搭建好相关的 Java 环境后根据书中的每行代码，都试着在自己的电脑上敲出并运行然后检查 bug 然后再修改 bug 。加了很多学习 Java 的 qq 群，在里面看到不少前辈给新人推荐使用《 head in first 》系列，所以我又买了这本书进行阅读，算是对巩固自己的 Java 基础起到了很大的巩固作用吧。  </p>
<p>学完 Java 的语法，需要写一些项目巩固自己学到的知识，这里推荐路人甲整理的一些项目源代码<a href="https://zhuanlan.zhihu.com/p/22062736" target="_blank" rel="external">有哪些适合新手的 Java 项目</a></p>
<h3 id="3-大二-—-呐喊"><a href="#3-大二-—-呐喊" class="headerlink" title="3.大二 — 呐喊"></a>3.大二 — 呐喊</h3><p>写过几个 Java 项目后想进阶继续学习，所以又到了所谓的迷茫期了，就上知乎搜了搜很多人关于如何系统学习 Java 知识的资料(当时自己还没有 JavaWeb 这个词的观念)，但是不像学习 Android、前端知识样别人都提供了详细的系统学习资料，这一块的资料少之又少，其实根本就没有前辈指点。看到身边有在学 Android 的前辈，知道了 Android 是用 Java 语言进行开发的，就想着，好吧，那我也学习 Android 吧，至少还有人可以请教方向，然后他给了我 stormzhang 发表的那篇著名的<a href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/" target="_blank" rel="external"> Android 学习道路</a>，从此便开始了我半年之久的 Android 的学习道路。这里我就不说如何系统学习 Android 了，想看的自己点击链接进去阅读吧，我这里主要介绍的就是自己的 JavaWeb 过程。</p>
<p>这个大二走来真是不容易，我算是先耗费了大半年的时间在 Android 开发上，写了很多的app(项目源码请参考我的 Github )，然后转战 JavaWeb 花了半年时间学完了 JavaWeb 的基本知识以及三大框架，也写了很多的 Web 项目(参考我的 Github )。</p>
<p>当然我真的超级感谢大二这一年的自己，沉住气来将全部时间花费在编程上，帮助积累了大量的知识和项目经历，让我在大三新学期开学就较身边的同学们提前走在了去公司实习的道路上。(至于这一年里我是如何系统的学习 JavaWeb ，参考下面的“ Java 学习路线”标题。</p>
<h3 id="4-大三-—-朝花夕拾"><a href="#4-大三-—-朝花夕拾" class="headerlink" title="4.大三 — 朝花夕拾"></a>4.大三 — 朝花夕拾</h3><p>大三当然就凭借自己大二一年积累的知识与项目经验，顺利拿到了学校附近几家科技公司的实习 offer ，然后便开始了长达一年的在公司与学校宿舍之间二点一线的码农生活。</p>
<p>也感谢大三这一年自己每天奔波在公司与学校宿舍这两点一线之间，这些丰富的实习经历又让我在 2017 年 3 月份的春招和 2017 年 9 月份的秋招中荣获了不少大公司的青睐，以至于最后得到了自己满意的 offer 。</p>
<h3 id="5-大四-—-感恩"><a href="#5-大四-—-感恩" class="headerlink" title="5.大四 — 感恩"></a>5.大四 — 感恩</h3><blockquote>
<p>感恩室友，感恩朋友，感恩亲人，感恩那些所有该感恩的</p>
</blockquote>
<p>最累的就是大三的暑假和大四开学的前几个月了，17年3月份为了准备阿里、腾讯等公司的春招，因为大公司注重算法，所以我就辞掉了自己的实习工作，在图书馆准备了长达3个月的面试准备，具体表现在: LeetCode 上的题我刷了两遍、剑指 offer 上的题我刷了两遍、算法的书我看了不少、网上搜到的面经我也背了不少。总之，快临近大三期末的时候我就是各种电话面试、笔试以及现场面试。  </p>
<p>因为不满意自己春招时找到的实习公司，所以暑假和大四我又早早的就开始了秋招的准备，后来就又是背面经、刷算法、写项目、笔试、面试，东奔西跑，真是累的一匹，好在皇天不负苦心人，最后的自己终于也成了别人眼中的” offer 收割机”，也终于完美的结束了自己的秋招。  </p>
<hr>
<h2 id="永远不要嫌晚"><a href="#永远不要嫌晚" class="headerlink" title="永远不要嫌晚"></a>永远不要嫌晚</h2><blockquote>
<p>不管何时何地做你想做的事永远都不嫌晚，如果你发现生活不如意，我希望你有勇气重来。 —出自《本杰明.巴顿奇事》 </p>
</blockquote>
<p>我为什么要在拿出干货前给大家介绍我这么无聊的经历呢？是想告诉大家永远不要嫌晚，你看我大一暑假开始学习编程，从一个编程小白到学完有关 JavaWeb 的所有基础知识点用了多久？真正花在 JavaWeb 上的时间不超过半年，而这半年里我还学了好多好多其他的互联网知识。所以大家永远不要嫌晚，即使你现在都已经大四了面临找工作了，也不要放弃不要急躁，只要下定决心从现在起开始学习，毕业前也一定会收获让你满意的 offer 。</p>
<p>好了道理扯了这么多了，很多人也该不耐烦了，特此奉上你们想要的干货:(请滑动你的鼠标</p>
<hr>
<h2 id="我的JavaWeb学习路线"><a href="#我的JavaWeb学习路线" class="headerlink" title="我的JavaWeb学习路线"></a>我的JavaWeb学习路线</h2><p><strong>更：</strong>有人觉得我下面提供的 JavaWeb 自学路线九个阶段还是过于抽象，所以我在文章最下方开了一个“更新”章节，觉得抽象的请将下拉框拉到文章最底部自行进行查看另一种关于“我推荐的JavaWeb学习路线”的说法，仅供参考，有不足还请多多指教。</p>
<ul>
<li><strong>第一阶段:</strong> Java 基础，包括 Java 语法，面向对象特征，常见API，集合框架。(基础）</li>
<li><strong>第二阶段:</strong>Java API：输入输出，多线程，网络编程，反射注解等，Java 的精华部分。(重点)</li>
<li><strong>第三阶段:</strong>数据库 SQL 基础，包括增删改查操作以及多表查询。Oracle  Mysql 二选一吧。(我的项目都是用的 Mysql</li>
<li><strong>第四阶段:</strong> JDBC 编程:包括 JDBC 原理， JDBC 连接库， JDBC API，虽然现在 Hibernate 比 JDBC 要方便许多，但是 JDBC 技术仍然在使用， JDBC 思想尤为重要。</li>
<li><strong>第五阶段:</strong> JDBC 深入理解高级特性：包括数据库连接池，存储过程，触发器， CRM 思想(高级)这个比较不好懂，有时间的可以学习。</li>
<li><strong>第六阶段:</strong> Servlet 开发，从此开始踏入 JavaWeb 开发的重要一步，包括XML， Tomcat 服务器的安装使用操作， HTTP 协议简单理解，Servlet API 等， Java Web 开发的基础。(重要) </li>
<li><strong>第七阶段:</strong> JSP 开发: JSP 语法和标签，自定义标签， EL , JSTL 库了解以及 MVC 三层架构的设计模式理念。</li>
<li><strong>第八阶段:</strong>三大框架- Spring 、 SpringMVC 、 MyBatis ， JavaWeb 的精华部分(重要) </li>
<li><strong>第九阶段:</strong>当学习完这些知识后，你就可以深层次的学习一些企业框架， Maven 、 redis 、 log4j 等等。</li>
</ul>
<p>记住每当学完一个知识点，要结合相应的项目来巩固自己学到的知识，可以参考我的博客，上面的所有文章就是按照学习 JavaWeb 时纪录下的全过程，看完我的博客你们就可以看到我的成长了。 </p>
<p>学完这些阶段你就可以出去找个实习了，只有在外面接触到实践项目了，你才会发现在公司学的东西跟你在学校老师讲的有多大区别。很多人问我，大三就出来实习那学校的课程怎么办？这个得看看自己学校的规定了，我们学校老师本着“教人为本”的思想，只要我们学生掌握了这门课的精髓并在期末考试中拿到了60分，便也没有再去听这门课的必要了。</p>
<hr>
<h2 id="用正确的方法"><a href="#用正确的方法" class="headerlink" title="用正确的方法"></a>用正确的方法</h2><h3 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1.硬件"></a>1.硬件</h3><ul>
<li><strong>电脑-推荐Mac</strong></li>
</ul>
<p>首先声明我不是果粉，个人 Windows ， Linux ， Mac OX 系统均用过， 只能说 Windows 上面的开发工具简直难以恭维，尤其命令行超级难用，而 Linux 自己必须得花不少时间在折腾中，更是不适合新手了， Max OS 是我认为迄今为止最好用的系统，没有之一， 所以如果你不差钱的话，强烈建议入手一台 Mac ，推荐 Pro 系列， 当然它的价格确实比较昂贵，如果暂时入手有困难，推荐以后手头宽裕的时候再入手吧，会带给你质的体验。( Google 的工程师们都在用 Mac ，应该比较有说服力吧)</p>
<h3 id="2-开发环境"><a href="#2-开发环境" class="headerlink" title="2.开发环境"></a>2.开发环境</h3><ul>
<li><strong><a href="https://www.jetbrains.com/idea/" target="_blank" rel="external">IDEA</a></strong></li>
</ul>
<p>现在很多钟爱 eclipse 的工程师都在搬向 IDEA ，网上可以搜到很多资料，都说 IDEA 比 eclipse 强大。我是从 eclipse 转向 IDEA 的，过程确实很艰难，但熟悉了 IDEA 的编程环境后发现” IDEA 比 eclipse 强大”这句话不是没有根据的。当然，我这里只是建议你用 IDEA ，具体使用权还是在你的手里。</p>
<ul>
<li><strong>Google</strong></li>
</ul>
<p>技术问题还是尽量 Google 吧，所以需要你有一台会翻墙的电脑，就不要吝啬了买个 vpn 吧。俗话说，不会翻墙的程序员不是好程序员.</p>
<ul>
<li><strong>Git</strong></li>
</ul>
<p>作为版本管理工具的 svn 与 git ，现在相信处在技术一线的大家应该都改为被 Github 带火了的 git 了吧。</p>
<ul>
<li><strong>Github</strong></li>
</ul>
<p>一个免费的远程仓库，如果是个人的开源项目，放到 GitHub 上是完全没有问题的;还是一个开源协作社区，通过 GitHub ，既可以让别人参与你的开源项目，也可以参与别人的开源项目。大家有写过的项目就往上面放好了，另外想告诉大家的是，现在很多公司在招聘人才时都会查看面试者的 Github ，我当初轻松的就找到了实习工作很大原因就是 Github 上的项目丰富，所以面试时简单被面试官问了点技术问题就很轻松的被录用了。</p>
<ul>
<li><strong>Linux命令</strong></li>
</ul>
<p>学习中因为用的 mac ，所以当然经常在 Linux 系统下编程，对于一些基本的 Linux 命令也是非常熟悉的。我也没有刻意买一本书去学习这些命令，我是遇到啥 Linux 命令了就会打开 google 搜点教程学习一下，当然需要的话大家也可以买一本书去学，这里推荐《鸟叔的 Linux 私房菜》。至于为什么要学 Linux ？自己上网搜搜吧。</p>
<ul>
<li><strong><a href="https://stackoverflow.com/" target="_blank" rel="external">Stack Overflow</a></strong></li>
</ul>
<p>一个程式设计领域的问答网站，开发过程中要是遇到解决不了的 bug 信息，只要把 bug 信息往这上面一放，基本就能搜到你要的解决方法了，当然了这个网站有点考验你的英文功底，当然也需要翻墙才能访问了。</p>
<p>建议大家擅用开发工具，好的工具会给自己的开发带来很大的帮助。</p>
<h3 id="3-不同水平的人用不同的方法"><a href="#3-不同水平的人用不同的方法" class="headerlink" title="3.不同水平的人用不同的方法"></a>3.不同水平的人用不同的方法</h3><p>在这里我必须强烈推荐新手们结合视频学习，身为过来人我的很清楚一开始入门很难，只是看书或者资料难以理解，而这时候结合视频讲解，加上自己的书籍与实战，会起到事半功倍的效果。所以不要小看了视频的作用，当然现阶段的我完全不需要去看视频，因为视频讲解的有些慢，但是对于新手们的作用非常巨大。视频学习有很多，但大都差不多，我也没法推荐最好的给你，只是以我自己的角度觉得质量还不错。</p>
<p>当然了，看视频的时候也是要跟着视频敲代码的，当然别忘了随时记下笔记，我就搭建了这样一个博客，用于记录自己学习 JavaWeb 的整个历程。说到这里，我有必要插一个插曲。记笔记的好处很多:你可以网上搜搜“我为什么要写博客”，讲这些好处的人非常多，因为人都是健忘的，你很难保证今天学了这些知识然后就让这些知识永远记录在你的脑海中了，这是不可能的，所以记下笔记，会很方便你以后忘记这些知识时然后回过头来进行复习加深印象，不然后面吃到亏可别怪我没提醒你 。当入门这种技术后，当然还是看书，当然别忘了随时记下笔记，记住一定要写的详细，其实我写过的一些 JavaWeb 项目都很简单，但却得到了很多人的 star ，我仔细思索了下原因，不是因为我很牛，大概是因为我的开发文档写的很详细十分适合那些刚入门的新人进行学习吧。至于视频，网上搜一下马士兵 Java 视频教程，资料很多，据说这个老师是 Java 讲的最好的一个讲师了。</p>
<p>当然那些有些基础的人，就直接撸书籍吧，毕竟视频讲的比较慢，较书籍需要花费的时间太多。</p>
<hr>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>语言只是你学习编程技术的第一道选择，对于语言的学习你可以选择 java 、 c++ 、 php 、 python ，看个人兴趣吧；入门这种语言后，你要经历的是第二道选择，例如我学的是 Java ，入门后接下来你要进行第二道选择，我们需要思考可以用 Java 这门语言去干嘛，所以你需要从 web 系统的开发(就是写后台嘛，称为 JavaWeb 开发人员)、或是 Android 开发者中选择其一。学习的时候一定要记住经常思考，带着问题去编程。</p>
<p>每天坚持10小时的代码开发，如果不能做到？建议洗洗睡吧，当然很多时候你都会感到枯燥，这事正常的，我很多时候也会觉得枯燥，问了身边志同道合的人，大多数人都会这样，坚持一下吧，当然兴趣还是最好的老师。毕竟看到一个新鲜的技术，你难道不想自己学习好这门技术后自己写一个漂亮的东西吗？</p>
<p>我在学习 Android 的时候就是看到什么就写什么，每天早上得要闹钟叫起吧？那我就自己写一个闹钟，何必借助系统自己的呢？想随时观看自己所在城市的天气预报，但又不喜欢系统的界面？我当时就搜到气象局的天气预报 API 接口，然后自己写了一个天气预报的 app 。这样的 Android 项目写了很多，代码都上传至了 Github 。</p>
<hr>
<h2 id="序幕"><a href="#序幕" class="headerlink" title="序幕"></a>序幕</h2><p>学习是一个漫长的过程，需要大家不断克服路途中遇到的困难，要始终坚持心中的信念。太久没写技术博客都有点生疏了，本篇是一直在我的文件里憋着，这几天熬了几个通宵耐着性子就给大家整理出来了，可能比较杂，这两天想到什么细节了再补充。最后希望大家都能学有所成，祝大家都能收获满意的 offer 。</p>
<h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p><strong>update in 2018.3.19 :
</strong>欢迎加入我的Java交流1群:659957958。**</p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><h3 id="2018-1-31更"><a href="#2018-1-31更" class="headerlink" title="2018.1.31更"></a>2018.1.31更</h3><p>赶在18年春招开始之前补充点信息，收到很多人的私信问除了上面介绍的Java基础和项目经验，还需要具备哪些技能才能在春招中展露头脚，我这里补充点信息再教大家一个面试前的准备小技巧。  </p>
<p>基础知识和框架之类的，加上自己所做的项目应付小公司的面试应该没多大问题了。但春招基本都是大公司才有的，除了上面说的基础，大公司对算法、数据结构、网络、计算机基础、Linux系统相关命令、JVM内存模型、GC算法啥的都挺看重的。  </p>
<p>大家也不要针对某一点就去买相关的书籍去看，这样效率太低下了，教大家一个准备面试的小技巧，打个比方，就是如果你想去面阿里巴巴，你就直接在搜索引擎中搜“阿里巴巴面试经验”，然后针对别人的面经列举出来的面试题啥的，针对你不会的题再去搜索引擎中搜相应的博客查看知识讲解，这样效率最高了，当然要是实在有摸不清的就建议撸书籍吧，像之前我为了摸清JVM相关知识，特地花了3天时间看完了《深入理解JVM虚拟机》，撸完就记忆深刻了。另外在校学生要是有丰富的实习经历，也是会成为春招以及今后秋招的一个闪光点的～</p>
<h3 id="2018-6-30更"><a href="#2018-6-30更" class="headerlink" title="2018.6.30更"></a>2018.6.30更</h3><p>很多小白对我写的方向还是感到过于抽象，也收到很多人的私信能否让我给想入门计算机的小白一个清晰的路线，想了很多，下面这段话是我给一位在读985大三在纠结是出国考研还是即刻就入计算机的读者写的方向，大家可以参考下:  </p>
<p>**首先要定方向，本科毕业只能搞开发，开发又分很多种，那么你想从事那行开发呢？定好方向你就要学一门编程语言，对于我熟悉并擅长的 Java 编程语言，以后可以搞Android、web后台、服务器；可以选 python 编程语言，以后可以搞机器学习、人工智能(这门编程语言适合读研的人学)；可以选 c++ ，也是用来写后台的语言，类似于 Java ，但市场上 Java 比 c 要更火，不过 c 往往用来搞和硬件打交道的东西，比如嵌入式开发，可以选 js ，用来搞前端。现在市场上最缺的就是前端工程师和 Java 开发工程师了。那么“学完所有的知识”是什么意思呢？比如你选择了 Java ，想要从事 web 后台开发，那么接下来你就要学习 Java 基础知识（1个月），然后用Java基础知识模仿别人的项目写几个小项目,(半个月)，学习项目链接在我的第一篇博客中给出过，然后接下来就是JavaWeb基础知识（1个月，基本就是 servlet + jdbc + jsp ），然后用 servlet + jdbc 写个项目，可以参照我 github上 的 customer 项目(1周)，然后去学 JavaWeb 三大框架 ssm (半个月)，学完用 ssm 写个项目，参考我 GitHub 上的 seckill 项目(半个月)。搞定。当然，这只是 Java 语言方面的，找公司时面试官还会考你算法、数据结构、计算机网络、Linux，这些知识你可以买相应的书籍在学习 Java 的同时翻一翻看一看。反正我大学期间都是每天花费10小时在这些知识上，你看你能不能坚持吧。其实编程不难，而且你是 985 ，简历那关很好过的，只要过了后面的技术面试，就能拿到 offer 。这是针对你打算本科毕业就工作我谈的，接下来谈谈你读研的事。如果觉得时间太紧的话，那就只有读研了，秋招在9月份开始，考研在12月，如果觉得一定考研，那么现在开始就先主要准备考研的知识点吧，穿插着可以学些上面跟你说的 Java 知识，如果12月份考研失利，这样你还可以在12月份过后继续寻找一份软件开发工程师的岗位.</p>
<hr>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some infos by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[杂谈]]></title>
      <url>http://codingxiaxw.cn/2017/04/12/68-chat/</url>
      <content type="html"><![CDATA[<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>近两天一直信赖的图床因为欠费导致账户被冻结，所以博客中的图片都无法显示，今天看了小伙伴们的留言才发现，嗯目前为止博客系统都正常恢复了，也对造成不便的小伙伴表示一声抱歉啊嘿～(然而我的评论区被莫名出现的水军轰炸，难道是因为图床欠费了的原因？吓得我赶紧为图床充了30块钱强行续了一命，然后花了20多分钟删除了近300条的垃圾评论信息</p>
<a id="more"></a>
<h2 id="汇报"><a href="#汇报" class="headerlink" title="汇报"></a>汇报</h2><p>消失了近两个月，收到很多一路跟着我的文章走过来的读者的私信，问我最近在研究啥新技术怎么不更新博客了，因为最近确实有点忙，一方面要准备措不及防的春招，另一方面也因为技术一直止步不前，所以看了很多的书籍来突破目前的瓶颈期。待我突破这个瓶颈期，忙过这个春招季，也会写篇干货给伙伴们分享自己的所得所失。</p>
<h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><p>与读者经常通过微博、知乎、邮件进行交流，很多我都挑重点的回复了，没收到我回复的也不要怪我，毕竟私信太多真的有时候看不过来～当然次数最多、效率也最高的交流方式当然是通过底下多说的评论区了，然而最近收到一个噩耗:多说公司由于业务调整，将于2017年6月1日停止服务。所以我到时候还要操心考虑如何将目前评论区的数据进行迁移，然后再在博客上安装另一个为评论服务的三方插件，(烦死咯) 不然丧失了这个读者为我指出错误的评论区，我该拿什么去拯救～ 然而，我最想说的一句还是:多说，我欠你一个会员！  </p>
<p>7.19日更:好吧在很多人的劝说下我还是开通了评论系统，使用的是disqus插件，不过在多说关闭之前忘记将它上面的评论数据导出来了，这样以后文章下的评论还是要靠大家重新积累了，不管怎样，希望大家有问题的话还是像以前那样直接在我文章下面评论吧~然后也是在很多人的提议下，我还是开了一个Java学习交流群:659957958，就一个要求:希望大家能一起帮忙解决新手的疑惑，不要让我一个人去解答，这样我会很累很累的。话不多说，赶快上车吧！</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>感觉写的文章多了以后，微博、知乎的粉丝也越来越多了，Github上项目的star数、follow数也越来越多了，谢谢小伙伴们一直的陪伴。人无完人，我也经常犯错，希望日后伙伴们能继续为我的错误提出指正，心里真的十分的感谢大家。</p>
<p>微信上最近也突然收到很多伙伴们因为看完我的文章与提供的资料然后给予我的打赏，突然觉得当初在每片文章的底下附上一个“打赏”的插件还是挺有用的呢(奸笑脸，嘿嘿)，表示十分感谢哈，其实知道你们跟着我一起进步我就很高兴了，不过也感觉更有动力写更多干货的文章了诶～</p>
<h2 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h2><p>真的好久没写博客咯，竟然这次还写了一篇没有干货没有代码的博客，(内心os:怎么做开发者的？)，这篇是下午坐在出租屋里一字一字码出来的，凑合着看吧。其实就是想冒个泡(逃</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode浅谈]]></title>
      <url>http://codingxiaxw.cn/2017/02/06/67-follow-me-in-leetcode/</url>
      <content type="html"><![CDATA[<p>许久没更了，新的一年我也将更新我2017的第一篇博客。趁新年放假之际，我又重新将<a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a>上面的题目刷了一遍，不同于之前的是，这次我详细记录了自己刷题时候的感想心得、被系统accept的答案、自己的思路以及错题反思以供大家参考。<a id="more"></a>为了让大家跟我一个步伐，所以我从难易程度为easy的题目再一次刷起，希望算法能力有所提高的小伙伴来跟我一起同步再刷一次LeetCode吧！</p>
<p>所做过的题目答案已上传到我的Github, <a href="https://github.com/codingXiaxw/leetcode" target="_blank" rel="external">Click here!</a>  需要收藏的不妨star一下吧。 <!--为了追赶上潮流，github中的README.md采用全英文书写，以后的README.md估计都采用全英文了吧，希望小伙伴们能跟着我一起提高品味hhh。  --></p>
<h2 id="为什么要刷题"><a href="#为什么要刷题" class="headerlink" title="为什么要刷题"></a>为什么要刷题</h2><p>虽然刷题一直饱受诟病，不过不可否认刷题确实能锻炼我们的编程能力，相信每个认真刷题的人都会有体会。现在提供在线编程评测的平台有很多，比较有名的有 <a href="http://hihocoder.com/" target="_blank" rel="external">hihocoder</a>，<a href="http://www.lintcode.com/zh-cn/" target="_blank" rel="external">LintCode</a>，以及这里我们关注的 <a href="https://leetcode.com" target="_blank" rel="external">LeetCode</a>。  </p>
<p>下图是LeetCode平台上统计的各种编程语言在LeetCode上提交的算法解决方法运行时间长短:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-07%20%E4%B8%8A%E5%8D%8811.21.44.png" alt=""></p>
<p>LeetCode 是一个非常棒的 OJ（Online Judge）平台，收集了许多公司的面试题目。相对其他 OJ 平台而言，有着下面的几个优点：</p>
<ul>
<li>题目全部来自业内大公司的真实面试</li>
<li>不用处理输入输出，精力全放在解决具体问题上</li>
<li>题目有丰富的讨论，可以参考别人的思路</li>
<li>精确了解自己代码在所有提交代码中运行效率的排名</li>
<li>支持多种主流语言：C/C++，Python, Java</li>
<li>可以在线进行测试，方便调试</li>
</ul>
<p>为什么要这么看重算法还需要特地刷LeetCode甚至5、6遍 ? 一句话:可能这就是区分程序员和码农很大的特点吧。</p>
<p>下面是我刷 LeetCode 的一些收获以及文章开头附上的自己用Java解决LeetCode上算法的源码，希望能够引诱大家有空时刷刷题目。</p>
<h2 id="如何合理利用LeetCode"><a href="#如何合理利用LeetCode" class="headerlink" title="如何合理利用LeetCode"></a>如何合理利用LeetCode</h2><p>我当初进入leetcode是完全蒙蔽的，全英文的界面、全英文的题目，总之一切都是全英文的，然而你要相信的是:了解一个工具或者平台，真的只需要几分钟的时间。</p>
<p>看了很多人写了关于LeetCode指南的文章，共同的特点就是:介绍刷LeetCode对提高自己的算法能力如何如何重要，再就是给你介绍介绍LeetCode平台的特征等等…然后也没人教你第一步也就是如何去使用这个平台，例如点击这个按钮能干嘛能干嘛，如何进入刷题系统等等…(很多人会想，都进入LeetCode官网了，难道会不知道咋进入刷题页面吗？没错，第一次进入该平台的我面对如此庞大的全英文，确实是摸不到头脑。然而我的文章一向保持着照顾新人的态度来书写的)也难怪，毕竟大神是不必在乎这些小细节的…我这里就不厌其烦的对自己第一次使用LeetCode平台时的感受浅谈几点吧。 </p>
<p>第一次进入<a href="https://leetcode.com" target="_blank" rel="external">LeetCode</a>官网，首先肯定是要点击<strong>Sign in</strong>按钮输入自己的账号和密码的，建议快速登录选择使用github登录，好处不用我多说，登录系统后出现下面这个界面:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%889.54.18.png" alt="">  </p>
<p>然后点击左下方的<strong>Start coding now</strong>按钮，这时页面会跳转到另一个随机出现的题目，例如下图:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%889.57.54.png" alt="">  </p>
<p>这时咋办？鼠标移到上方<strong>Problems</strong>菜单栏，选择<strong>Algorithms</strong>:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%889.58.24.png" alt="">  </p>
<p>就可以跳转到LeetCode所有题的列表页了，如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%8810.00.05.png" alt="">  </p>
<p>然后便可以选择相应的题目进行答题了，建议从难易程度为<strong>easy</strong>的题目刷起，这样往后你就会越刷越有信心，当然有个把题目你要是想了1、2两个小时，这都是正常的不要害怕，刷着刷着你的算法能力就上去了，刷着刷着你的速度也快了。例如我这里选择第一题<strong><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="external">Two Sum</a></strong>然后进入如下页面，这个页面我要给大家讲讲相应的界面元素:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%8810.02.38.png" alt="">  </p>
<p>上面这行英文字母当然就是系统为你布置的题目啦:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%8810.22.14.png" alt="">  </p>
<p>英文底子不好的连题目都看不懂的，建议安装一款插件，我用的浏览器是Chrome，用了一款叫<strong>划词翻译</strong>的插件，还是挺不错的，选择页面中相应的英文或其它不是中文的文然后点击下面出现的”译”就可以将文字翻译成相对准确的中文了。(要是没有相关条件的人，可以看看我传在github中的代码答案，因为我在代码中把题目都翻译成了中文并写在了代码中)  </p>
<p>下面的<strong>Example</strong>，当然就是系统给你举的例子了，例如给你一个输入，然后通过你编写的算法应该得出与它一致的输出:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%8810.22.19.png" alt="">  </p>
<p>下方的这个框框就是你的答题区域咯，你可以选择相应的编程语言了然后进行答题:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%8810.22.29.png" alt="">  </p>
<p>编写完成后，你就可以点击下面的按钮:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%8810.22.35.png" alt="">  </p>
<p>点击这个<strong>Run Code</strong>按钮表示运行一下你的代码，然后系统检测通过上面给出的<strong>Example</strong>粗略判断你的代码是否符合要求，待出现的<strong>output</strong>和<strong>expected output</strong>一致后你就可以点击下面这个<strong>Submit Solution</strong>按钮进行提交自己的代码至系统了:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%8810.22.39.png" alt="">  </p>
<p>有趣的是点击这个按钮后若你的算法代码被系统<strong>Accepted</strong>后，还会给你生成一幅你这个算法时间复杂度的一个图表，是不是很高大上！  </p>
<p>当然，当你要是实在对题目没有头绪时，不妨点击中间的<strong>discuss</strong>按钮:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-06%20%E4%B8%8B%E5%8D%8810.22.48.png" alt=""></p>
<p>点击后，你就可以进入这个题目背后各种LeetCode好友提供的自己的答案，还可以为你觉得写的好的答案支持一下，支持数越多的答案当然就会被排在前面。  </p>
<p>那么问题来了，既然这个界面有每个题目的答案，我又为什么要在github上提供自己的答案呢？很简单啊，因为我在将我的代码上传至github之前我当然也拿自己的答案和上面的答案进行对比了，我的答案多了这些:</p>
<ul>
<li>1.<strong>多种</strong>合适当前题目的时间复杂度最低又好理解的答案。</li>
<li>2.我自己没被通过的答案，以及我的反思，自己错在哪里。</li>
<li>3.最重要的是我将题目都在答案中抄了一遍，中英文都有哦。</li>
</ul>
<p>说了这么多功能，当然更多的是需要你自己去摸索了，点击的次数多了，遇到的坑多了，自己自然也就熟悉了。</p>
<p>至于我上传在github上的源码，那逼格可高多啦，除了记录了我详细的解题思路，最重要的是README.md可是采用全英文写的呢! <strong>like this :</strong> </p>
<h2 id="LeetCode-Algorithm"><a href="#LeetCode-Algorithm" class="headerlink" title="LeetCode Algorithm"></a>LeetCode Algorithm</h2><p><strong>This form includes:</strong></p>
<ul>
<li>1.the question’s numbers marking by “#”.</li>
<li>2.the question’s title with its address in <a href="https://leetcode.com/" target="_blank" rel="external">LeetCode</a> marking by “Title”.</li>
<li>3.the question’s Java algorithm solutions with its address in my github marking by “Solution”.</li>
<li>4.the difficulty about this question.</li>
</ul>
<p><strong>And in my solutions code , it includes:</strong></p>
<ul>
<li>1.the title about this question with English and Chinese version.</li>
<li>2.the right questions more than one.</li>
<li>3.the wrong question that I did the first time.</li>
<li>4.why I did the wrong answer,how I think in that time.</li>
</ul>
<p><strong>others:”＊”</strong> represents something I didn’t finish.</p>
<p>Hope it helps you in algorithm learning. <strong>Have fun!</strong></p>
<table>
<thead>
<tr>
<th>#</th>
<th>Title</th>
<th>Solution</th>
<th>Difficulty</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="external">Two Sum</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/two_sum.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>2</td>
<td>＊<a href="https://leetcode.com/problems/add-two-numbers/" target="_blank" rel="external">Add Two Numbers</a></td>
<td><a href="">Java</a></td>
<td>Medium</td>
</tr>
<tr>
<td>7</td>
<td><a href="https://leetcode.com/problems/reverse-integer/" target="_blank" rel="external">Reverse Integer</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/reverse.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>9</td>
<td><a href="https://leetcode.com/problems/palindrome-number/" target="_blank" rel="external">Palindrome Number</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/palindromeNumber.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>13</td>
<td><a href="">Roman to Integer</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/romanToInteger.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>14</td>
<td><a href="https://leetcode.com/problems/longest-common-prefix/" target="_blank" rel="external">Longest Common Prefix</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/longestCommonPrefix.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>20</td>
<td><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="external">Valid Parentheses</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/validParentheses.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>21</td>
<td>＊<a href="">Merge Two Sorted Lists</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/mergeTwoSortedLists.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>26</td>
<td><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="external">Remove Duplicates from Sorted Array</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/removeDuplicatesFromSortedArray.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>27</td>
<td><a href="https://leetcode.com/problems/remove-element/" target="_blank" rel="external">Remove Element</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/removeElement.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>28</td>
<td><a href="">Implement strStr()</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/implementStrStr.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>35</td>
<td><a href="https://leetcode.com/problems/search-insert-position/" target="_blank" rel="external">Search Insert Position</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/searchInsertPosition.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
<tr>
<td>38</td>
<td>＊<a href="https://leetcode.com/problems/count-and-say/" target="_blank" rel="external">Count and Say</a></td>
<td><a href="https://github.com/codingXiaxw/leetcode/blob/master/algorithms/Java/countAndSay.java" target="_blank" rel="external">Java</a></td>
<td>easy</td>
</tr>
</tbody>
</table>
<p>是不是很6？hhh,2016悄然过去，相信小伙伴们在反思过去的同时也一定成长了不少，新的一年，希望大家带着以往的梦想，继续前进!</p>
<h2 id="2017-04-01更"><a href="#2017-04-01更" class="headerlink" title="2017.04.01更"></a>2017.04.01更</h2><p>突然发现又把LeetCode上面的题目刷完了一遍，然而我太懒了所以的题目都只在LeetCode官网上的OJ平台跑了一遍，也只将前面的题目答案整理到了自己的Github上，后面的题目没有整理…呃大家要不在刷题的时候就查看LeetCode讨论区各个伙伴们贡献的答案吧，我就等以后哪天再刷的时候再整理自己的刷题过程吧。(当然希望我那时候不要太懒…</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用查找算法]]></title>
      <url>http://codingxiaxw.cn/2017/01/14/66-leetcode-find/</url>
      <content type="html"><![CDATA[<p>上周写了一篇有关排序的几种算法实现，有排序当然就有查找咯，所以本篇文章对我们常用的几种查找算法进行介绍。源码请参见<a href="https://github.com/codingXiaxw/leetcode" target="_blank" rel="external">我的github</a>，欢迎star和fork。<a id="more"></a></p>
<h2 id="关于查找，你必须要知道的一些概念"><a href="#关于查找，你必须要知道的一些概念" class="headerlink" title="关于查找，你必须要知道的一些概念"></a>关于查找，你必须要知道的一些概念</h2><p>查找是在大量的信息中寻找一个特定的信息元素，在计算机应用中，查找是常用的基本运算，例如编译程序中符号表的查找。本文简单概括性的介绍了常见的七种查找算法，说是七种，其实二分查找、插值查找以及斐波那契查找都可以归为一类——插值查找。插值查找和斐波那契查找是在二分查找的基础上的优化查找算法。  </p>
<p><strong>查找定义：</strong>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。  </p>
<p><strong>查找算法分类：</strong></p>
<ul>
<li>1.静态查找和动态查找；<ul>
<li>静态或者动态都是针对查找表而言的，如本篇要介绍的顺序查找、二分查找、分块查找。</li>
<li>动态表指查找表中有删除和插入操作的表,如本篇要介绍的树表查找(二叉树查找、平衡查找树之2-3查找树、平衡查找树之红黑树、B树和B+树查找)、哈希表查找。</li>
</ul>
</li>
<li>无序查找和有序查找。<ul>
<li>无序查找：被查找数列有序无序均可；</li>
<li>有序查找：被查找数列必须为有序数列。</li>
</ul>
</li>
</ul>
<h2 id="1-顺序查找"><a href="#1-顺序查找" class="headerlink" title="1.顺序查找"></a>1.顺序查找</h2><h3 id="1-1顺序查找实现思路"><a href="#1-1顺序查找实现思路" class="headerlink" title="1.1顺序查找实现思路"></a>1.1顺序查找实现思路</h3><p>顺序查找也称为线形查找，属于无序查找算法。从数据结构线形表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定值k相比较，若相等则表示查找成功；若扫描结束仍没有找到关键字等于k的结点，表示查找失败。</p>
<p><strong>复杂度分析：</strong>查找成功时的平均查找长度为:(假设每个数据元素的概率相等） ASL = 1/n(1+2+3+…+n) = (n+1)/2 ;当查找不成功时，需要n+1次比较，时间复杂度为O(n);所以，顺序查找的时间复杂度为O(n)。</p>
<h3 id="1-2顺序查找实现代码"><a href="#1-2顺序查找实现代码" class="headerlink" title="1.2顺序查找实现代码"></a>1.2顺序查找实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**顺序查找平均时间复杂度 O（n） </span><br><span class="line"> * <span class="doctag">@param</span> searchKey 要查找的值 </span><br><span class="line"> * <span class="doctag">@param</span> array 数组（从这个数组中查找） </span><br><span class="line"> * <span class="doctag">@return</span>  查找结果（数组的下标位置） </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">orderSearch</span><span class="params">(<span class="keyword">int</span> searchKey,<span class="keyword">int</span>[] array)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length&lt;<span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;  </span><br><span class="line">        <span class="keyword">if</span>(array[i]==searchKey)&#123;  </span><br><span class="line">            <span class="keyword">return</span> i;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-二分查找"><a href="#2-二分查找" class="headerlink" title="2.二分查找"></a>2.二分查找</h2><h3 id="2-1二分查找实现思路"><a href="#2-1二分查找实现思路" class="headerlink" title="2.1二分查找实现思路"></a>2.1二分查找实现思路</h3><p>也称为是折半查找，属于有序查找算法。用给定值k先与中间结点的关键字比较，中间结点把线形表分成两个子表，若相等则查找成功；若不相等，再根据k与该中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找到或查找结束发现表中没有这样的结点。  </p>
<p><strong>复杂度分析：</strong>最坏情况下，关键词比较次数为log2(n+1)，且期望时间复杂度为O(log2n)；  </p>
<p><strong>需要注意：</strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</p>
<h3 id="2-2二分查找实现代码"><a href="#2-2二分查找实现代码" class="headerlink" title="2.2二分查找实现代码"></a>2.2二分查找实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line"> * 二分查找又称折半查找，它是一种效率较高的查找方法。 【二分查找要求】：1.必须采用顺序存储结构 2.必须按关键字大小有序排列。 </span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> array </span><br><span class="line"> *            有序数组 * </span><br><span class="line"> * <span class="doctag">@param</span> searchKey </span><br><span class="line"> *            查找元素 * </span><br><span class="line"> * <span class="doctag">@return</span> searchKey的数组下标，没找到返回-1 </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> searchKey)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span> high = array.length - <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;  </span><br><span class="line">        <span class="keyword">int</span> middle = (low + high) / <span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span> (searchKey == array[middle]) &#123;  </span><br><span class="line">            <span class="keyword">return</span> middle;  </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (searchKey &lt; array[middle]) &#123;  </span><br><span class="line">            high = middle - <span class="number">1</span>;  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">            low = middle + <span class="number">1</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-分块查找"><a href="#3-分块查找" class="headerlink" title="3.分块查找"></a>3.分块查找</h2><h3 id="3-1分块查找实现思路"><a href="#3-1分块查找实现思路" class="headerlink" title="3.1分块查找实现思路"></a>3.1分块查找实现思路</h3><p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。<strong>算法思想：</strong>将n个数据元素”按块有序”划分为m块（m ≤ n）。每一块中的结点不必有序，但块与块之间必须”按块有序”；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，即下述步骤:</p>
<ul>
<li>1.首先将查找表分成若干块，在每一块中数据元素的存放是任意的，但块与块之间必须是有序的（假设这种排序是按关键字值递增的，也就是说在第一块中任意一个数据元素的关键字都小于第二块中所有数据元素的关键字，第二块中任意一个数据元素的关键字都小于第三块中所有数据元素的关键字，依次类推）； </li>
<li>2.建立一个索引表，把每块中最大的关键字值按块的顺序存放在一个辅助数组中，这个索引表也按升序排列； </li>
<li>3.查找时先用给定的关键字值在索引表中查找，确定满足条件的数据元素存放在哪个块中，查找方法既可以是折半方法，也可以是顺序查找。 </li>
<li>4.再到相应的块中顺序查找，便可以得到查找的结果。 </li>
</ul>
<h3 id="3-2分块查找实现代码"><a href="#3-2分块查找实现代码" class="headerlink" title="3.2分块查找实现代码"></a>3.2分块查找实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line"> * 分块查找 </span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> index </span><br><span class="line"> *            索引表，其中放的是各块的最大值 </span><br><span class="line"> * <span class="doctag">@param</span> st </span><br><span class="line"> *            顺序表， </span><br><span class="line"> * <span class="doctag">@param</span> key </span><br><span class="line"> *            要查找的值 </span><br><span class="line"> * <span class="doctag">@param</span> m </span><br><span class="line"> *            顺序表中各块的长度相等，为m </span><br><span class="line"> * <span class="doctag">@return</span> </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">blockSearch</span><span class="params">(<span class="keyword">int</span>[] index, <span class="keyword">int</span>[] st, <span class="keyword">int</span> key, <span class="keyword">int</span> m)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 在序列st数组中，用分块查找方法查找关键字为key的记录  </span></span><br><span class="line">    <span class="comment">// 1.在index[ ] 中折半查找，确定要查找的key属于哪个块中  </span></span><br><span class="line">    <span class="keyword">int</span> i = binarySearch(index, key);  </span><br><span class="line">    <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="keyword">int</span> j = i &gt; <span class="number">0</span> ? i * m : i;  </span><br><span class="line">        <span class="keyword">int</span> len = (i + <span class="number">1</span>) * m;  </span><br><span class="line">        <span class="comment">// 在确定的块中用顺序查找方法查找key  </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = j; k &lt; len; k++) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (key == st[k]) &#123;  </span><br><span class="line">                System.out.println(<span class="string">"查询成功"</span>);  </span><br><span class="line">                <span class="keyword">return</span> k;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    System.out.println(<span class="string">"查找失败"</span>);  </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-树表查找"><a href="#4-树表查找" class="headerlink" title="4.树表查找"></a>4.树表查找</h2><h3 id="4-1二叉树查找"><a href="#4-1二叉树查找" class="headerlink" title="4.1二叉树查找"></a>4.1二叉树查找</h3><h4 id="4-1-1二叉树查找实现思路"><a href="#4-1-1二叉树查找实现思路" class="headerlink" title="4.1.1二叉树查找实现思路"></a>4.1.1二叉树查找实现思路</h4><p><strong>基本思想：</strong>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。   </p>
<p><strong>二叉查找树:</strong>也叫二叉搜索树，或称二叉排序树,或者是一棵空树，或者是具有下列性质的二叉树:</p>
<ul>
<li>1.若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>2.若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>3.任意节点的左、右子树也分别为二叉查找树。  </li>
</ul>
<p><strong>二叉查找树性质：</strong>对二叉查找树进行中序遍历，即可得到有序的数列。  </p>
<p>不同形态的二叉查找树如下图所示:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%889.32.50.png" alt="">  </p>
<p><strong>复杂度分析：</strong>它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。  </p>
<p>基于二叉查找树进行优化，进而可以得到其他的树表查找算法，如平衡树、红黑树等高效算法。</p>
<h4 id="4-1-2二叉树查找实现算法"><a href="#4-1-2二叉树查找实现算法" class="headerlink" title="4.1.2二叉树查找实现算法"></a>4.1.2二叉树查找实现算法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义二叉树数据结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> value;</span><br><span class="line">	TreeNode left;</span><br><span class="line">	TreeNode right;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSearch</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> TreeNode <span class="title">Solution</span><span class="params">(TreeNode root,<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//定义当前节点</span></span><br><span class="line">		TreeNode current = root;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (current.val &lt; value) &#123;</span><br><span class="line">				<span class="comment">//如果当前节点的值比value小，则从其右子树中开始找</span></span><br><span class="line">				current = current.right;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.val &gt; value) &#123;</span><br><span class="line">				<span class="comment">//如果当前节点的值比value大，则从其左子树中开始找</span></span><br><span class="line">				current = current.left;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (current.val == value) &#123;</span><br><span class="line">				<span class="comment">//找到则返回这个节点</span></span><br><span class="line">				<span class="keyword">return</span> current;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2平衡查找树之2-3查找树-2-3-Tree"><a href="#4-2平衡查找树之2-3查找树-2-3-Tree" class="headerlink" title="4.2平衡查找树之2-3查找树(2-3 Tree)"></a>4.2平衡查找树之2-3查找树(2-3 Tree)</h3><h4 id="4-2-1-2-3查找树实现思路"><a href="#4-2-1-2-3查找树实现思路" class="headerlink" title="4.2.1 2-3查找树实现思路"></a>4.2.1 2-3查找树实现思路</h4><p><strong>2-3查找树定义:</strong>和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个子节点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下:</p>
<ul>
<li>1.要么为空，要么：</li>
<li>2.对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。</li>
<li>3.对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。  </li>
</ul>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%889.39.36.png" alt="">  </p>
<p><strong>2-3查找树的性质:</strong></p>
<ul>
<li>1.如果中序遍历2-3查找树，就可以得到排好序的序列；</li>
<li>2.在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）  </li>
</ul>
<p>性质2如下图所示：  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%889.41.19.png" alt=""></p>
<p><strong>复杂度分析：</strong><br>2-3树的查找效率与树的高度是息息相关的。</p>
<ul>
<li>在最坏的情况下，也就是所有的节点都是2-node节点，查找效率为lgN</li>
<li>在最好的情况下，所有的节点都是3-node节点，查找效率为log3N约等于0.631lgN</li>
</ul>
<p>具体来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。</p>
<p>对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。</p>
<h4 id="4-2-2-2-3查找树实现代码"><a href="#4-2-2-2-3查找树实现代码" class="headerlink" title="4.2.2 2-3查找树实现代码"></a>4.2.2 2-3查找树实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待更新</span><br></pre></td></tr></table></figure>
<h3 id="4-3平衡查找树之红黑树-Red-Black-Tree"><a href="#4-3平衡查找树之红黑树-Red-Black-Tree" class="headerlink" title="4.3平衡查找树之红黑树(Red-Black Tree)"></a>4.3平衡查找树之红黑树(Red-Black Tree)</h3><h4 id="4-3-1红黑树查找实现思路"><a href="#4-3-1红黑树查找实现思路" class="headerlink" title="4.3.1红黑树查找实现思路"></a>4.3.1红黑树查找实现思路</h4><p>2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgn，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，于是就有了一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。  </p>
<p><strong>基本思想:</strong>红黑树的思想就是对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%889.48.28.png" alt="">  </p>
<p><strong>红黑树的定义:</strong>红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p>
<ul>
<li>1.红色节点向左倾斜</li>
<li>2.一个节点不可能有两个红色链接</li>
<li>3.整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。  </li>
</ul>
<p>下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%889.49.59.png" alt="">  </p>
<p><strong>红黑树的性质：</strong>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。</p>
<p><strong>复杂度分析：</strong>最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。  </p>
<p>下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%889.56.51.png" alt=""></p>
<h4 id="4-3-2红黑树查找实现代码"><a href="#4-3-2红黑树查找实现代码" class="headerlink" title="4.3.2红黑树查找实现代码"></a>4.3.2红黑树查找实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待更新。</span><br></pre></td></tr></table></figure>
<h3 id="4-4-B树和B-树查找-B-Tree-B-Tree"><a href="#4-4-B树和B-树查找-B-Tree-B-Tree" class="headerlink" title="4.4 B树和B+树查找(B Tree/B+ Tree)"></a>4.4 B树和B+树查找(B Tree/B+ Tree)</h3><h4 id="4-4-1-B树和B-树查找实现思路"><a href="#4-4-1-B树和B-树查找实现思路" class="headerlink" title="4.4.1 B树和B+树查找实现思路"></a>4.4.1 B树和B+树查找实现思路</h4><p>平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。</p>
<p>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B树为系统最优化大块数据的读和写操作。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。  </p>
<p>B树定义：B树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点:</p>
<ul>
<li>1.根节点至少有两个子节点</li>
<li>2.每个节点有M-1个key，并且以升序排列</li>
<li>3.位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li>
<li>4.其它节点至少有M/2个子节点</li>
</ul>
<p>下图是一个M=4 阶的B树:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%889.58.57.png" alt="">  </p>
<p>可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入:</p>
<p>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4  </p>
<p><strong>B+树定义:</strong>B+树是对B树的一种变形树，它与B树的差异在于：</p>
<ul>
<li>1.有k个子结点的结点必然有k个关键码；</li>
<li>2.非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li>
<li>3.树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li>
</ul>
<p>如下图，是一个B+树:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%8810.00.25.png" alt=""></p>
<p>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。  </p>
<p><strong>B+ 树的优点在于：</strong>  </p>
<ul>
<li>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</li>
<li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li>
</ul>
<p>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。</p>
<p>下面是B 树和B+树的区别图:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-20%20%E4%B8%8B%E5%8D%8810.01.36.png" alt="">  </p>
<p>B/B+树常用于文件系统和数据库系统中，它通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。它广泛用于文件系统及数据库中。  </p>
<p><strong>树表查找总结：</strong>二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。</p>
<p>除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。</p>
<h4 id="4-4-2-B树和B-树查找实现代码"><a href="#4-4-2-B树和B-树查找实现代码" class="headerlink" title="4.4.2 B树和B+树查找实现代码"></a>4.4.2 B树和B+树查找实现代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待更新。</span><br></pre></td></tr></table></figure>
<h2 id="5-哈希表查找"><a href="#5-哈希表查找" class="headerlink" title="5.哈希表查找"></a>5.哈希表查找</h2><h3 id="5-1哈希表查找实现思路"><a href="#5-1哈希表查找实现思路" class="headerlink" title="5.1哈希表查找实现思路"></a>5.1哈希表查找实现思路</h3><p><strong>什么是哈希表?</strong>  </p>
<p>我们使用一个下标范围比较大的数组来存储元素。可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素”分类”，然后将这个元素存储在相应”类”所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了”冲突”，换句话说，就是把不同的元素分在了相同的”类”之中。后面我们将看到一种解决”冲突”的简便做法。  </p>
<p>总的来说，”直接定址”与”解决冲突”是哈希表的两大特点。</p>
<p><strong>5.1.2什么是哈希函数</strong>  </p>
<p><strong>哈希函数的规则是</strong>：通过某种转换关系，使关键字适度的分散到指定大小的的顺序结构中，越分散，则以后查找的时间复杂度越小，空间复杂度越高。  </p>
<p><strong>算法思想：</strong>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。  </p>
<p><strong>算法流程：</strong>  </p>
<ul>
<li>1.用给定的哈希函数构造哈希表；</li>
<li>2.根据选择的冲突处理方法解决地址冲突；<ul>
<li>常见的解决冲突的方法：拉链法和线性探测法。</li>
</ul>
</li>
<li>3.在哈希表的基础上执行哈希查找。  </li>
</ul>
<p>哈希表是一个在时间和空间上做出权衡的经典例子。如果没有内存限制，那么可以直接将键作为数组的索引。那么所有的查找时间复杂度为O(1)；如果没有时间限制，那么我们可以使用无序数组并进行顺序查找，这样只需要很少的内存。哈希表使用了适度的时间和空间来在这两个极端之间找到了平衡。只需要调整哈希函数算法即可在时间和空间上做出取舍。  </p>
<p><strong>复杂度分析：</strong>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</p>
<h3 id="5-2哈希表查找实现代码"><a href="#5-2哈希表查找实现代码" class="headerlink" title="5.2哈希表查找实现代码"></a>5.2哈希表查找实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** </span><br><span class="line"> * Hash查找 </span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> hash </span><br><span class="line"> * <span class="doctag">@param</span> hashLength </span><br><span class="line"> * <span class="doctag">@param</span> key </span><br><span class="line"> * <span class="doctag">@return</span> </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">searchHash</span><span class="params">(<span class="keyword">int</span>[] hash, <span class="keyword">int</span> hashLength, <span class="keyword">int</span> key)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 哈希函数  </span></span><br><span class="line">    <span class="keyword">int</span> hashAddress = key % hashLength;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 指定hashAdrress对应值存在但不是关键值，则用开放寻址法解决  </span></span><br><span class="line">    <span class="keyword">while</span> (hash[hashAddress] != <span class="number">0</span> &amp;&amp; hash[hashAddress] != key) &#123;  </span><br><span class="line">        hashAddress = (++hashAddress) % hashLength;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 查找到了开放单元，表示查找失败  </span></span><br><span class="line">    <span class="keyword">if</span> (hash[hashAddress] == <span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">return</span> hashAddress;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/*** </span><br><span class="line"> * 数据插入Hash表 </span><br><span class="line"> *  </span><br><span class="line"> * <span class="doctag">@param</span> hash </span><br><span class="line"> *            哈希表 </span><br><span class="line"> * <span class="doctag">@param</span> hashLength </span><br><span class="line"> * <span class="doctag">@param</span> data </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertHash</span><span class="params">(<span class="keyword">int</span>[] hash, <span class="keyword">int</span> hashLength, <span class="keyword">int</span> data)</span> </span>&#123;  </span><br><span class="line">    <span class="comment">// 哈希函数  </span></span><br><span class="line">    <span class="keyword">int</span> hashAddress = data % hashLength;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 如果key存在，则说明已经被别人占用，此时必须解决冲突  </span></span><br><span class="line">    <span class="keyword">while</span> (hash[hashAddress] != <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="comment">// 用开放寻址法找到  </span></span><br><span class="line">        hashAddress = (++hashAddress) % hashLength;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将data存入字典中  </span></span><br><span class="line">    hash[hashAddress] = data;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上种种，慢慢体会多刷刷leetcode吧啊哈。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[常用排序算法]]></title>
      <url>http://codingxiaxw.cn/2017/01/07/65-leetcodeSort/</url>
      <content type="html"><![CDATA[<p>忙碌了一整个星期公司布置的任务，如今周末终于能抽出时间继续自己在互联网技术上的学习，尽管现阶段是学校安排的考试周，但也无法阻止我对新技术的学习热情。<a id="more"></a>因为计划是寒假就开始leetcode的学习之旅，所以今天先总结一篇学习到的关于排序的算法，后面也会继续记录自己在刷leetcode时的感悟，代码将上传至<a href="https://github.com/codingXiaxw/leetcode" target="_blank" rel="external">我的github</a>，欢迎star和fork。  </p>
<p>当然，作为一个Java工程师，所以里面的算法都是用Java语言实现的，不过其实不管你用的是哪种语言，实现该算法的思路都是一样的，所以借鉴此篇文章的你即使用的不是Java，看完此片文章的实现思路及其实现代码后你也是可以用其他语言实现的～</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>查找和排序算法是算法的入门知识，其经典思想可以用于很多算法当中，但万变不离其宗，只要熟悉了思想，灵活运用也不是难事。那么常用的排序算法有哪些呢？本篇文章要介绍的排序算法，按照排序的效率分有以下10种:</p>
<ul>
<li>1.简单排序:冒泡排序、(直接)选择排序、(直接)插入排序。</li>
<li>2.高效排序:快速排序、堆排序、希尔排序。</li>
<li>3.基于分治递归思想的:归并排序。</li>
<li>4.线性排序:计数排序、桶排序、基数排序。</li>
</ul>
<p>按照排序的方式又可分为:</p>
<ul>
<li>1.插入排序:直接插入排序、希尔排序。</li>
<li>2.选择排序:直接选择排序、堆排序。</li>
<li>3.交换排序:冒泡排序、快速排序。</li>
<li>4.线性排序:计数排序、基数排序、桶排序;其中基数排序又叫桶排序;</li>
<li>5.递归排序:归并排序。</li>
</ul>
<p>对于这些排序，我们需要掌握比较各自的优劣、各种算法的思想及其使用场景，还有要会分析算法的时间和空间复杂度，必要时要熟练写出代码。我们可以知道排序算法要么简单有效，要么是利用简单排序的特点加以改进，要么是以空间换取时间在特定情况下的高效排序。但是这些排序方法都不是固定不变的，需要结合具体的需求和场景来选择甚至组合使用，才能达到高效稳定的目的。所以有句话叫做:没有最好的排序，只有最适合的排序。  </p>
<p>下面我将分别介绍以上提出的这10种排序的思想及其算法实现，为了便于讲解，统一采取从小到大的排序方法。</p>
<h2 id="1-简单排序之冒泡排序"><a href="#1-简单排序之冒泡排序" class="headerlink" title="1.简单排序之冒泡排序"></a>1.简单排序之冒泡排序</h2><h3 id="1-1冒泡排序实现思想"><a href="#1-1冒泡排序实现思想" class="headerlink" title="1.1冒泡排序实现思想"></a>1.1冒泡排序实现思想</h3><p>冒泡排序是最简单的排序之一了，其大体思想就是通过与相邻元素的比较和交换来把大的数交换到最后面(从小到大排序)。这个过程类似于水泡向上升一样，因此而得名。  </p>
<p>举个栗子，对5,3,8,6,4这个无序序列进行冒泡排序。第一次冒泡:从前向后冒泡，5和3比较，5大所以将5和3交换，序列变成3，5，8，6，4;同理5和8比较，5比8小所以不交换;然后8和6比较，8大所以将8和6交换，序列变成3，5，6，8，4;然后8和4比较，进行8和4的交换，这样一次冒泡就完了，结果是将最大的数字8换到了最后面。对剩下的序列依次进行第二次冒泡、…、第n次冒泡就会得到一个有序序列。冒泡排序的时间复杂度为O(n^2)。</p>
<h3 id="1-2冒泡排序实现代码"><a href="#1-2冒泡排序实现代码" class="headerlink" title="1.2冒泡排序实现代码"></a>1.2冒泡排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;<span class="comment">//将要排序的数字放入一个数组中</span></span><br><span class="line">    	  <span class="comment">//判断需要排序的数组是否为空，为空则不进行排序</span></span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//i控制外循环即总共需要将多少个数字进行排序，j控制内循环即每次循环都会将最大的数排到右边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;arr.length-i-<span class="number">1</span>; j++) &#123;</span><br><span class="line">            		<span class="comment">//如果前面的数字大于后面的数字就将前面的数字和后面的数字进行交换，直接最大的数字被排到最右侧</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &gt; arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line">                    swap(arr, j+<span class="number">1</span>, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两个数字的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-简单排序之选择排序"><a href="#2-简单排序之选择排序" class="headerlink" title="2.简单排序之选择排序"></a>2.简单排序之选择排序</h2><h3 id="2-1选择排序实现思路"><a href="#2-1选择排序实现思路" class="headerlink" title="2.1选择排序实现思路"></a>2.1选择排序实现思路</h3><p>选择排序的思想其实和冒泡排序有点类似，都是在一次排序后把最大的元素放到最右边。但是过程不同，冒泡排序是通过相邻的比较和交换。而选择排序是通过对整体的选择。  </p>
<p>举个栗子，对5,3,8,6,4这个无序序列进行简单选择排序。第一次选择排序:首先要循环遍历该数组，选择整体中5以外的最小数来和5交换，遍历该数组时发现3是最小的数字，那么就会拿3和5交换，一次遍历和排序后就变成了3,5,8,6,4，实现了将最小的数字放在最前面。对剩下的序列依次进行第二次选择和交换、…、第n次选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。选择排序的时间复杂度为O(n^2)。</p>
<h3 id="2-2选择排序实现代码"><a href="#2-2选择排序实现代码" class="headerlink" title="2.2选择排序实现代码"></a>2.2选择排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length-<span class="number">1</span>; i++) &#123; <span class="comment">//只需要比较n-1次</span></span><br><span class="line">        	  <span class="comment">//将数组中的第一个数arr[i]即arr[minIndex]作为基准，遍历其后面所有的数字，只要出现比这个数小的，那么就记下这个数的下标并赋给minIndex，遍历完后若该minIndex不等于i，说明找到了最小的值，就将这个数字下标为minIndex的值与基准数字交换之。</span></span><br><span class="line">            minIndex = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;arr.length; j++) &#123; <span class="comment">//从i+1开始比较，因为minIndex默认为i了，i就没必要比了。</span></span><br><span class="line">                <span class="keyword">if</span>(arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">                    minIndex = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(minIndex != i) &#123; <span class="comment">//如果minIndex不为i，说明找到了更小的值，交换之。</span></span><br><span class="line">                swap(arr, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-简单排序之插入排序"><a href="#3-简单排序之插入排序" class="headerlink" title="3.简单排序之插入排序"></a>3.简单排序之插入排序</h2><h3 id="3-1插入排序实现思路"><a href="#3-1插入排序实现思路" class="headerlink" title="3.1插入排序实现思路"></a>3.1插入排序实现思路</h3><p>插入排序不是通过交换位置而是通过比较找到合适的位置插入元素来达到排序的目的的。相信大家都有过打扑克牌的经历，特别是牌数较大的。在分牌时可能要整理自己的牌，牌多的时候怎么整理呢？就是拿到一张牌，找到一个合适的位置插入。这个原理其实和插入排序是一样的。  </p>
<p>举个栗子，对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置是正确的，想一下在拿到第一张牌的时候，没必要整理。然后第二张牌3要插到5前面，所以把5后移一位，变成3,5,8,6,4.想一下整理牌的时候应该也是这样吧。然后拿到第三张牌时8不用动，拿到第四张牌6时要插在8前面，此时8后移一位，拿到第五张牌4时，要插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经有序。简单插入排序的时间复杂度也是O(n^2)。</p>
<h3 id="3-2插入排序实现代码"><a href="#3-2插入排序实现代码" class="headerlink" title="3.2插入排序实现代码"></a>3.2插入排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//这里首先要假设第一个数位置是正确的(arr[0]是第一张牌)；因为要往后移动数字，必须要假设第一个。然后将第二个数字arr[1]比作打扑克时拿到的第二张牌</span></span><br><span class="line">        <span class="comment">//i依旧控制需要将多少个数字进行排序(n个数字，n-1次排序，为啥？比如只有两个数字，你肯定只需要进行1次排序啊)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;arr.length; i++) &#123; </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> j = i;<span class="comment">//第一次循环时将第二个数字的下标赋给j</span></span><br><span class="line">            <span class="keyword">int</span> target = arr[j]; <span class="comment">//第一次循环时将第二个数字赋值给target(即保留待插入元素)</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//第一次循环时如果第二个数字小于第一个数字，就将第一个数字后移(后面的循环中即将前面的数字都后移一位)</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>]) &#123;</span><br><span class="line">                arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//然后将第二个数字插入到第一个位置 (后面的循环中即将待插入数字插入到前面空出的地方)</span></span><br><span class="line">                arr[j - <span class="number">1</span>] = temp;</span><br><span class="line">                j --;<span class="comment">//将j － 1，继续调整</span></span><br><span class="line">            &#125;     </span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-高效排序之快速排序"><a href="#4-高效排序之快速排序" class="headerlink" title="4.高效排序之快速排序"></a>4.高效排序之快速排序</h2><h3 id="4-1快速排序实现思路"><a href="#4-1快速排序实现思路" class="headerlink" title="4.1快速排序实现思路"></a>4.1快速排序实现思路</h3><p>快速排序一听名字就觉得很高端，在实际应用当中快速排序确实也是表现最好的排序算法。快速排序虽然高端，但其实其思想是来自冒泡排序，冒泡排序是通过相邻元素的比较和交换把最小的冒泡到最顶端，而快速排序是同时比较和交换小数和大数，这样一来不仅把小数冒泡到上面同时也把大数沉到下面。</p>
<p>举个栗子：对5,3,8,6,4这个无序序列进行快速排序，思路是右指针找比基准数小的，左指针找比基准数大的，交换之。</p>
<p>第一次排序:用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。</p>
<p>首先设置i,j两个指针分别指向两端(即i指向5，j指向4)，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。</p>
<p>然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。</p>
<p>一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</p>
<p>上面留下来了一个问题为什么一定要j指针先动呢？首先这也不是绝对的，这取决于基准数的位置，因为在最后两个指针相遇的时候，要交换基准数到相遇的位置。一般选取第一个数作为基准数，那么就是在左边，所以最后相遇的数要和基准数交换，那么相遇的数一定要比基准数小。所以j指针先移动才能先找到比基准数小的数。</p>
<p>快速排序是不稳定的，其时间平均时间复杂度是O(nlgn)。</p>
<h3 id="4-2快速排序实现代码"><a href="#4-2快速排序实现代码" class="headerlink" title="4.2快速排序实现代码"></a>4.2快速排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一次划分</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotKey = arr[left];</span><br><span class="line">        <span class="keyword">int</span> pivotPointer = left;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)</span><br><span class="line">                right --;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)</span><br><span class="line">                left ++;</span><br><span class="line">            swap(arr, left, right); <span class="comment">//把大的交换到右边，把小的交换到左边。</span></span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivotPointer, left); <span class="comment">//最后把pivot交换到中间</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> pivotPos = partition(arr, left, right);</span><br><span class="line">        <span class="comment">//通过上面的partition方法，一次排序后就出现:中间右边的数都比中间的基准数要大、中间左边的数都比中间的基准数要小得规律。这样接下来分两次排序:将中间左边的数进行快速排序、将中间右边的数进行快速排序即可。</span></span><br><span class="line">        quickSort(arr, left, pivotPos-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivotPos+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换的是left、right下标对应的数组元素，而不是交换的left和right的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实上面的代码还可以再优化，上面代码中基准数已经在pivotKey中保存了，所以不需要每次交换都设置一个temp变量，在交换左右指针的时候只需要先后覆盖就可以了。这样既能减少空间的使用还能降低赋值运算的次数。优化代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 划分</span><br><span class="line">     * <span class="doctag">@param</span> arr</span><br><span class="line">     * <span class="doctag">@param</span> left</span><br><span class="line">     * <span class="doctag">@param</span> right</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivotKey = arr[left];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[right] &gt;= pivotKey)</span><br><span class="line">                right --;</span><br><span class="line">            arr[left] = arr[right]; <span class="comment">//把小的移动到左边</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt; right &amp;&amp; arr[left] &lt;= pivotKey)</span><br><span class="line">                left ++;</span><br><span class="line">            arr[right] = arr[left]; <span class="comment">//把大的移动到右边</span></span><br><span class="line">        &#125;</span><br><span class="line">        arr[left] = pivotKey; <span class="comment">//最后把pivot赋值到中间</span></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 递归划分子序列</span><br><span class="line">     * <span class="doctag">@param</span> arr</span><br><span class="line">     * <span class="doctag">@param</span> left</span><br><span class="line">     * <span class="doctag">@param</span> right</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> pivotPos = partition(arr, left, right);</span><br><span class="line">        quickSort(arr, left, pivotPos-<span class="number">1</span>);</span><br><span class="line">        quickSort(arr, pivotPos+<span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结快速排序的思想：冒泡+二分+递归分治，慢慢体会吧。</p>
<h2 id="5-高效排序之堆排序"><a href="#5-高效排序之堆排序" class="headerlink" title="5.高效排序之堆排序"></a>5.高效排序之堆排序</h2><h3 id="5-1堆排序实现思路"><a href="#5-1堆排序实现思路" class="headerlink" title="5.1堆排序实现思路"></a>5.1堆排序实现思路</h3><p>堆排序是借助堆来实现的选择排序，思想同简单的选择排序，以下以大顶堆为例。注意：如果想升序排序就使用大顶堆，反之使用小顶堆。原因是堆顶元素需要交换到序列尾部。</p>
<p>首先，实现堆排序需要解决两个问题：</p>
<ol>
<li>如何由一个无序序列键成一个堆？</li>
<li>如何在输出堆顶元素之后，调整剩余元素成为一个新的堆？</li>
</ol>
<p>第一个问题，可以直接使用线性数组来表示一个堆，由初始的无序序列建成一个堆就需要自底向上从第一个非叶元素开始挨个调整成一个堆。</p>
<p>第二个问题，怎么调整成堆？首先是将堆顶元素和最后一个元素交换。然后比较当前堆顶元素的左右孩子节点，因为除了当前的堆顶元素，左右孩子堆均满足条件，这时需要选择当前堆顶元素与左右孩子节点的较大者（大顶堆）交换，直至叶子节点。我们称这个自堆顶自叶子的调整成为筛选。</p>
<p>从一个无序序列建堆的过程就是一个反复筛选的过程。若将此序列看成是一个完全二叉树，则最后一个非终端节点是n/2取底个元素，由此筛选即可。举个栗子：</p>
<p>49,38,65,97,76,13,27,49序列的堆排序建初始堆和调整的过程如下图:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-11%20%E4%B8%8B%E5%8D%889.21.33.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-11%20%E4%B8%8B%E5%8D%889.21.58.png" alt="">  </p>
<h3 id="5-2堆排序实现代码"><a href="#5-2堆排序实现代码" class="headerlink" title="5.2堆排序实现代码"></a>5.2堆排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 堆筛选，除了start之外，start~end均满足大顶堆的定义。</span><br><span class="line">     * 调整之后start~end称为一个大顶堆。</span><br><span class="line">     * <span class="doctag">@param</span> arr 待调整数组</span><br><span class="line">     * <span class="doctag">@param</span> start 起始指针</span><br><span class="line">     * <span class="doctag">@param</span> end 结束指针</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapAdjust</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>*start+<span class="number">1</span>; i&lt;=end; i*=<span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">//左右孩子的节点分别为2*i,2*i+1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//选择出左右孩子较大的下标</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; end &amp;&amp; arr[i] &lt; arr[i+<span class="number">1</span>]) &#123;</span><br><span class="line">                i ++; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp &gt;= arr[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">//已经为大顶堆，=保持稳定性。</span></span><br><span class="line">            &#125;</span><br><span class="line">            arr[start] = arr[i]; <span class="comment">//将子节点上移</span></span><br><span class="line">            start = i; <span class="comment">//下一轮筛选</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        arr[start] = temp; <span class="comment">//插入正确的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//建立大顶堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length/<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapAdjust(arr, i, arr.length-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=arr.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            heapAdjust(arr, <span class="number">0</span>, i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-高效排序之希尔排序"><a href="#6-高效排序之希尔排序" class="headerlink" title="6.高效排序之希尔排序"></a>6.高效排序之希尔排序</h2><h3 id="6-1希尔排序实现思路"><a href="#6-1希尔排序实现思路" class="headerlink" title="6.1希尔排序实现思路"></a>6.1希尔排序实现思路</h3><p>希尔排序是插入排序的一种高效率的实现，也叫缩小增量排序。简单的插入排序中，如果待排序列是正序时，时间复杂度是O(n)，如果序列是基本有序的，使用直接插入排序效率就非常高。  </p>
<p>希尔排序就利用了这个特点。基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录基本有序时再对全体记录进行一次直接插入排序。    </p>
<p>举个栗子，见下图:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-08%20%E4%B8%8B%E5%8D%887.55.30.png" alt="">  </p>
<p>从上述排序过程可见，希尔排序的特点是，子序列的构成不是简单的逐段分割，而是将某个相隔某个增量的记录组成一个子序列。如上面的例子，第一堂排序时的增量为5，第二趟排序的增量为3。由于前两趟的插入排序中记录的关键字是和同一子序列中的前一个记录的关键字进行比较，因此关键字较小的记录就不是一步一步地向前挪动，而是跳跃式地往前移，从而使得进行最后一趟排序时，整个序列已经做到基本有序，只要作记录的少量比较和移动即可。因此希尔排序的效率要比直接插入排序高。</p>
<p>希尔排序的分析是复杂的，时间复杂度是所取增量的函数，这涉及一些数学上的难题。但是在大量实验的基础上推出当n在某个范围内时，时间复杂度可以达到O(n^1.3)。</p>
<h3 id="6-2希尔排序实现代码"><a href="#6-2希尔排序实现代码" class="headerlink" title="6.2希尔排序实现代码"></a>6.2希尔排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> d = arr.length / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(d &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">            shellInsert(arr, d); <span class="comment">//调用下面的插入方法</span></span><br><span class="line">            d /= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 希尔排序的一趟插入</span><br><span class="line">     * <span class="doctag">@param</span> arr 待排数组</span><br><span class="line">     * <span class="doctag">@param</span> d 增量</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellInsert</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=d; i&lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> j = i - d;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];    <span class="comment">//记录要插入的数据  </span></span><br><span class="line">            <span class="keyword">while</span> (j&gt;=<span class="number">0</span> &amp;&amp; arr[j]&gt;temp) &#123;  <span class="comment">//从后向前，找到比其小的数的位置   </span></span><br><span class="line">                arr[j+d] = arr[j];    <span class="comment">//向后挪动  </span></span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                j -= d;  </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-基于分治递归思想的归并排序"><a href="#7-基于分治递归思想的归并排序" class="headerlink" title="7.基于分治递归思想的归并排序"></a>7.基于分治递归思想的归并排序</h2><h3 id="7-1归并排序实现思路"><a href="#7-1归并排序实现思路" class="headerlink" title="7.1归并排序实现思路"></a>7.1归并排序实现思路</h3><p>归并排序是另一种不同的排序方法，因为归并排序使用了递归分治的思想，所以理解起来比较容易。其基本思想是，先递归划分子问题，然后合并结果。把待排序列看成由两个有序的子序列，然后合并两个子序列;然后把子序列看成两个有序的子子序列，然后合并这两个子子序列;然后…倒着来看，其实就是先两两合并，然后四四合并，最终形成一个有序序列。空间复杂度为O(n)，时间复杂度为O(nlogn)。</p>
<p>举个栗子，见下图:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-08%20%E4%B8%8B%E5%8D%888.00.04.png" alt="">  </p>
<h3 id="7-2归并排序实现代码"><a href="#7-2归并排序实现代码" class="headerlink" title="7.2归并排序实现代码"></a>7.2归并排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        mSort(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 递归分治</span><br><span class="line">     * <span class="doctag">@param</span> arr 待排数组</span><br><span class="line">     * <span class="doctag">@param</span> left 左指针</span><br><span class="line">     * <span class="doctag">@param</span> right 右指针</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        mSort(arr, left, mid); <span class="comment">//递归排序左边</span></span><br><span class="line">        mSort(arr, mid+<span class="number">1</span>, right); <span class="comment">//递归排序右边</span></span><br><span class="line">        merge(arr, left, mid, right); <span class="comment">//合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 合并两个有序数组</span><br><span class="line">     * <span class="doctag">@param</span> arr 待合并数组</span><br><span class="line">     * <span class="doctag">@param</span> left 左指针</span><br><span class="line">     * <span class="doctag">@param</span> mid 中间指针</span><br><span class="line">     * <span class="doctag">@param</span> right 右指针</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//[left, mid] [mid+1, right]</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>]; <span class="comment">//中间数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//执行完这个while循环，相当于将两个子序列合并后重新进行了一次排序并将排序结果记录在了临时数组temp[k]中。while走完后k的值等于数组的长度，i的值此时大于mid，j的值大于right</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt;= arr[j]) &#123;</span><br><span class="line">                temp[k++] = arr[i++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[k++] = arr[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid) &#123;</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j &lt;= right) &#123;</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将有序的临时数组temp[k]一个一个赋值到原数组arr[]中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;temp.length; p++) &#123;</span><br><span class="line">            arr[left + p] = temp[p];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-线性排序之计数排序"><a href="#8-线性排序之计数排序" class="headerlink" title="8.线性排序之计数排序"></a>8.线性排序之计数排序</h2><h3 id="8-1计数排序实现思路"><a href="#8-1计数排序实现思路" class="headerlink" title="8.1计数排序实现思路"></a>8.1计数排序实现思路</h3><p>前面基于比较的排序的时间复杂度下限是O(nlogn)，但接下来要谈的计数排序的时间复杂度却只有O(n)。确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满足一定的范围的整数，而且计数排序需要比较多的辅助空间。  </p>
<p>其基本思想是：用待排序的数作为计数数组的下标，统计每个数字的个数，然后依次输出即可得到有序序列。</p>
<h3 id="8-2计数排序实现代码"><a href="#8-2计数排序实现代码" class="headerlink" title="8.2计数排序实现代码"></a>8.2计数排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//取出数组中数值最大的数</span></span><br><span class="line">        <span class="keyword">int</span> max = max(arr);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用0填充count数组中的每一个数</span></span><br><span class="line">        Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            count[arr[i]] ++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=max; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;count[i]; j++) &#123;</span><br><span class="line">                arr[k++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ele : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span>(ele &gt; max)</span><br><span class="line">                max = ele;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="9-线性排序之桶排序"><a href="#9-线性排序之桶排序" class="headerlink" title="9.线性排序之桶排序"></a>9.线性排序之桶排序</h2><h3 id="9-1桶排序实现思路"><a href="#9-1桶排序实现思路" class="headerlink" title="9.1桶排序实现思路"></a>9.1桶排序实现思路</h3><p>设有一组长度为N的待排关键字序列K[1….n]。首先将这个序列划分成M个的子区间(桶) 。然后基于某种映射函数 ，将待排序列的关键字k映射到第i个桶中(即桶数组B的下标 i) ，那么该关键字k就作为B[i]中的元素(每个桶B[i]都是一组大小为N/M的序列)。接着对每个桶B[i]中的所有元素进行比较排序(可以使用快排)。然后依次枚举输出B[0]….B[M]中的全部内容即是一个有序序列。bindex=f(key)   其中，bindex 为桶数组B的下标(即第bindex个桶), k为待排序列的关键字。桶排序之所以能够高效，其关键在于这个映射函数，它必须做到：如果关键字k1&lt;k2，那么f(k1)&lt;=f(k2)。也就是说B(i)中的最小数据都要大于B(i-1)中最大数据。很显然，映射函数的确定与数据本身的特点有很大的关系。  </p>
<p>举个栗子:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-11%20%E4%B8%8B%E5%8D%889.05.22.png" alt=""></p>
<p>假如待排序列K= {49、 38 、 35、 97 、 76、 73 、 27、 49 }。这些数据全部在1—100之间。因此我们定制10个桶，然后确定映射函数f(k)=k/10。则第一个关键字49将定位到第4个桶中(49/10=4)。依次将所有关键字全部堆入桶中，并在每个非空的桶中进行快速排序后得到如图所示。只要顺序输出每个B[i]中的数据就可以得到有序序列了。</p>
<p><strong>桶排序分析：</strong></p>
<p>桶排序利用函数的映射关系，减少了几乎所有的比较工作。实际上，桶排序的f(k)值的计算，其作用就相当于快排中划分，希尔排序中的子序列，归并排序中的子问题，已经把大量数据分割成了基本有序的数据块(桶)。然后只需要对桶中的少量数据做先进的比较排序即可。　</p>
<p>对N个关键字进行桶排序的时间复杂度分为两个部分：</p>
<ul>
<li><p>(1)循环计算每个关键字的桶映射函数，这个时间复杂度是O(N)。</p>
</li>
<li><p>(2)利用先进的比较排序算法对每个桶内的所有数据进行排序，其时间复杂度为  ∑ O(Ni*logNi) 。其中Ni 为第i个桶的数据量。</p>
</li>
</ul>
<p>很显然，第(2)部分是桶排序性能好坏的决定因素。尽量减少桶内数据的数量是提高效率的唯一办法(因为基于比较排序的最好平均时间复杂度只能达到O(N*logN)了)。因此，我们需要尽量做到下面两点：</p>
<ul>
<li><p>(1)映射函数f(k)能够将N个数据平均的分配到M个桶中，这样每个桶就有[N/M]个数据量。</p>
</li>
<li><p>(2)尽量的增大桶的数量。极限情况下每个桶只能得到一个数据，这样就完全避开了桶内数据的“比较”排序操作。当然，做到这一点很不容易，数据量巨大的情况下，f(k)函数会使得桶集合的数量巨大，空间浪费严重。这就是一个时间代价和空间代价的权衡问题了。</p>
</li>
</ul>
<p>对于N个待排数据，M个桶，平均每个桶[N/M]个数据的桶排序平均时间复杂度为：<code>O(N)+O(M*(N/M)*log(N/M))=O(N+N*(logN-logM))=O(N+N*logN-N*logM)</code></p>
<p>当N=M时，即极限情况下每个桶只有一个数据时。桶排序的最好效率能够达到O(N)。</p>
<p><strong>总结:</strong>桶排序的平均时间复杂度为线性的O(N+C)，其中C=N*(logN-logM)。如果相对于同样的N，桶数量M越大，其效率越高，最好的时间复杂度达到O(N)。 当然桶排序的空间复杂度 为O(N+M)，如果输入数据非常庞大，而桶的数量也非常多，则空间代价无疑是昂贵的。此外，桶排序是稳定的。</p>
<h3 id="9-2桶排序实现代码"><a href="#9-2桶排序实现代码" class="headerlink" title="9.2桶排序实现代码"></a>9.2桶排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BucketSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> &amp;&amp; arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> bucketNums = <span class="number">10</span>; <span class="comment">//这里默认为10，规定待排数[0,100)</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; buckets = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;(); <span class="comment">//桶的索引</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">            buckets.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;()); <span class="comment">//用链表比较合适</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//划分桶</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            buckets.get(f(arr[i])).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对每个桶进行排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;buckets.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!buckets.get(i).isEmpty()) &#123;</span><br><span class="line">                Collections.sort(buckets.get(i)); <span class="comment">//对每个桶进行快排</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//还原排好序的数组</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ele : bucket) &#123;</span><br><span class="line">                arr[k++] = ele;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 映射函数</span><br><span class="line">     * <span class="doctag">@param</span> x</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x / <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-线性排序之基数排序"><a href="#10-线性排序之基数排序" class="headerlink" title="10.线性排序之基数排序"></a>10.线性排序之基数排序</h2><h3 id="10-1基数排序实现思路"><a href="#10-1基数排序实现思路" class="headerlink" title="10.1基数排序实现思路"></a>10.1基数排序实现思路</h3><p>基数排序又是一种和前面排序方式不同的排序方式，基数排序不需要进行记录关键字之间的比较。基数排序是一种借助多关键字排序思想对单逻辑关键字进行排序的方法。所谓的多关键字排序就是有多个优先级不同的关键字。比如说成绩的排序，如果两个人总分相同，则语文高的排在前面，语文成绩也相同则数学高的排在前面…如果对数字进行排序，那么个位、十位、百位就是不同优先级的关键字，如果要进行升序排序，那么个位、十位、百位优先级一次增加。基数排序是通过多次的收分配和收集来实现的，关键字优先级低的先进行分配和收集。  </p>
<p><strong>举个栗子:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-11%20%E4%B8%8B%E5%8D%889.11.11.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-01-11%20%E4%B8%8B%E5%8D%889.11.49.png" alt="">  </p>
<h3 id="10-2基数排序实现代码"><a href="#10-2基数排序实现代码" class="headerlink" title="10.2基数排序实现代码"></a>10.2基数排序实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr == <span class="keyword">null</span> &amp;&amp; arr.length == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxBit = getMaxBit(arr);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=maxBit; i++) &#123;</span><br><span class="line">            </span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; buf = distribute(arr, i); <span class="comment">//分配</span></span><br><span class="line">            collecte(arr, buf); <span class="comment">//收集</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分配</span><br><span class="line">     * <span class="doctag">@param</span> arr 待分配数组</span><br><span class="line">     * <span class="doctag">@param</span> iBit 要分配第几位</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; distribute(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> iBit) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; buf = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">10</span>; j++) &#123;</span><br><span class="line">            buf.add(<span class="keyword">new</span> LinkedList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            buf.get(getNBit(arr[i], iBit)).add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 收集</span><br><span class="line">     * <span class="doctag">@param</span> arr 把分配的数据收集到arr中</span><br><span class="line">     * <span class="doctag">@param</span> buf </span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">collecte</span><span class="params">(<span class="keyword">int</span>[] arr, List&lt;List&lt;Integer&gt;&gt; buf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(List&lt;Integer&gt; bucket : buf) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> ele : bucket) &#123;</span><br><span class="line">                arr[k++] = ele;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取最大位数</span><br><span class="line">     * <span class="doctag">@param</span> x</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMaxBit</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ele : arr) &#123;</span><br><span class="line">            <span class="keyword">int</span> len = (ele+<span class="string">""</span>).length();</span><br><span class="line">            <span class="keyword">if</span>(len &gt; max)</span><br><span class="line">                max = len;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取x的第n位，如果没有则为0.</span><br><span class="line">     * <span class="doctag">@param</span> x</span><br><span class="line">     * <span class="doctag">@param</span> n</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getNBit</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String sx = x + <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">if</span>(sx.length() &lt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> sx.charAt(sx.length()-n) - <span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这10个算法，我完全消化了的有7个，剩下3个如堆排序、桶排序、基数排序，它们的实现思路我是学明白了，但实现代码我想我还需要点时间消化…这里说下看懂实现代码的一个笨方法，就是随便列举一个要排序的序列，然后代入到代码中进行阅读，虽然费时但是这样看代码就简单多了(来自一个编程新手的笨方法…勿喷)。算法这种，关键要领悟它的思想，思想掌握好以后，再去用代码实现它就不难了。</p>
<p><strong>参考:</strong></p>
<ul>
<li><a href="http://www.cnblogs.com/wxisme/p/5243631.html" target="_blank" rel="external">面试中的排序算法总结</a>  </li>
<li><a href="http://hxraid.iteye.com/blog/647759" target="_blank" rel="external">桶排序分析</a></li>
<li><a href="http://www.cnblogs.com/weixliu/archive/2012/12/23/2829671.html" target="_blank" rel="external">部分排序算法分析与介绍</a></li>
</ul>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于Hadoop、Storm和Spark的技术验证]]></title>
      <url>http://codingxiaxw.cn/2016/12/27/64-Hadoop-Storm-Spark/</url>
      <content type="html"><![CDATA[<p>本文基于目前自己负责的视频管理平台，继续探讨Hadoop、Storm以及Spark三种大数据处理框架结合此平台的数据处理，进行功能的比较，然后择优进行开发及使用。<a id="more"></a></p>
<h2 id="1-Hadoop技术验证"><a href="#1-Hadoop技术验证" class="headerlink" title="1.Hadoop技术验证"></a>1.Hadoop技术验证</h2><h3 id="1-1介绍"><a href="#1-1介绍" class="headerlink" title="1.1介绍"></a>1.1介绍</h3><p>以MapReduce为处理引擎,专用于批处理的处理框架。</p>
<h3 id="1-2技术特性"><a href="#1-2技术特性" class="headerlink" title="1.2技术特性"></a>1.2技术特性</h3><p>其包含多个组件，即多个层，通过配合使用可处理批数据。</p>
<ul>
<li><strong>HDFS：</strong>HDFS是一种分布式文件系统层，可对集群节点间的存储和复制进行协调。HDFS确保了无法避免的节点故障发生后数据依然可用，可将其用作数据来源，可用于存储中间态的处理结果，并可存储计算的最终结果。</li>
<li><strong>YARN：</strong>YARN是Yet Another Resource Negotiator（另一个资源管理器）的缩写，可充当Hadoop堆栈的集群协调组件。该组件负责协调并管理底层资源和调度作业的运行。通过充当集群资源的接口，YARN使得用户能在Hadoop集群中使用比以往的迭代方式运行更多类型的工作负载。</li>
<li><strong>MapReduce：</strong>MapReduce是Hadoop的原生批处理引擎。其处理过程为:<ul>
<li>1.从HDFS文件系统读取数据集</li>
<li>2.将数据集拆分成小块并分配给所有可用节点</li>
<li>3.针对每个节点上的数据子集进行计算（计算的中间态结果会重新写入HDFS）</li>
<li>4.重新分配中间态结果并按照键进行分组</li>
<li>5.通过对每个节点计算的结果进行汇总和组合对每个键的值进行“Reducing”(简化)</li>
<li>6.将计算而来的最终结果重新写入 HDFS</li>
</ul>
</li>
</ul>
<h3 id="1-3使用场景"><a href="#1-3使用场景" class="headerlink" title="1.3使用场景"></a>1.3使用场景</h3><p>对数据集的要求:  </p>
<ul>
<li><strong>有界：</strong>批处理数据集代表数据的有限集合</li>
<li><strong>持久：</strong>数据通常始终存储在某种类型的持久存储位置中</li>
<li><strong>大量：</strong>批处理操作通常是处理极为海量数据集的唯一方法</li>
</ul>
<p>批处理非常适合<strong>需要访问全套记录才能完成的计算工作</strong>。例如在计算总数和平均数时，必须将数据集作为一个整体加以处理，而不能将其视作多条记录的集合。这些操作要求在计算进行过程中数据维持自己的状态。</p>
<p>需要处理大量数据的任务通常最适合用批处理操作进行处理。无论直接从持久存储设备处理数据集，或首先将数据集载入内存，批处理系统在设计过程中就充分考虑了数据的量，可提供充足的处理资源。由于批处理在应对大量持久数据方面的表现极为出色，因此经常被用于对历史数据进行分析。</p>
<p>大量数据的处理需要付出大量时间，因此批处理不适合对处理时间要求较高的场合。</p>
<h3 id="1-4验证过程"><a href="#1-4验证过程" class="headerlink" title="1.4验证过程"></a>1.4验证过程</h3><p>本机mac OSX系统，基于Unix，在本机上搭建Hadoop环境相对Windows容易。所以在本机上搭建伪分布式集群环境，通过将HDFS作为数据源，从本机上向HDFS传入文本数据，然后在本机上写代码，对读取到的HDFS上的文本数据进行计算，例如计数(文本单词总数、文本内容行数)、查出某个特定单词出现的频率。</p>
<h3 id="1-5验证结果"><a href="#1-5验证结果" class="headerlink" title="1.5验证结果"></a>1.5验证结果</h3><p>由于Hadoop是一款批处理框架，其处理数据过程必须符合其约束，即处理过程中数据集要始终维持自己的状态(处理过程中不能对数据集进行增、删、改等操作)。而我们的视频管理平台提供的数据源肯定是时刻需要更新的，所以此框架不予采用。</p>
<h2 id="2-Storm技术验证"><a href="#2-Storm技术验证" class="headerlink" title="2.Storm技术验证"></a>2.Storm技术验证</h2><h3 id="2-1介绍"><a href="#2-1介绍" class="headerlink" title="2.1介绍"></a>2.1介绍</h3><p>Apache Storm是一种侧重于极低延迟的流处理框架，也许是要求近实时处理的工作负载的最佳选择。该技术可处理非常大量的数据，通过比其他解决方案更低的延迟提供结果。</p>
<h3 id="2-2技术特性"><a href="#2-2技术特性" class="headerlink" title="2.2技术特性"></a>2.2技术特性</h3><p>Storm的流处理可对框架中名为Topology（拓扑）的DAG（Directed Acyclic Graph，有向无环图）进行编排。这些拓扑描述了当数据片段进入系统后，需要对每个传入的片段执行的不同转换或步骤。</p>
<p>拓扑包含：</p>
<ul>
<li><strong>Stream：</strong>普通的数据流，这是一种会持续抵达系统的无边界数据。</li>
<li><strong>Spout：</strong>位于拓扑边缘的数据流来源，例如可以是API或查询等，从这里可以产生待处理的数据。</li>
<li><strong>Bolt：</strong>Bolt代表需要消耗流数据，对其应用操作，并将结果以流的形式进行输出的处理步骤。Bolt需要与每个Spout建立连接，随后相互连接以组成所有必要的处理。在拓扑的尾部，可以使用最终的Bolt输出作为相互连接的其他系统的输入。</li>
</ul>
<p>Storm背后的想法是使用上述组件定义大量小型的离散操作，随后将多个组件组成所需拓扑。默认情况下Storm提供了“至少一次”的处理保证，这意味着可以确保每条消息至少可以被处理一次(Trident 抽象)，但某些情况下如果遇到失败可能会处理多次(Core Storm)。Storm无法确保可以按照特定顺序处理消息。</p>
<p>为了实现严格的一次处理，即有状态处理，可以使用一种名为Trident的抽象。严格来说不使用Trident的Storm通常可称之为Core Storm。Trident会对Storm的处理能力产生极大影响，会增加延迟，为处理提供状态，使用微批模式代替逐项处理的纯粹流处理模式。</p>
<p>为避免这些问题，通常建议Storm用户尽可能使用Core Storm。然而也要注意，Trident对内容严格的一次处理保证在某些情况下也比较有用，例如系统无法智能地处理重复消息时。如果需要在项之间维持状态，例如想要计算一个小时内有多少用户点击了某个链接，此时Trident将是你唯一的选择。尽管不能充分发挥框架与生俱来的优势，但Trident提高了Storm的灵活性。</p>
<p>Trident拓扑包含:</p>
<ul>
<li>流批（Stream batch）：这是指流数据的微批，可通过分块提供批处理语义。</li>
<li>操作（Operation）：是指可以对数据执行的批处理过程。</li>
</ul>
<h3 id="2-3使用场景"><a href="#2-3使用场景" class="headerlink" title="2.3使用场景"></a>2.3使用场景</h3><p>流处理系统会对随时进入系统的数据进行计算。相比批处理模式，这是一种截然不同的处理方式。流处理方式无需针对整个数据集执行操作，而是对通过系统传输的每个数据项执行操作。流处理中的数据集是“无边界”的，这就产生了几个重要的影响:</p>
<ul>
<li>完整数据集只能代表截至目前已经进入到系统中的数据总量。</li>
<li>工作数据集也许更相关，在特定时间只能代表某个单一数据项。</li>
<li>处理工作是基于事件的，除非明确停止否则没有“尽头”。处理结果立刻可用，并会随着新数据的抵达继续更新。</li>
</ul>
<p>流处理系统可以处理几乎无限量的数据，但同一时间只能处理一条（真正的流处理）或很少量（微批处理，Micro-batch Processing）数据，不同记录间只维持最少量的状态。虽然大部分系统提供了用于维持某些状态的方法，但流处理主要针对副作用更少，更加功能性的处理（Functional processing）进行优化。</p>
<p>功能性操作主要侧重于状态或副作用有限的离散步骤。针对同一个数据执行同一个操作会或略其他因素产生相同的结果，此类处理非常适合流处理，因为不同项的状态通常是某些困难、限制，以及某些情况下不需要的结果的结合体。因此虽然某些类型的状态管理通常是可行的，但这些框架通常在不具备状态管理机制时更简单也更高效。</p>
<p>此类处理非常适合某些类型的工作负载。有近实时处理需求的任务很适合使用流处理模式。分析、服务器或应用程序错误日志，以及其他基于时间的衡量指标是最适合的类型，因为对这些领域的数据变化做出响应对于业务职能来说是极为关键的。流处理很适合用来处理必须对变动或峰值做出响应，并且关注一段时间内变化趋势的数据。</p>
<h4 id="2-3-1优势和局限"><a href="#2-3-1优势和局限" class="headerlink" title="2.3.1优势和局限"></a>2.3.1优势和局限</h4><p>目前来说Storm可能是近实时处理领域的最佳解决方案。该技术可以用极低延迟处理数据，可用于希望获得最低延迟的工作负载。如果处理速度直接影响用户体验，例如需要将处理结果直接提供给访客打开的网站页面，此时Storm将会是一个很好的选择。</p>
<p>Storm与Trident配合使得用户可以用微批代替纯粹的流处理。虽然借此用户可以获得更大灵活性打造更符合要求的工具，但同时这种做法会削弱该技术相比其他解决方案最大的优势。话虽如此，但多一种流处理方式总是好的。</p>
<p>Core Storm无法保证消息的处理顺序。Core Storm为消息提供了“至少一次”的处理保证，这意味着可以保证每条消息都能被处理，但也可能发生重复。Trident提供了严格的一次处理保证，可以在不同批之间提供顺序处理，但无法在一个批内部实现顺序处理。</p>
<p>在互操作性方面，Storm可与Hadoop的YARN资源管理器进行集成，因此可以很方便地融入现有Hadoop部署。除了支持大部分处理框架，Storm还可支持多种语言，为用户的拓扑定义提供了更多选择。</p>
<h4 id="2-3-2总结"><a href="#2-3-2总结" class="headerlink" title="2.3.2总结"></a>2.3.2总结</h4><p>对于延迟需求很高的纯粹的流处理工作负载，Storm可能是最适合的技术。该技术可以保证每条消息都被处理，可配合多种编程语言使用。由于Storm无法进行批处理，如果需要这些能力可能还需要使用其他软件。如果对严格的一次处理保证有比较高的要求，此时可考虑使用Trident。不过这种情况下其他流处理框架也许更适合。</p>
<h3 id="2-4验证过程"><a href="#2-4验证过程" class="headerlink" title="2.4验证过程"></a>2.4验证过程</h3><p>待验证。</p>
<h3 id="2-5验证结果"><a href="#2-5验证结果" class="headerlink" title="2.5验证结果"></a>2.5验证结果</h3><p>基于Storm的实时处理性，待验证。</p>
<h2 id="3-Spark技术验证"><a href="#3-Spark技术验证" class="headerlink" title="3.Spark技术验证"></a>3.Spark技术验证</h2><h3 id="3-1介绍"><a href="#3-1介绍" class="headerlink" title="3.1介绍"></a>3.1介绍</h3><p>Apache Spark是一种包含<strong>流处理能力</strong>的下一代<strong>批处理框架</strong>。与Hadoop的MapReduce引擎基于各种相同原则开发而来的Spark主要侧重于通过完善的内存计算和处理优化机制加快批处理工作负载的运行速度。</p>
<p>Spark可作为独立集群部署（需要相应存储层的配合），或可与Hadoop集成并取代MapReduce引擎。我这里采用与Hadoop集成部署的结构，在本机上搭建的spark伪分布式环境。</p>
<h3 id="3-2技术特性"><a href="#3-2技术特性" class="headerlink" title="3.2技术特性"></a>3.2技术特性</h3><p>既然Spark是一种包含<strong>流处理能力</strong>的下一代<strong>批处理框架</strong>，那么它就具备同时处理批处理和流处理工作负载的技术。</p>
<h4 id="3-2-1批处理模式"><a href="#3-2-1批处理模式" class="headerlink" title="3.2.1批处理模式"></a>3.2.1批处理模式</h4><p>与MapReduce不同，Spark的数据处理工作全部在内存中进行，只在一开始将数据读入内存，以及将最终结果持久存储时需要与存储层交互。所有中间态的处理结果均存储在内存中。</p>
<p>虽然内存中处理方式可大幅改善性能，Spark在处理与磁盘有关的任务时速度也有很大提升，因为通过提前对整个任务集进行分析可以实现更完善的整体式优化。为此Spark可创建代表所需执行的全部操作，需要操作的数据，以及操作和数据之间关系的Directed Acyclic Graph（有向无环图），即DAG，借此处理器可以对任务进行更智能的协调。</p>
<p>为了实现内存中批计算，Spark会使用一种名为Resilient Distributed Dataset（弹性分布式数据集），即RDD的模型来处理数据。这是一种代表数据集，只位于内存中，永恒不变的结构。针对RDD执行的操作可生成新的RDD。每个RDD可通过世系（Lineage）回溯至父级RDD，并最终回溯至磁盘上的数据。Spark可通过RDD在无需将每个操作的结果写回磁盘的前提下实现容错。</p>
<h4 id="3-2-2流处理模式"><a href="#3-2-2流处理模式" class="headerlink" title="3.2.2流处理模式"></a>3.2.2流处理模式</h4><p>流处理能力是由Spark Streaming实现的。Spark本身在设计上主要面向批处理工作负载，为了弥补引擎设计和流处理工作负载特征方面的差异，Spark实现了一种叫做微批（Micro-batch）*的概念。在具体策略方面该技术可以将数据流视作一系列非常小的“批”，借此即可通过批处理引擎的原生语义进行处理。</p>
<p>Spark Streaming会以亚秒级增量对流进行缓冲，随后这些缓冲会作为小规模的固定数据集进行批处理。</p>
<h3 id="3-3使用场景"><a href="#3-3使用场景" class="headerlink" title="3.3使用场景"></a>3.3使用场景</h3><p>使用Spark而非Hadoop MapReduce的主要原因是速度。在内存计算策略和先进的DAG调度等机制的帮助下，Spark可以用更快速度处理相同的数据集。</p>
<p>Spark的另一个重要优势在于多样性。该产品可作为独立集群部署，或与现有Hadoop集群集成。该产品可运行批处理和流处理，运行一个集群即可处理不同类型的任务。</p>
<p>除了引擎自身的能力外，围绕Spark还建立了包含各种库的生态系统，可为机器学习、交互式查询等任务提供更好的支持。相比MapReduce，Spark任务更是“众所周知”地易于编写，因此可大幅提高生产力。</p>
<p>为流处理系统采用批处理的方法，需要对进入系统的数据进行缓冲。缓冲机制使得该技术可以处理非常大量的传入数据，提高整体吞吐率，但等待缓冲区清空也会导致延迟增高。这意味着Spark Streaming可能不适合处理对延迟有较高要求的工作负载。</p>
<p>由于内存通常比磁盘空间更贵，因此相比基于磁盘的系统，Spark成本更高。然而处理速度的提升意味着可以更快速完成任务，在需要按照小时数为资源付费的环境中，这一特性通常可以抵消增加的成本。</p>
<p>Spark内存计算这一设计的另一个后果是，如果部署在共享的集群中可能会遇到资源不足的问题。相比Hadoop MapReduce，Spark的资源消耗更大，可能会对需要在同一时间使用集群的其他任务产生影响。从本质来看，Spark更不适合与Hadoop堆栈的其他组件共存一处。</p>
<h3 id="3-4验证过程"><a href="#3-4验证过程" class="headerlink" title="3.4验证过程"></a>3.4验证过程</h3><p>在本机上搭建Spark伪分布式环境，和Hadoop进行集成，通过将HDFS作为数据源，从本机上向HDFS传入文本数据，然后在本机上写代码，对读取到的HDFS上的文本数据进行计算，例如计数(文本单词总数、文本内容行数)、查出某个特定单词出现的频率。与Hadoop验证过程的区别在于代码的不同，Hadoop采用的MapReduce作为引擎进行对批数据的处理，而Spark是基于RDD(弹性分布式数据集)的模型(action和transformation操作)来处理批数据、spark Streaming来处理流数据。</p>
<h3 id="3-5验证结果"><a href="#3-5验证结果" class="headerlink" title="3.5验证结果"></a>3.5验证结果</h3><p>集批数据处理和流数据处理于一体的Spark处理框架，是多样化工作负载处理任务的最佳选择。Spark批处理能力以更高内存占用为代价提供了无与伦比的速度优势。对于重视吞吐率而非延迟的工作负载，则比较适合使用Spark Streaming作为流处理解决方案。</p>
<p><strong>本文参考:</strong><a href="http://www.infoq.com/cn/articles/hadoop-storm-samza-spark-flink" target="_blank" rel="external">大数据框架对比：Hadoop、Storm、Samza、Spark和Flink</a></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[『 JavaCV 』JavaCV+FFmpeg实现推流和拉流]]></title>
      <url>http://codingxiaxw.cn/2016/12/21/63-javacv-ffmpeg/</url>
      <content type="html"><![CDATA[<p>研究了接近一个星期的流媒体技术，等好不容易有点成就(其实我是打算写个直播系统的= =。阿嘿)的时候又被领导派去学习spark分布式计算框架了…关于流媒体的技术，之前写了一篇使用<a href="http://codingxiaxw.cn/2016/12/14/62-javacv/">JavaCV调用本机摄像头</a>的文章，趁着工作之余，也更新下第二篇关于流媒体的博客。本篇文章介绍使用JavaCV和FFmpeg完成视频的推流及拉流。<a id="more"></a>  </p>
<p>啥是推流啥是拉流？＝＝。直播听过吗？直播就是一个将推流及拉流运用到极致的一个产品。那么直播是如何表现出推流和拉流功能的？我还是简短的介绍一下吧，详细介绍请自行google。  </p>
<ul>
<li><strong>1.推流:</strong>将录制视频进行<strong>采集</strong>、<strong>编码</strong>、<strong>美颜处理</strong>后推送给直播服务器进行处理。将视频推送到服务器的这一过程就叫做推流。  </li>
<li><strong>2.拉流:</strong>服务器对传送过来的视频进行处理例如<strong>转码</strong>、<strong>录制</strong>、<strong>截图</strong>、<strong>鉴黄</strong>后将视频分发给正在观看直播的客户(播放器)。服务器将视频分发给客户端的这一过程就叫做拉流咯。  </li>
</ul>
<p>下面我来谈谈如何实现上述功能，由于博主没有买服务器，所以在下面的代码中我就将服务器的地址写为我本机的文件目录路径咯，你使用的时候只需将我的本地路径修改为你的服务器地址即可。</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>1.<strong>准备jar包:</strong>1.javacv.jar。2.javacpp.jar。3.ffmpeg.jar。4.ffmpeg-系统平台.jar。5.opencv.jar。6.opencv-系统平台.jar。  </p>
<p><strong>为什么要这些jar包:</strong>因为ffmpeg-系统平台.jar中存放的是c/c++本地so/dll库，而ffmpeg.jar就是使用javacpp封装的对应本地库Java接口的实现，而javacpp就是基于jni的一个功能性封装包，方便实现jni，javacv.jar就是对9个视觉库进行了二次封装，但是实现的功能有限，所以建议新手先熟悉openCV和ffmpeg这两个C/C++库的API后再来看javaCV思路就会很清晰了。  </p>
<p>2.<strong>开发工具:</strong>eclipse和IDEA都行啦。</p>
<p>3.<strong>功能介绍:</strong></p>
<ul>
<li>1.推流端:实现调用本机摄像头边播放边录制/推流，停止预览(关掉摄像头窗口)即停止录制/推流。</li>
<li>2.拉流端:实现将服务器端的视频资源拉到本地。</li>
</ul>
<h2 id="2-推流端的代码实现"><a href="#2-推流端的代码实现" class="headerlink" title="2.推流端的代码实现"></a>2.推流端的代码实现</h2><p>这里我就直接上代码啦，每行代码具体意思见代码旁注释:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.codingxiaxw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.Loader;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.avcodec;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.opencv_core.IplImage;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacpp.opencv_objdetect;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.CanvasFrame;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.Frame;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameGrabber;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameRecorder;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.OpenCVFrameConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordCameraPullTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, org.bytedeco.javacv.FrameRecorder.Exception, Exception</span><br><span class="line">	 </span>&#123;</span><br><span class="line">		 recordCamera(<span class="string">"/Users/codingBoy/Desktop/picture/camera/output.mp4"</span>, <span class="number">25</span>);<span class="comment">//这里将地址换成你的远程视频服务器地址例如recordCamera("rtmp://192.168.30.21/live/record1",25);  即可</span></span><br><span class="line">	 &#125;</span><br><span class="line">	</span><br><span class="line">	 <span class="comment">/**</span><br><span class="line">	  * </span><br><span class="line">	  * <span class="doctag">@param</span> outputFile 服务器地址，我这里直接将视频输送到我本机目录</span><br><span class="line">	  * <span class="doctag">@param</span> frameRate</span><br><span class="line">	  * <span class="doctag">@throws</span> Exception</span><br><span class="line">	  * <span class="doctag">@throws</span> InterruptedException</span><br><span class="line">	  * <span class="doctag">@throws</span> org.bytedeco.javacv.FrameRecorder.Exception</span><br><span class="line">	  */</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recordCamera</span><span class="params">(String outputFile, <span class="keyword">double</span> frameRate)</span>  </span><br><span class="line">	            <span class="keyword">throws</span> Exception, InterruptedException, org.bytedeco.javacv.FrameRecorder.Exception </span>&#123;  </span><br><span class="line">	        Loader.load(opencv_objdetect.class);  </span><br><span class="line">	        FrameGrabber grabber = FrameGrabber.createDefault(<span class="number">0</span>);<span class="comment">//本机摄像头默认0，这里使用javacv的抓取器，至于使用的是ffmpeg还是opencv，请自行查看源码  </span></span><br><span class="line">	        grabber.start();<span class="comment">//开启抓取器  </span></span><br><span class="line">	  </span><br><span class="line">	        OpenCVFrameConverter.ToIplImage converter = <span class="keyword">new</span> OpenCVFrameConverter.ToIplImage();<span class="comment">//转换器  </span></span><br><span class="line">	        IplImage grabbedImage = converter.convert(grabber.grab());<span class="comment">//抓取一帧视频并将其转换为图像，至于用这个图像用来做什么？加水印，人脸识别等等自行添加  </span></span><br><span class="line">	        <span class="keyword">int</span> width = grabbedImage.width();  </span><br><span class="line">	        <span class="keyword">int</span> height = grabbedImage.height();  </span><br><span class="line">	      </span><br><span class="line">	        FrameRecorder recorder = FrameRecorder.createDefault(outputFile, width, height);  </span><br><span class="line">	        recorder.setVideoCodec(avcodec.AV_CODEC_ID_H264); <span class="comment">// avcodec.AV_CODEC_ID_H264，编码  </span></span><br><span class="line">	        recorder.setFormat(<span class="string">"flv"</span>);<span class="comment">//封装格式，如果是推送到rtmp就必须是flv封装格式  </span></span><br><span class="line">	        recorder.setFrameRate(frameRate);  </span><br><span class="line">	          </span><br><span class="line">	        recorder.start();<span class="comment">//开启录制器  </span></span><br><span class="line">	        <span class="keyword">long</span> startTime=<span class="number">0</span>;  </span><br><span class="line">	        <span class="keyword">long</span> videoTS=<span class="number">0</span>;  </span><br><span class="line">	        CanvasFrame frame = <span class="keyword">new</span> CanvasFrame(<span class="string">"camera"</span>, CanvasFrame.getDefaultGamma() / grabber.getGamma());  </span><br><span class="line">	        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  </span><br><span class="line">	        frame.setAlwaysOnTop(<span class="keyword">true</span>);  </span><br><span class="line">	        Frame rotatedFrame=converter.convert(grabbedImage);<span class="comment">//不知道为什么这里不做转换就不能推到rtmp  </span></span><br><span class="line">	        <span class="keyword">while</span> (frame.isVisible() &amp;&amp; (grabbedImage = converter.convert(grabber.grab())) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">	            rotatedFrame = converter.convert(grabbedImage);  </span><br><span class="line">	            frame.showImage(rotatedFrame);  </span><br><span class="line">	            <span class="keyword">if</span> (startTime == <span class="number">0</span>) &#123;  </span><br><span class="line">	                startTime = System.currentTimeMillis();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            videoTS = <span class="number">1000</span> * (System.currentTimeMillis() - startTime);  </span><br><span class="line">	            recorder.setTimestamp(videoTS);  </span><br><span class="line">	            recorder.record(rotatedFrame);  </span><br><span class="line">	            Thread.sleep(<span class="number">40</span>);  </span><br><span class="line">	        &#125;  </span><br><span class="line">	        frame.dispose();  </span><br><span class="line">	        recorder.stop();  </span><br><span class="line">	        recorder.release();  </span><br><span class="line">	        grabber.stop();  	      </span><br><span class="line">	    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，会自动启动你本机的摄像头开始录制，同时你会在本机目录(或是远程服务器上)看到一个新生成的.flv(其它格式你只要修改相应视频后缀即可)视频文件，关闭摄像头，便可查看这个.flv视频文件。这样，我们便实现了使用本机摄像头进行录制并将此视频推送到服务器(或者本机)上。接下来看看如何实现拉流功能。</p>
<h2 id="3-拉流端代码实现"><a href="#3-拉流端代码实现" class="headerlink" title="3.拉流端代码实现"></a>3.拉流端代码实现</h2><p>同样直接上代码，不懂就使劲代码，一遍不懂看两遍，两遍不懂…去撞墙吧:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.codingxiaxw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FFmpegFrameGrabber;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FFmpegFrameRecorder;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.Frame;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameGrabber;</span><br><span class="line"><span class="keyword">import</span> org.bytedeco.javacv.FrameRecorder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecordCollect3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">frameRecord</span><span class="params">(String inputFile, String outputFile, <span class="keyword">boolean</span> AUDIO_ENABLED)</span>  </span><br><span class="line">	            <span class="keyword">throws</span> Exception, org.bytedeco.javacv.FrameRecorder.Exception </span>&#123;  </span><br><span class="line">	        <span class="comment">// 是否录制音频  </span></span><br><span class="line">	        <span class="keyword">int</span> audioChannel = AUDIO_ENABLED ? <span class="number">1</span> : <span class="number">0</span>;  </span><br><span class="line">	        <span class="comment">// 获取视频源  </span></span><br><span class="line">	        FFmpegFrameGrabber grabber = <span class="keyword">new</span> FFmpegFrameGrabber(inputFile);  </span><br><span class="line">	        <span class="comment">// 流媒体输出地址，分辨率（长，高），是否录制音频（0:不录制/1:录制）  </span></span><br><span class="line">	        FFmpegFrameRecorder recorder = <span class="keyword">new</span> FFmpegFrameRecorder(outputFile, <span class="number">1280</span>, <span class="number">720</span>, audioChannel);  </span><br><span class="line">	        <span class="comment">// 开始取视频源  </span></span><br><span class="line">	        recordByFrame(grabber, recorder, AUDIO_ENABLED);  </span><br><span class="line">	    &#125;    </span><br><span class="line">	  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recordByFrame</span><span class="params">(FFmpegFrameGrabber grabber, FFmpegFrameRecorder recorder, Boolean status)</span>  </span><br><span class="line">	            <span class="keyword">throws</span> Exception, org.bytedeco.javacv.FrameRecorder.Exception </span>&#123;  </span><br><span class="line">	        <span class="keyword">try</span> &#123;  <span class="comment">//建议在线程中使用该方法  </span></span><br><span class="line">	        	</span><br><span class="line">	            grabber.start();  </span><br><span class="line">	            recorder.start();  </span><br><span class="line">	            Frame frame = <span class="keyword">null</span>;  </span><br><span class="line">	            <span class="keyword">while</span> (status &amp;&amp; (frame = grabber.grabFrame()) != <span class="keyword">null</span>) &#123;  </span><br><span class="line">	                recorder.record(frame);  </span><br><span class="line">	            &#125;  </span><br><span class="line">	            recorder.stop();  </span><br><span class="line">	            grabber.stop();  </span><br><span class="line">	        &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">	            <span class="keyword">if</span> (grabber != <span class="keyword">null</span>) &#123;  </span><br><span class="line">	                grabber.stop();  </span><br><span class="line">	            &#125;  </span><br><span class="line">	        &#125;  </span><br><span class="line">	    &#125;  </span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line">	  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span><br><span class="line">	            <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">	  </span><br><span class="line">	         String inputFile = <span class="string">"/Users/codingBoy/Desktop/picture/camera/output.mp4"</span>;  </span><br><span class="line">	         <span class="comment">// Decodes-encodes  </span></span><br><span class="line">	         String outputFile = <span class="string">"/Users/codingBoy/Desktop/picture/camera/recorde.mp4"</span>;  </span><br><span class="line">	         frameRecord(inputFile, outputFile,<span class="keyword">true</span>);  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中<code>inputFile</code>传入你的远程服务器地址如<code>rtsp://admin:admin@192.168.2.236:37779/cam/realmonitor?channel=1&amp;subtype=0</code>即可。<code>outputFile</code>表示你需要将远程服务器上的视频拉到你本地的哪个文件目录下。这样，我们便完成了拉流端代码的实现。  </p>
<p>好了，只要你将上述的代码看懂(放心，我刚开始研究这东西，也是把别人的源码看了几十来遍吧才看懂的.)，然后再去查点关于流媒体的资料，简书上有很多人有写实现直播功能的一系列教程，去看看，不久后你也能写出一个像样的直播系统。  </p>
<p>关于流媒体这块内容我不打算再更新博客啦，除非以后突然有兴趣继续研究直播功能这块，所以大家要是想继续研究的话，点击参考链接看下这位大神写的关于JavaCV和FFmpeg的详细博客吧。  </p>
<p>参考:<a href="http://blog.csdn.net/eguid_1/article/details/51659578" target="_blank" rel="external">javacv开发详解系列</a>  </p>
<p>最后，祝你好运。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[『 JavaCV 』JavaCV之调用本机摄像头]]></title>
      <url>http://codingxiaxw.cn/2016/12/14/62-javacv/</url>
      <content type="html"><![CDATA[<p>最近学习用java语言如何进行人脸识别的功能，人脸检测有助于在任何数字图像上识别人脸，在做了一些研究后，我发现OpenCV的库可以帮我检测图像中的人脸，所以接触到了opencv这门技术。  <a id="more"></a></p>
<p>什么是opencv? OpenCV(Open Source Computer Vision) 是一个开源的计算机视觉算法库。是用C/C++写的，旨在发挥多核心的优势。它提供C++、C、Python和Java的接口，并支持所有主流操作系统平台，包括Windows、Linux、Mac OS、iOS及Android。  </p>
<h2 id="1-写在前面的话"><a href="#1-写在前面的话" class="headerlink" title="1.写在前面的话"></a>1.写在前面的话</h2><p><strong>因为博主在用java开发人脸识别功能时走了不少的弯路，所以有些话我要写在前面，避免你走不少的弯路:</strong>  </p>
<ul>
<li><p>1.因为opencv是用c++写的，所以你要是打算用c++或者python在opencv上进行开发，那么你首先需要的就是在自己的电脑上搭建opencv的开发环境，若是mac系统搜”mac下opencv的搭建”，windows系统搜”windows下opencv的搭建”即可。若是你真的采用上面所说的两种语言开发的，那么本篇文章你就可以跳过去了，因为本篇文章是在java环境下描述的。</p>
</li>
<li><p>2.如果你像我一样打算用java去完成人脸识别，那么恭喜你，opencv的环境就不用你亲自动手去搭建了，本篇文章也很适合你。或许有人会问:opencv是用c++写的嘛，所以自然而言我们要用c++去调用它的相关方法嘛，那么用java如何调用呢?opencv是从2.2.4版本开始后就提供了java语言编写的相关接口，使得java开发人员可以通过JNI去调用opencv的相关库，这里有个很酷的库叫javacv，从javacv0.8版本以后，就完全将opencv的功能封装在自己的库中，所以我们可以直接通过引用opencv对应的系统平台的引用包而不用再搭建繁琐的opencv环境咯。首先<a href="http://search.maven.org/remotecontent?filepath=org/bytedeco/javacv-platform/1.3/javacv-platform-1.3-bin.zip" target="_blank" rel="external">点击链接下载javacv中所有的jar包</a>，解压后里面有所有的javacv开发的相关jar包，本篇文章我们需要的jar包只有4个:opencv.jar、javacv.jar、javacpp.jar、opencv-macosx-x86_64.jar(这个jar包要跟自己的操作系统相同，你要是是windows系统就选择相应的opencv-windows-x86_64位或者32位jar包)，其他的jar包当遇到时我会再说。</p>
</li>
</ul>
<p>这里说说我遇到的坑，网上很多关于javacv的搭建环境的教程，然后都是大同小异先教你搭建opencv的环境，然后给你一个实例让你测试自己的opencv环境是否成功搭建。说到这里我就想骂人了，那些教需要在电脑上搭建opencv环境的，你不知道javacv0.8版本之后就不用再搭建opencv的环境了吗？麻烦你知道了就快点把博客内容改改吧，不要再耽误我们这些java开发人员的时间了好吗？我看了你们的教程可是关搭建opencv的环境就浪费了两天时间…  </p>
<p>另外本篇文章是在mac环境下运行的，windows系统也同样能参考我这篇文章。</p>
<h2 id="2-准备环境"><a href="#2-准备环境" class="headerlink" title="2.准备环境"></a>2.准备环境</h2><p>1.相关jar包，本篇文章只需要4个jar包即可:  </p>
<p><strong>mac系统:</strong>javacpp.jar，javacv.jar,opencv.jar,opencv-macosx-x86_64.jar。<br><strong>windows系统:</strong>javacpp.jar，javacv.jar,opencv.jar,oepncv-windows-x86_64.jar(或者oepncv-windows-x86.jar)。<br><strong>Linux系统:</strong>javacpp.jar，javacv.jar,opencv.jar,,opencv-linux-x86_64.jar。  </p>
<p>2.貌似准备环境只需要上述四个jar包即可。。。本地opencv的环境已不再需要你在自己的电脑上搭建。。。当然开发工具eclipse和IDEA都可以。  </p>
<h2 id="3-Demo-java通过javacv获取本机电脑摄像头"><a href="#3-Demo-java通过javacv获取本机电脑摄像头" class="headerlink" title="3.Demo:java通过javacv获取本机电脑摄像头"></a>3.Demo:java通过javacv获取本机电脑摄像头</h2><p>好了废话不要那么多，直接开始coding吧。新建一个java项目，普通项目即可，创建一个JavacvCameraTest.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import相关类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavacvCameraTest</span>  </span><br><span class="line"></span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, InterruptedException  </span><br><span class="line"></span>&#123;  </span><br><span class="line">    OpenCVFrameGrabber grabber = <span class="keyword">new</span> OpenCVFrameGrabber(<span class="number">0</span>);    </span><br><span class="line">    grabber.start();   <span class="comment">//开始获取摄像头数据  </span></span><br><span class="line">    CanvasFrame canvas = <span class="keyword">new</span> CanvasFrame(<span class="string">"摄像头"</span>);<span class="comment">//新建一个窗口  </span></span><br><span class="line">    canvas.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);  </span><br><span class="line">    canvas.setAlwaysOnTop(<span class="keyword">true</span>);  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(!canvas.isDisplayable())  </span><br><span class="line">        &#123;<span class="comment">//窗口是否关闭  </span></span><br><span class="line">            grabber.stop();<span class="comment">//停止抓取  </span></span><br><span class="line">            System.exit(<span class="number">2</span>);<span class="comment">//退出  </span></span><br><span class="line">        &#125;  </span><br><span class="line">        canvas.showImage(grabber.grab());<span class="comment">//获取摄像头图像并放到窗口上显示， 这里的Frame frame=grabber.grab(); frame是一帧视频图像  </span></span><br><span class="line">  </span><br><span class="line">        Thread.sleep(<span class="number">50</span>);<span class="comment">//50毫秒刷新一次图像  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后运行程序，过不了几秒神奇的事就会发生了…我说几秒钟你会出现在你自己的电脑屏幕上你信吗。</p>
<p><strong>后话:</strong>本来上级布下任务，要使用javacv完成人脸识别的功能。老实说，用javacv这个东西完全没有人带，网上资料少之又少，可是没办法，领导布置的任务必须要完成。所以自己确实走了不少的弯路，希望总结下来为你解决不少的问题。  </p>
<p>当然这里又会有人问，既然是要用javacv做视频流转换成图片的功能，那这篇文章为啥要写用它调用本机摄像头的功能实现呢?亲，你总得先学会使用它的相关API吧！期待我下篇关于javacv的相关API的文章请点击<a href="http://codingxiaxw.cn/2016/12/21/63-javacv-ffmpeg/">JavaCV+FFmpeg实现推流和拉流</a></p>
<p>若是我没有更新，请参考某位大神写的关于javacv的系列文章，<a href="http://blog.csdn.net/eguid_1/article/details/51659578" target="_blank" rel="external">javacv开发详解之1：调用本机摄像头视频</a>,还有详解2、详解3…详解7，很有参考价值!</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[『 Spark 』使用Spark Streaming处理流式数据]]></title>
      <url>http://codingxiaxw.cn/2016/12/10/61-spark-streaming/</url>
      <content type="html"><![CDATA[<p>在上篇文章<a href="http://codingxiaxw.cn/2016/12/07/60-mac-spark/">mac下Spark的安装与使用</a>的一个示例中，我们使用RDD的Map和Reduce操作对一个文本中的文字做了简单的字数检查。本篇文章的目的是讲述Spark 中的流数据处理。结构分为三个部分:第一部分简单对Spark进行介绍，第二部分介绍Spark Streaming，最后一部分通过一个简单的Demo讲讲Spark是如何通过Spark Streaming进行流式数据的处理。<a id="more"></a>  </p>
<h2 id="1-简单介绍Spark"><a href="#1-简单介绍Spark" class="headerlink" title="1.简单介绍Spark"></a>1.简单介绍Spark</h2><p>查看Spark官方文档，发现Spark除了Map和Reduce操作之外，它还支持SQL查询(Spark SQL)，流数据(Spark Streaming)，机器学习(Spark MLlib)和图表数据处理(Spark GraphX),也就是Spark的一些Api。开发者可以在一个数据管道用例中单独使用某一能力或者将这些能力结合在一起使用。  </p>
<h3 id="1-1Spark生态系统"><a href="#1-1Spark生态系统" class="headerlink" title="1.1Spark生态系统"></a>1.1Spark生态系统</h3><p>除了Spark核心API之外，Spark生态系统中还包括其他附加库，可以在大数据分析和机器学习领域提供更多的能力。这些库的介绍如下:  </p>
<ul>
<li><strong>Spark Streaming:</strong><ul>
<li>Spark Streaming基于微批量方式的计算和处理，可以用于处理实时的流数据。它使用DStream，简单来说就是一个弹性分布式数据集（RDD）系列，处理实时数据。</li>
</ul>
</li>
<li><strong>Spark SQL:</strong><ul>
<li>Spark SQL可以通过JDBC API将Spark数据集暴露出去，而且还可以用传统的BI和可视化工具在Spark数据上执行类似SQL的查询。用户还可以用Spark SQL对不同格式的数据（如JSON，Parquet以及数据库等）执行ETL，将其转化，然后暴露给特定的查询。</li>
</ul>
</li>
<li><strong>Spark MLlib:</strong><ul>
<li>MLlib是一个可扩展的Spark机器学习库，由通用的学习算法和工具组成，包括二元分类、线性回归、聚类、协同过滤、梯度下降以及底层优化原语。</li>
</ul>
</li>
<li><strong>Spark GraphX:</strong><ul>
<li>GraphX是用于图计算和并行图计算的新的（alpha）Spark API。通过引入弹性分布式属性图（Resilient Distributed Property Graph），一种顶点和边都带有属性的有向多重图，扩展了Spark RDD。为了支持图计算，GraphX暴露了一个基础操作符集合（如subgraph，joinVertices和aggregateMessages）和一个经过优化的Pregel API变体。此外，GraphX还包括一个持续增长的用于简化图分析任务的图算法和构建器集合。  </li>
</ul>
</li>
</ul>
<p>除了这些库以外，还有一些其他的库，如BlinkDB和Tachyon。  </p>
<ul>
<li><strong>BlinkDB:</strong><ul>
<li>BlinkDB是一个近似查询引擎，用于在海量数据上执行交互式SQL查询。BlinkDB可以通过牺牲数据精度来提升查询响应时间。通过在数据样本上执行查询并展示包含有意义的错误线注解的结果，操作大数据集合。  </li>
</ul>
</li>
<li><strong>Tachyon:</strong><ul>
<li>Tachyon是一个以内存为中心的分布式文件系统，能够提供内存级别速度的跨集群框架（如Spark和MapReduce）的可信文件共享。它将工作集文件缓存在内存中，从而避免到磁盘中加载需要经常读取的数据集。通过这一机制，不同的作业/查询和框架可以以内存级的速度访问缓存的文件。<br>此外，还有一些用于与其他产品集成的适配器，如Cassandra（Spark Cassandra 连接器）和R（SparkR）。Cassandra Connector可用于访问存储在Cassandra数据库中的数据并在这些数据上执行数据分析。</li>
</ul>
</li>
</ul>
<p>下图展示了在Spark生态系统中，这些不同的库之间的相互关联:  </p>
<p><img src="http://cdn4.infoqstatic.com/statics_s1_20161208-0302u1/resource/articles/apache-spark-introduction/zh/resources/0304081.png" alt="">  </p>
<p>本篇文章只进行Spark Streaming的介绍。  </p>
<h3 id="1-2Spark体系架构"><a href="#1-2Spark体系架构" class="headerlink" title="1.2Spark体系架构"></a>1.2Spark体系架构</h3><p>Spark体系架构包括如下三个主要组件:  </p>
<ul>
<li>1.数据存储。<ul>
<li>Spark用HDFS文件系统存储数据(这也就是我们在上问中提到为什么安装Spark要在安装Hadoop之后进行)。它可用于存储任何兼容于Hadoop的数据源，包括一些内置数据源如HDFS、TCP sockets和一些外置数据源如Twitter、Kafka等。</li>
</ul>
</li>
<li>2.API。<ul>
<li>利用API，应用开发者可以用标准的API接口创建基于Spark的应用。Spark提供Scala，Java和Python三种程序设计语言的API。</li>
</ul>
</li>
<li>3.资源管理。  <ul>
<li>Spark既可以部署在一个单独的服务器也可以部署在像Mesos或YARN这样的分布式计算框架之上。</li>
</ul>
</li>
</ul>
<p>如上对Spark进行了简单的介绍，接下来我们就基于Spark对其中的库Spark Streaming来进行介绍。</p>
<h2 id="2-Spark-Streaming的简单介绍"><a href="#2-Spark-Streaming的简单介绍" class="headerlink" title="2.Spark Streaming的简单介绍"></a>2.Spark Streaming的简单介绍</h2><p>上篇文章中的demo中我们对一个文件中的字数基于批处理模式下进行了静态信息处理，比如作为一个按小时或天运行的任务。但若是在数据驱动的业务决策场景下，当需要飞快地分析实时数据流以执行分析并创建决策支持时，又该如何呢？  </p>
<p>使用流式数据处理，一旦数据到达计算就会被实时完成，而非作为批处理任务。实时数据处理与分析正在变为大多数组织的大数据战略中至关重要的一个组件。接下来，我们将会学习到如何使用Apache Spark中一个被称为Spark流的库进行实时数据分析。  </p>
<h3 id="2-1流数据分析"><a href="#2-1流数据分析" class="headerlink" title="2.1流数据分析"></a>2.1流数据分析</h3><p>流数据基本上是一组连续的数据记录，它们通常产生于诸如传感器、服务器流量与在线搜索等数据源。常见的流数据的例子有网站上的用户行为、监控数据、服务器日志与其他事件数据。  </p>
<p>流数据处理应用会有助于现场面板、实时在线推荐与即时诈骗检测。<br>如果我们正在构建一个实时收集、处理与分析流数据的应用，我们需要按照与批处理数据应用不同的设计视角进行考虑。  </p>
<p>下面列出了三种不同的流数据处理框架：</p>
<ul>
<li>Apache Samza</li>
<li>Storm</li>
<li>Spark流<br>在本文中我们将专注于Spark流，即Spark Streaming。</li>
</ul>
<h3 id="2-2Spark流"><a href="#2-2Spark流" class="headerlink" title="2.2Spark流"></a>2.2Spark流</h3><p>Spark流是核心Spark API的扩展。Spark流使得基于实时数据流构建容错性处理变得更加简单。下图(就是上面介绍到的Spark生态系统图)展示了Spark流是如何融入到整个Apache Spark生态系统中:  </p>
<p><img src="http://cdn2.infoqstatic.com/statics_s1_20161208-0302u1/resource/articles/apache-spark-streaming/zh/resources/0000.png" alt="">  </p>
<p>Spark流工作的方式是将数据流按照预先定义的间隔(N秒)划分为批(称微批次)然后将每批数据视为一个弹性分布式数据集(Resilient Distributed Datasets，RDDs)。随后我们就可以使用诸如map、reduce、reduceByKey、join和window这样的操作来处理这些RDDs。这些RDD操作的结果会以批的形式返回。通常我们会将这些结果保存到数据存储中以供未来分析并生成报表与面板，或是发送基于事件的预警。  </p>
<p>为Spark流决定时间间隔是很重要的，这需要基于你的用例与数据处理要求。如果值N太低，那么在分析阶段微批次就没有足够的数据以给出有意义的结果。  </p>
<p>与Spark流相比，其他流处理框架是基于每个事件而非一个微批次来处理数据流的。用微批次的方法，我们可以在同一应用下使用Spark流API来应用其他Spark库(比如核心、机器学习等)。  </p>
<p>流数据可以来源于许多不同的数据源，一些内置数据源如HDFS、TCP sockets和一些外置数据源如Twitter、Kafka等。  </p>
<p>使用诸如Apache Spark这种大数据处理框架的另外一个优势就是我们可以在同一系统中组合批处理与流处理。我们也可以在数据流上应用Spark的机器学习与图处理算法，Spark流结构如下图所示:<br><img src="http://cdn2.infoqstatic.com/statics_s1_20161208-0302u1/resource/articles/apache-spark-streaming/zh/resources/0001.png" alt="">  </p>
<h3 id="2-3Spark流用例"><a href="#2-3Spark流用例" class="headerlink" title="2.3Spark流用例"></a>2.3Spark流用例</h3><p>Spark流正在变为实现实时数据处理与分析方案的首选平台，这些实时数据往往来源于物联网(Internet of Things，IoT)和传感器。它被用于各种用例与商业应用。下面是一些最有趣的Spark流用例:</p>
<ul>
<li>Uber:车驾共享服务背后的公司，在他们的持续流式ETL管道中使用了Spark流以每天从其移动用户处收集TB级的事件数据来进行实时遥测分析。</li>
<li>Pinterest:可视化书签工具背后的公司，使用Spark流、MemSQL与Apache Kafka技术以实时地深入了解他们全球的用户是怎样使用Pins的。</li>
<li>Netflix:使用Kafka与Spark流来构建一个实时在线电影推荐与数据监控解决方案，该方案每天要处理来自于不同数据源的数十亿条事件。</li>
</ul>
<p>Spark流其他现实世界的样例还包括:  </p>
<ul>
<li>供应链分析</li>
<li>实时安全情报操作以寻找威胁</li>
<li>广告竞价平台</li>
<li>实时视频分析，以帮助观看者实现个性化与互动体验</li>
</ul>
<h3 id="2-4Spark流架构与API"><a href="#2-4Spark流架构与API" class="headerlink" title="2.4Spark流架构与API"></a>2.4Spark流架构与API</h3><p>让我们看一下Spark流的架构与API方法。若要编写Spark流程序，我们需要知晓两个组件:DStream与流上下文。  </p>
<h4 id="2-4-1DStream"><a href="#2-4-1DStream" class="headerlink" title="2.4.1DStream"></a>2.4.1DStream</h4><p>Dstream(离散流，Discretized Stream，的缩写)是Spark流中最基本的抽象，它描述了一个持续的数据流。DStream既可以从诸如Kafka、Flume与Kinesis这样的数据源中创建，也可以对其他DStream实施操作。在内部，一个DStream被描述为一个RDD对象的序列。与RDDs上的转换与动作操作类似，DStream支持的操作有:map、flatMap、filter、count、reduce、countByValue、reduceByKey、join、updateStateByKey。</p>
<h4 id="2-4-2流上下文"><a href="#2-4-2流上下文" class="headerlink" title="2.4.2流上下文"></a>2.4.2流上下文</h4><p>与Spark中的Spark上下文(SparkContext)相似，流上下文(StreamingContext)是所有流功能的主入口。  </p>
<p>流上下文拥有内置方法可以将流数据接收到Spark流程序中。使用该上下文，我们可以创建一个描述基于TCP数据源的流数据的DStream，可以用主机名与端口号指定TCP数据源。比如，如果我们使用像netcat这样的工具来测试Spark流程序的话，我们将会从运行netcat的机器(比如localhost)的9999端口上接收到数据流。(下面的demo中我们以HDFS上的数据作为数据源)  </p>
<p>当代码被执行，在启动时，Spark流仅是设置将要执行的计算，此时还没有进行实时处理。在所有的转换都被设置完毕后，为了启动处理，我们最终会调用start()方法来启动计算，还有awaitTermination()方法来等待计算终结。</p>
<h4 id="2-4-3Spark流Api"><a href="#2-4-3Spark流Api" class="headerlink" title="2.4.3Spark流Api"></a>2.4.3Spark流Api</h4><p>由于我是搞java开发的，所以这里就只附上Spark提供的关于<a href="https://spark.apache.org/docs/1.3.0/api/java/index.html?org/apache/spark/sql/api/java/package-summary.html" target="_blank" rel="external">Java Api</a>的官方链接啦，小伙伴自行查看吧。  </p>
<h3 id="2-5Spark编程的步骤"><a href="#2-5Spark编程的步骤" class="headerlink" title="2.5Spark编程的步骤"></a>2.5Spark编程的步骤</h3><p>在展现出用demo应用之前，先来看看Spark流编程中与众不同的步骤:</p>
<ul>
<li>1.Spark流上下文被用于处理实时数据流。因此，第一步就是用两个参数初始化流上下文对象，Spark上下文和切片间隔时间。切片间隔设置了流中我们处理输入数据的更新窗口。一旦上下文被初始化，就无法再向已经存在的上下文中定义或添加新的计算。并且，在同一时间只有一个流上下文对象可以被激活。</li>
<li>2.当Spark流上下文被定义后，我们通过创建输入DStreams来指定输入数据源。在我们的样例应用中，输入数据源是一个使用了Apache Kafka分布式数据库和消息系统的日志消息生成器。日志生成器程序创建随机日志消息以模拟网络服务器的运行时环境，作为各种网络应用服务用户而产生的流量，日志消息被持续不断地生成。</li>
<li>3.使用map和reduce这样的Spark流变换API为DStreams定义计算。<br>当流计算逻辑被定义好后，我们可以使用先前创建的流上下文对象中的start方法来开始接收并处理数据。</li>
<li>4.最终，我们使用流上下文对象的awaitTermination方法等待流数据处理完毕并停止它。</li>
</ul>
<p>好了，上述讲了这么多大道理，你不烦我都烦了，接下来通过上述介绍的编程步骤直接附上我的demo吧。</p>
<h2 id="3-Spark处理流数据demo"><a href="#3-Spark处理流数据demo" class="headerlink" title="3.Spark处理流数据demo"></a>3.Spark处理流数据demo</h2><p>这里我们使用IDEA创建一个maven项目，在pom.xml文件中添加上Spark相关API jar包的坐标如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.codingxiaxw.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-mvn<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spark-mvn Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- Spark dependency --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>spark-mvn<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后创建一个WordCountStreaming.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.codingxiaxw.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.api.java.function.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.api.java.JavaDStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.api.java.JavaPairDStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.api.java.JavaReceiverInputDStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.api.java.JavaStreamingContext;</span><br><span class="line"><span class="keyword">import</span> scala.Tuple2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by codingBoy on 16/12/8.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorldCountStreaming</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建RDD</span></span><br><span class="line">        SparkConf sparkConf=<span class="keyword">new</span> SparkConf().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="string">"NetworkWorldCount"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         *</span><br><span class="line">         *</span><br><span class="line">         * 创建StreamingContext对象: 同Spark初始化需要创建SparkContext对象一样，</span><br><span class="line">         * 使用Spark Streaming就需要创建StreamingContext对象。创建StreamingContext对象所需的参数与SparkContext基本一致，</span><br><span class="line">         * 包括指明Master，设定名称(如NetworkWordCount)。需要注意的是参数Seconds(1)，Spark Streaming需要指定处理数据的时间间隔，</span><br><span class="line">         * 如上例所示的1s，那么Spark Streaming会以1s为时间窗口进行数据处理。此参数需要根据用户的需求和集群的处理能力进行适当的设置；</span><br><span class="line">         *</span><br><span class="line">         * 与Spark中的Spark上下文(SparkContext)相似，流上下文(StreamingContext)是所有流功能的主入口。</span><br><span class="line">         */</span></span><br><span class="line">        JavaStreamingContext jsc=<span class="keyword">new</span> JavaStreamingContext(sparkConf,Durations.seconds(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 创建InputDStream:如同Storm的Spout，Spark Streaming需要指明数据源。如上例所示的socketTextStream，Spark Streaming以</span><br><span class="line">         * socket连接作为数据源读取数据。当然Spark Streaming支持多种不同的数据源，包括Kafka、 Flume、HDFS/S3、Kinesis和Twitter</span><br><span class="line">         * 等数据源</span><br><span class="line">         */</span></span><br><span class="line">        JavaReceiverInputDStream&lt;String&gt; lines=jsc.socketTextStream(<span class="string">"localhost"</span>,<span class="number">8020</span>);</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        JavaReceiverInputDStream&lt;String&gt; lines= (JavaReceiverInputDStream&lt;String&gt;) jsc.textFileStream("hdfs://localhost:8020/directory");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 操作DStream:对于从数据源得到的DStream，用户可以在其基础上进行各种操作，</span><br><span class="line">         * 对于当前时间窗口内从数据源得到的数据首先进行分割，然后利用Map和ReduceByKey方法进行计算，当然最后还有使用print()方法输出结果；</span><br><span class="line">         */</span></span><br><span class="line">        JavaDStream&lt;String&gt; words=lines.flatMap(</span><br><span class="line">                <span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> Arrays.asList(s.split(<span class="string">" "</span>)).iterator();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 启动Spark Streaming之前所作的所有步骤只是创建了执行流程，程序没有真正连接上数据源，</span><br><span class="line">         * 也没有对数据进行任何操作，只是设定好了所有的执行计划，当ssc.start()启动后程序才真正进行所有预期的操作。</span><br><span class="line">         */</span></span><br><span class="line">        JavaPairDStream&lt;String,Integer&gt; pairs=words.mapToPair(</span><br><span class="line">                <span class="keyword">new</span> PairFunction&lt;String, String, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">call</span><span class="params">(String s)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(s,<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        JavaPairDStream&lt;String,Integer&gt; wordCounts=pairs.reduceByKey(</span><br><span class="line">                <span class="keyword">new</span> Function2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer integer, Integer integer2)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> integer+integer2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        wordCounts.print();</span><br><span class="line"></span><br><span class="line">        jsc.start();</span><br><span class="line">        jsc.awaitTermination();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过运行main函数实现Spark对流式数据的处理，代码中我们指定数据源为localhost上的文件(有疑惑？听我慢慢道来)，计算远程主机上某个文件内容的字数，发现控制台每隔1秒就输出如下图内容(即Spark每隔一秒就处理数据源的数据):<img src="http://od2xrf8gr.bkt.clouddn.com/streaming.gif" alt="">  </p>
<p>有人就有疑惑了，为什么控制台只输出了当前处理的时间而没有输出对数据源的操作信息(如这里我们是对数据源中的内容进行计数，为什么没有计数信息)呢?因为上述代码中我们没有指定正确的数据源，使用<code>JavaReceiverInputDStream&lt;String&gt; lines= (JavaReceiverInputDStream&lt;String&gt;) jsc.textFileStream(&quot;hdfs://localhost:8020/directory&quot;);</code>代替掉代码<code>JavaReceiverInputDStream&lt;String&gt; lines=jsc.socketTextStream(&quot;localhost&quot;,8020);</code>，括号中输入正确的数据源，这样就能实现实时监听数据源中变化的操作咯。至于数据源，你想用内置数据源，还是外置数据源就看你的实际需要咯！  </p>
<p>到此，我们便完成了如果通过Spark来处理流式数据的demo。   </p>
<p>参考:<a href="http://www.infoq.com/cn/articles/apache-spark-streaming" target="_blank" rel="external">用Apache Spark进行大数据处理——第三部分：Spark流</a></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[『 Spark 』mac下Spark的安装与使用]]></title>
      <url>http://codingxiaxw.cn/2016/12/07/60-mac-spark/</url>
      <content type="html"><![CDATA[<p>每次接触一个新的知识之前我都抱有恐惧之心，因为总认为自己没有接触到的知识都很高大上，比如上篇介绍到的<a href="http://codingxiaxw.cn/2016/12/06/59-mac-hadoop/">Hadoop的安装与使用</a>与本篇要介绍的Spark,其实在自己真正琢磨以后才发现本以为高大上的知识其实也不过如此。<a id="more"></a></p>
<p>由于Spark是最新火起来的处理大数据的框架，国内教程资源少之甚少，所以本篇文章是本人在看了<a href="http://spark.apache.org/docs/latest/quick-start.html" target="_blank" rel="external">Spark官网的快速入门</a>教程后总结下来的经验，由于Spark同Hadoop一样可以运行在多种模式下，而本人又比较穷只有一台电脑，所以本篇文章为大家介绍如何在mac系统的本地模式下安装Spark以及安装后如何用Spark来进行交互式分析。  </p>
<p>本文结构:前部分介绍Spark的一点点(详情介绍请自行google)基础概念以及安装过程，后部分通过一个demo让大家快速学会使用Spark基本Api。</p>
<h2 id="1-Spark的运行模式"><a href="#1-Spark的运行模式" class="headerlink" title="1.Spark的运行模式"></a>1.Spark的运行模式</h2><p>在正式安装Spark之前，先给大家介绍下Spark可以在哪几种模式下运行。同上篇<a href="http://codingxiaxw.cn/2016/12/06/59-mac-hadoop/">Hadoop的安装与使用</a>中介绍的Hadoop可以运行在其3种模式中的任意一种模式之上，Spark也可以运行在多种模式之上，主要有以下4种运行模式:  </p>
<ul>
<li>1.<code>local</code>: 本地单进程模式，用于本地开发测试Spark代码。</li>
<li>2.<code>standalone</code>:分布式集群模式，Master-Worker架构，Master负责调度，Worker负责具体Task的执行。</li>
<li>3.<code>on yarn/mesos</code>:运行在yarn/mesos等资源管理框架之上，yarn/mesos提供资源管理，spark提供计算调度，并可与其他计算框架(如MapReduce/MPI/Storm)共同运行在同一个集群之上。</li>
<li>4.<code>on cloud(EC2)</code>: 运行在AWS的EC2之上</li>
</ul>
<p>由于博主比较穷，所以下面为大家介绍本地模式下Spark的安装与使用。</p>
<h2 id="2-Spark的安装"><a href="#2-Spark的安装" class="headerlink" title="2.Spark的安装"></a>2.Spark的安装</h2><h3 id="2-1准备工作"><a href="#2-1准备工作" class="headerlink" title="2.1准备工作"></a>2.1准备工作</h3><p><strong>第一步:</strong>安装Java JDK 1.7及以上版本，并配置好环境变量。本电脑安装的jdk是1.7.0_79版本的。  </p>
<p><strong>第二步:</strong>安装Hadoop。本电脑安装的Hadoop是2.7.3版本的。</p>
<p><strong>疑惑:</strong>上篇文章说到可以不学Hadoop直接学习Spark，那为什么还要安装Hadoop?亲，我的意思是不用学习Hadoop的相关知识例如它的API啥的，但是没说不用先搭建Hadoop的环境呀！<br><strong>合理解释:</strong>Spark会用到HDFS与YARN，因此请先安装Hadoop，关于Hadoop的安装请参考我的上篇博文<a href="http://codingxiaxw.cn/2016/12/06/59-mac-hadoop/">mac下Hadoop的安装与使用</a>，在此就不再复述。  </p>
<p><strong>第三步:</strong>安装Scala 2.9.3以上版本。这里介绍下Scala在mac下的安装与环境变量的配置。点击链接进入<a href="http://www.scala-lang.org/download/" target="_blank" rel="external">scala官方网站</a>的下载页，下载2.11.8版本(第一次操作的时候我下载了最新版2.12.1，后来测试spark-shell命令时发现最新版本的scala与1.7版本的jdk不兼容，所以后来换成了2.11.8版本)的Scala:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-07%20%E4%B8%8B%E5%8D%883.27.59.png" alt="">  </p>
<p>点击图上下载链接会自动将scala下载到Dowmloads目录下，文件名为:<code>scala-2.12.1.tgz</code>，还有一种下载方法就是直接在命令行使用homebrew命令(作为一个Linux开发人员我建议使用这种方式)进行下载:<code>brew install scala</code>，该命令会自动帮你把scala下载到<code>/usr/local</code>目录下。使用在官网点击链接下载的方式的话，我们也要将该scala文件加到<code>/usr/local</code>目录下，你可以直接拷贝过去，当然作为一个Linux开发人员你可以直接使用一条命令完成将该压缩包进行<strong>解压</strong>并<strong>移动</strong>到<code>/usr/local/</code>目录下:<code>sudo tar -zxf ~/downloads/scala-2.12.1.tgz -C /usr/local/</code>，然后使用命令<code>cd /usr/local</code>进入到该目录下，由于解压后的文件名为:<code>scala-2.12.1</code>，所以为了之后配置的方便我们使用命令:<code>sudo mv ./scala-2.12.1 ./scala</code>将文件名修改为scala。因为该目录属于管理员级别的目录所以如果当前用户不是管理员的话应该在命令前面使用<code>sudo</code>关键字表示使用管理员权限。  </p>
<p>这样scala的安装便完成，但是还要配置scala的环境变量，使用命令:<code>sudo vim /etc/profile</code>打开系统中配置环境变量的文件，在里面添加如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SCALA_HOME=/usr/local/scala</span><br><span class="line">export PATH=$PATH:$SCALA_HOME/bin</span><br></pre></td></tr></table></figure></p>
<p>然后<code>:wq!</code>保存并退出该文件，输入命令使该文件的内容立刻生效:<code>source /etc/profile</code>，接下来在(根目录下)命令行输入:<code>scala</code>并敲击回车，看到控制台打印如下信息说明我们的scala安装并成功配置了环境变量:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-07%20%E4%B8%8B%E5%8D%884.50.39.png" alt="">  </p>
<p>图中信息即表明我们使用的scala版本为2.11.8，jdk版本为1.7.0_79。</p>
<p>使用命令行快捷键<code>control+c</code>或者<code>:quit</code>退出scala shell环境(网上教程有说使用exit命令可以退出scala shell环境，我试了但貌似不行)。</p>
<p><strong>疑惑:</strong>既然Spark提供了Scala、Python、Java三种程序设计语言的API，那么我直接用java不就好了，为什么还要下载Scala呢？是因为等会我们会使用Spark shell连接到Spark引擎进行交互式数据分析，而Spark shell只支持Scala和Python两种语言。Java不支持交互式的Shell，因此这一功能暂未在Java语言中实现(当然你也可以不使用shell编程，直接在IDE中用java编程语言连接到Spark引擎进行交互式数据分析也是可以的)。所以建议大家还是老老实实在电脑上面下载好scala并配置好环境变量，反正也占不了多大空间啊，而且万一哪天用到这东西了呢?所以下面我都是采用的scala支持的shell来配置的Spark，之后我也会使用scala运行spark-shell进行交互式数据分析的一个小示例带大家快速入门。</p>
<p>准备好如上环境后，接下来就可以进行Spark的安装与相关配置操作了。  </p>
<h3 id="2-2安装Spark并配置"><a href="#2-2安装Spark并配置" class="headerlink" title="2.2安装Spark并配置"></a>2.2安装Spark并配置</h3><p>接下来才是正题，进入<a href="http://spark.apache.org/downloads.html" target="_blank" rel="external">Apache Spark官方网站</a>进行Spark的下载，看到如下页面:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-07%20%E4%B8%8A%E5%8D%8811.33.53.png" alt="">  </p>
<p>第2条你要是选择的是Hadoop2.7的话，你要保证你之前安装的Hadoop版本也是2.7版本。选择第4条的下载链接即可(当然你也可以直接用Homebrew命令进行下载)，系统会将下好的文件放在Dowmloads文件目录下，文件名为:<code>spark-2.0.2-bin-hadoop2.7.tgz</code>，同scala的安装方法一样，我们使用命令:<code>sudo tar -zxf ~/Dowmloads/spark-2.0.2-bin-hadoop2.7.tgz -C /usr/local/</code>直接将该压缩包解压并移动到<code>/usr/local/</code>目录下，然后我们<code>cd /usr/local</code>进入到<code>/usr/local</code>目录下，使用命令更改该目录下的spark文件名:<code>sudo mv ./spark-2.0.2-bin-hadoop2.7 ./spark</code>将文件名改为<code>spark</code>。  </p>
<p>经过上述步骤从官网下载到Spark的文件，这样我们便完成了Spark的安装，但是Spark也是要进行相应的环境变量配置的，所以接下来我们进行Spark环境变量的配置。  </p>
<p>使用命令:<code>sudo vim /etc/profile</code>，在文件中加入Spark的环境变量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HOME=/usr/local/spark</span><br><span class="line">export PATH=$PATH:$SPARK_HOME/bin</span><br></pre></td></tr></table></figure></p>
<p>然后我们进入到Spark目录的conf配置文件中:<code>cd /usr/local/spark/conf</code>，执行命令:<code>cp spark-env.sh.template spark-env.sh</code>将spark-env.sh.template拷贝一份，然后打开拷贝后的spark-env.sh文件:<code>vim spark-env.sh</code>，在里面加入如下内容:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">export SCALA_HOME=/usr/local/scala</span><br><span class="line"></span><br><span class="line">export SPARK_MASTER_IP=localhost</span><br><span class="line"></span><br><span class="line">export SPARK_WORKER_MEMORY=4g</span><br></pre></td></tr></table></figure></p>
<p>这样我们便完成了Spark环境变量的配置，接下来测试测试一下Spark,在根目录(因为我们配置了spark环境变量，所以可以直接在根目录)下输入命令:<code>spark-shell</code>，看到控制台输出如下信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-07%20%E4%B8%8B%E5%8D%883.56.26.png" alt="">  </p>
<p>恭喜你，尽情享受Spark吧。</p>
<h2 id="3-安装过程出现的问题分析"><a href="#3-安装过程出现的问题分析" class="headerlink" title="3.安装过程出现的问题分析"></a>3.安装过程出现的问题分析</h2><p>1.运行<code>spark-shell</code>命令时控制台出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">..我忘了是啥报错了.connection out.中间报错信息是这个..</span><br></pre></td></tr></table></figure></p>
<p>的错误，说明没有配置SSH，配置SSH请参考我上篇文章中Hadoop安装的配置过程。</p>
<p>2.运行命令:<code>scala</code>时控制台出现:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-07%20%E4%B8%8B%E5%8D%883.59.58.png" alt="">  </p>
<p>的错误信息，表示scala没有成功安装，或者安装的scala与jdk不兼容，所以这里我建议你们就按本教程的2.11.8scala版本与1.7jdk版本来操作吧。这些坑我都试过了，所以才能为你们总结经验。(大哭脸)</p>
<p>3.其他错误，有以下原因，你们一定要一一进行检查:  </p>
<ul>
<li><p>1.关于JDK:JDK版本不对，所以我建议大家用1.7;或者是JDK版本正确但是没有成功配置它的环境变量，我配置时更改了两个文件的环境变量:一个是<code>/etc/profile</code>目录下的，一个是<code>.bash_profile</code>文件中的，配置环境变量信息如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.关于scala:Scala版本不对，所以我建议大家用2.11.8;或者是没有成功配置scala的环境变量，配置环境变量按照文中介绍的即可。</p>
</li>
<li>3.Hadoop版本与Spark版本不兼容:所以大家在Spark官网下载Spark的时候一定要注意下载Spark时选择的第二条信息的Hadoop版本要与电脑上面已经安装的Hadoop一致才行。</li>
</ul>
<h2 id="4-快速入门Spark基础Api"><a href="#4-快速入门Spark基础Api" class="headerlink" title="4.快速入门Spark基础Api"></a>4.快速入门Spark基础Api</h2><p>这里我介绍两种使用Spark基础Api的方式，一种是在spark-shell中进行简单的测试，一种是在开发工具IDEA中进行代码的编写来教大家快速学习Spark基础API。  </p>
<h3 id="4-1使用spark-shell完成单词统计功能"><a href="#4-1使用spark-shell完成单词统计功能" class="headerlink" title="4.1使用spark-shell完成单词统计功能"></a>4.1使用spark-shell完成单词统计功能</h3><p>由于spark-shell只支持scala和python两种语言的编写，不支持Java，所以我在spark-shell中通过scala的语法来进行简单测试。  </p>
<p>在配置好Spark环境变量之后，我们打开命令行，直接在当前用户目录下输入命令<code>spark-shell</code>进入scala编写环境(当然前提是你首先使用命令<code>start-all.sh</code>命令开启了Spark):<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-10%20%E4%B8%8B%E5%8D%882.11.20.png" alt="">  </p>
<p>我们从 <code>/usr/local/spark/README.md</code> 文件新建一个 RDD，代码如下（本文出现的 Spark 交互式命令代码中，第一行为代码及其解释，第二行及以后是控制台返回的结果):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; val textFile = sc.textFile(&quot;file:///usr/local/spark/README.md&quot;)</span><br><span class="line">&gt;textFile: org.apache.spark.rdd.RDD[String] = file:///usr/local/spark/README.md MapPartitionsRDD[1] at textFile at &lt;console&gt;:24</span><br></pre></td></tr></table></figure></p>
<p>代码中通过 <code>file://</code> 前缀或者不加 <code>file://</code> 前缀表示指定读取本地文件。如果你这里传入的路径写的是HDFS上的文件路径，例如<code>hdfs://远程主机名:Hadoop端口号我/文件名</code>代表你要是读取的是 HDFS 中的文件，你需要先上传文件到 HDFS 中(至于如何上传，后面的demo中我们会进行讲解)，否则会有<code>org.apache.hadoop.mapred.InvalidInputException: Input path does not exist: hdfs://localhost:9000/user/hadoop/README.md</code>的错误。这里我们就以读取本地文件进行讲解。  </p>
<p>RDDs 支持两种类型的操作:1.actions: 在数据集上运行计算后返回值。2.transformations: 转换, 从现有数据集上创建一个新的数据集。  </p>
<p>使用上述命令创建好的RDD对象,下面我们就来通过该对象演示 count() 和 first() 操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">textFile.count()  // RDD 中的 item 数量，对于文本文件，就是总行数</span><br><span class="line">&gt;res0: Long = 95</span><br><span class="line"> </span><br><span class="line">textFile.first() // RDD 中的第一个 item，对于文本文件，就是第一行内容</span><br><span class="line">&gt;res1: String = # Apache Spark</span><br></pre></td></tr></table></figure></p>
<p>接着演示 transformation，通过 filter transformation 来返回一个新的 RDD，代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val linesWithSpark = textFile.filter(line =&gt; line.contains(&quot;Spark&quot;))   // 筛选出包含 Spark 的行</span><br><span class="line">&gt;linesWithSpark: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[2] at filter at &lt;console&gt;:26</span><br><span class="line"> </span><br><span class="line">linesWithSpark.count()       // 统计行数</span><br><span class="line">&gt;res4: Long = 17</span><br></pre></td></tr></table></figure></p>
<p>上述我们完成了RDD的简单计算，而RDD 的 actions 和 transformations 其实可用在更复杂的计算中，例如通过如下代码可以找到包含单词最多的那一行内容共有几个单词:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">textFile.map(line =&gt; line.split(&quot; &quot;).size).reduce((a, b) =&gt; if (a &gt; b) a else b)</span><br><span class="line">&gt;res1: Int = 22</span><br></pre></td></tr></table></figure></p>
<p>代码首先将每一行内容 map 为一个整数，这将创建一个新的 RDD，并在这个 RDD 中执行 reduce 操作，找到最大的数。map()、reduce() 中的参数是 Scala 的函数字面量（function literals，也称为闭包 closures），并且可以使用语言特征或 Scala/Java 的库。例如，通过使用 Math.max() 函数（需要导入 Java 的 Math 库），可以使上述代码更容易理解:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java.lang.Math //先导入Math函数</span><br><span class="line"> </span><br><span class="line">textFile.map(line =&gt; line.split(&quot; &quot;).size).reduce((a, b) =&gt; Math.max(a, b))</span><br><span class="line">&gt;res6: Int = 14</span><br></pre></td></tr></table></figure></p>
<p>Hadoop MapReduce 是常见的数据流模式，在 Spark 中同样可以实现（下面这个例子也就是 WordCount）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val wordCounts = textFile.flatMap(line =&gt; line.split(&quot; &quot;)).map(word =&gt; (word, 1)).reduceByKey((a, b) =&gt; a + b)   // 实现单词统计</span><br><span class="line">&gt;wordCounts: org.apache.spark.rdd.RDD[(String, Int)] = ShuffledRDD[4] at reduceByKey at &lt;console&gt;:29</span><br><span class="line"> </span><br><span class="line">wordCounts.collect()    // 输出单词统计结果</span><br><span class="line">&gt;res7: Array[(String, Int)] = Array((package,1), (For,2), (Programs,1), (processing.,1), (Because,1), (The,1)...)</span><br></pre></td></tr></table></figure></p>
<p>上述我们通过spark-shell完成单词的统计简单对我们spark的基础Api进行了熟悉，采用的是scala语言，由于我是一个java开发人员，所以接下来就在开发工具IDEA中通过编写Java代码来实现HDFS中某个路径下文件内容中单词的统计功能。</p>
<h3 id="4-2在IDEA中编写Java代码完成HDFS中某个文件中的单词统计功能"><a href="#4-2在IDEA中编写Java代码完成HDFS中某个文件中的单词统计功能" class="headerlink" title="4.2在IDEA中编写Java代码完成HDFS中某个文件中的单词统计功能"></a>4.2在IDEA中编写Java代码完成HDFS中某个文件中的单词统计功能</h3><p>既然要统计HDFS中某个文件中的单词，那么我们首先要将文件上传到HDFS上吧！如何上传?听我慢慢道来。  </p>
<p>使用命令<code>:quit</code>退出scala命令环境，首先在本地电脑的当前用户目录下创建一个文件，我这里创建了一个叫hello的txt文件，里面写上内容<code>hello world hello you  hello  hello 
，内容可以随便打啦</code>，然后输入hadoop的命令(关于Hadoop的更多命令请自行google):<code>hadoop fs -put ~/hello /</code>，实现将本机目录下的hello文件推至远程主机的根目录下，然后便可以开始编写我们的java代码了。  </p>
<p>使用IDEA创建一个Maven项目(便于管理我们的jar包嘛！)，在pom.xml中添加上Spark相应jar包坐标:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.codingxiaxw.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-mvn<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>spark-mvn Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> <span class="comment">&lt;!-- Spark dependency --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.11<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>spark-mvn<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后创建一个WordCount.java文件，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Simple</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern SPACE = Pattern.compile(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        if (args.length &lt; 1) &#123;</span></span><br><span class="line"><span class="comment">//            System.err.println("Usage: JavaWordCount &lt;file&gt;");</span></span><br><span class="line"><span class="comment">//            System.exit(1);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个RDD对象</span></span><br><span class="line">        SparkConf conf=<span class="keyword">new</span> SparkConf().setAppName(<span class="string">"Simple"</span>).setMaster(<span class="string">"local"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建spark上下文对象，是数据的入口</span></span><br><span class="line">        JavaSparkContext spark=<span class="keyword">new</span> JavaSparkContext(conf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取数据源</span></span><br><span class="line">        JavaRDD&lt;String&gt; lines = spark.textFile(<span class="string">"hdfs://localhost:8020/hello"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 对于从数据源得到的DStream，用户可以在其基础上进行各种操作，</span><br><span class="line">         * 对于当前时间窗口内从数据源得到的数据首先进行分割，</span><br><span class="line">         * 然后利用Map和ReduceByKey方法进行计算，当然最后还有使用print()方法输出结果；</span><br><span class="line">         */</span></span><br><span class="line">        JavaRDD&lt;String&gt; words = lines.flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Iterator&lt;String&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Arrays.asList(SPACE.split(s)).iterator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用RDD的map和reduce方法进行计算</span></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; ones = words.mapToPair(</span><br><span class="line">                <span class="keyword">new</span> PairFunction&lt;String, String, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Tuple2&lt;String, Integer&gt; <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">new</span> Tuple2&lt;&gt;(s, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        JavaPairRDD&lt;String, Integer&gt; counts = ones.reduceByKey(</span><br><span class="line">                <span class="keyword">new</span> Function2&lt;Integer, Integer, Integer&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> i1 + i2;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;Tuple2&lt;String, Integer&gt;&gt; output = counts.collect();</span><br><span class="line">        <span class="keyword">for</span> (Tuple2&lt;?,?&gt; tuple : output) &#123;</span><br><span class="line">            <span class="comment">//输出计算结果</span></span><br><span class="line">            System.out.println(tuple._1() + <span class="string">": "</span> + tuple._2());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        spark.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>各行代码意思见代码旁的注释，上述代码都是从官方文档抄的，但是貌似要注释掉官方文档的:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//        if (args.length &lt; 1) &#123;</span></span><br><span class="line"><span class="comment">//            System.err.println("Usage: JavaWordCount &lt;file&gt;");</span></span><br><span class="line"><span class="comment">//            System.exit(1);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>然后运行程序，控制台输出结果如下图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-10%20%E4%B8%8B%E5%8D%882.42.45.png" alt=""></p>
<p>成功统计出HDFS上文件内容的单词个数。到此，我们便简单熟悉了Spark的相关API，下篇文章我将介绍通过Spark的<a href="http://codingxiaxw.cn/2016/12/10/61-spark-streaming/">Streaming Api实现对流式数据的处理</a>为大家介绍Spark中Streming库的相关Api操作。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="5-联系"><a href="#5-联系" class="headerlink" title="5.联系"></a>5.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[『 Hadoop 』mac下Hadoop的安装与使用]]></title>
      <url>http://codingxiaxw.cn/2016/12/06/59-mac-hadoop/</url>
      <content type="html"><![CDATA[<p>最近接触大数据，所以当然有必要学习下Hadoop和Spark(概念请自行百google或者百度)。Spark是Apache目前最火的一款快速处理大数据的开源框架，当然Hadoop也是一款处理大数据的框架，只是Sparck青出于蓝而胜于蓝，在出生之后就得到迅猛发展，所以有学者说日后Spark可能会将Hadoop淘汰(不是我说的，是学者说的哦)。<a id="more"></a>  </p>
<p>至于Hadoop与Spark的关系，就像是svn与git的关系，后者都是较前者后几年出来且火于前者的一款工具。那么学习大数据的处理框架时就会有很多人有这样一个疑惑:既然Hadoop是先于Spark出来的，那么我要不要先学习Hadoop呢，还是跳过Hadoop直接从Spark学习起?  </p>
<p>这样我们先看看git与svn的关系，svn是早于git好些年出生的版本控制工具，虽然二者性质都一样，但是学习git不一定要有svn的知识，所以Hadoop与Spark的关系也是这样，直接跳过Hadoop从Spark开始学习就好。我也是直接从Spark开始学起的，由于是新手，所以在前方给大家探路打算先学习一下Hadoop的搭建然后再去学习Spark相关技术，等学完后再来对本篇文章进行改正。关于Hadoop的概念介绍大家可以直接google或者百度，本篇文章只介绍mac环境下Hadoop的安装与使用(伪分布式Hadoop)。</p>
<p><strong>这段话是我学习Spark后再来更新的:</strong>针对上述的疑惑，我现在可以直接告诉大家:学习大数据处理框架可以跳过Hadoop的学习直接从Spark学，但是你在搭建Spark环境的之前还非得先搭建Hadoop环境，因为下篇文章中介绍的安装Spark时会讲搭建Spark的环境是依赖于该Hadoop的，所以总的来说就是:Hadoop的各种API知识啥的不用学，但是在搭建Spark前你还非得先搭建Hadoop的环境。所以大家还是规规矩矩按照本篇文章的介绍老老实实的先搭建好Hadoop的环境吧,good luck!</p>
<h2 id="1-安装Homebrew与Cask"><a href="#1-安装Homebrew与Cask" class="headerlink" title="1.安装Homebrew与Cask"></a>1.安装Homebrew与Cask</h2><p>关于Homebrew的一些命令我在这篇文章的<code>Homeberw段落</code>中有详细介绍<a href="http://codingxiaxw.cn/2016/12/02/58-mac-commands/">mac下常用软件相关命令</a>,当然本篇文章也会基于本篇文章的目的进行专一性的命令介绍。  </p>
<p>打开Mac终端，安装OS X 不可或缺的套件管理器homebrew和homebrew cask:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure></p>
<p>执行过程需要输入root命令，当控制台出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">==&gt; Installation successful!</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p>
<p>恭喜你，成功安装homebrew。接下来安装homebrew cask,在终端输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ brew install caskroom/cask/brew-cask</span><br></pre></td></tr></table></figure></p>
<p>根据提示进行安装。  </p>
<h2 id="2-安装Java"><a href="#2-安装Java" class="headerlink" title="2.安装Java"></a>2.安装Java</h2><p>这一步搞java开发的人请自行跳过，因为我相信你们早就已经成功的安装了java(其实mac系统已自动为我们集成)并成功配置了环境变量。我电脑上安装的JDK版本为1.7.0_79，并完成环境变量的配置。  </p>
<h2 id="3-配置SSH"><a href="#3-配置SSH" class="headerlink" title="3.配置SSH"></a>3.配置SSH</h2><p>为了确保在远程管理Hadoop以及Hadoop节点用户共享时的安全性, Hadoop需要配置使用SSH协议。  </p>
<p>首先在系统偏好设置-&gt;共享-&gt;打开远程登录服务-&gt;右侧选择允许所有用户访问。  </p>
<p>首先在终端输入:<code>ssh localhost</code>，如果终端有返回<code>Last login: Tue Dec 6 11:47:39 2016 from ::1</code>，说明你之前成功配置了SSH keys,如果没有返回该内容，请按下述步骤新建一个配置:</p>
<p>在终端输入:<code>$ ssh-keygen -t rsa</code>  </p>
<p>执行上述命令会在当前用户目录下的.ssh文件夹(是一个隐藏文件)中生成一个id_rsa文件, 然后继续执行如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>用于授权你的公钥到本地可以避免每次登陆时都要询问你的密码,再次输入<code>ssh localhost</code>若返回<code>Last login: Tue Dec  6 11:47:39 2016 from ::1</code>，恭喜你，成功完成ssh的配置。</p>
<h2 id="4-安装Hodoop"><a href="#4-安装Hodoop" class="headerlink" title="4.安装Hodoop"></a>4.安装Hodoop</h2><p>之前的三步骤都是安装Hadoop前的准备，有了前期的准备，安装Hadoop也简单了，执行命令<code>brew install hadoop</code>，等待系统安装，完成后Hadoop会被安装到<code>/usr/local/Cellar/hadoop</code>下。然后需要进行如下配置才能算成功安装Hadoop。  </p>
<h3 id="4-1配置Hadoop"><a href="#4-1配置Hadoop" class="headerlink" title="4.1配置Hadoop"></a>4.1配置Hadoop</h3><p>1.首先更改Hadoop的配置文件信息，找到<code>usr/local/Cellar/hadoop/2.7.3/libexec/etc/hadoop</code>目录下，打开<code>hadoop-env.sh</code>文件，找到其中一行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true&quot;</span><br></pre></td></tr></table></figure></p>
<p>将其修改为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_OPTS=&quot;$HADOOP_OPTS -Djava.net.preferIPv4Stack=true -Djava.security.krb5.realm= -Djava.security.krb5.kdc=&quot;</span><br><span class="line">export JAVA_HOME=&quot;/Library/Java/JavaVirtualMachines/jdk1.7.0_79.jdk/Contents/Home&quot; #改为自己JDK目录</span><br></pre></td></tr></table></figure></p>
<p>2.然后要配置hdfs的地址和端口号，在<code>usr/local/Cellar/hadoop/2.7.3/libexec/etc/hadoop</code>目录下，打开<code>core-site.xml</code>，会发现<code>core-site.xml</code>文件中的<code>&lt;configuration&gt;&lt;/configuration&gt;</code>标签中间的内容为空，需要我们自己加入如下配置信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Put site-specific property overrides in this file. --&gt;</span><br><span class="line"> &lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">     &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;</span><br><span class="line">&lt;value&gt;/usr/local/Cellar/hadoop/hdfs/tmp&lt;/value&gt;</span><br><span class="line">    &lt;description&gt;A base for other temporary directories.&lt;/description&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">     &lt;name&gt;fs.default.name&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;hdfs://localhost:8020&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>3.再然后就是设置map-reduce中jobtracker的地址和端口号，在目录<code>usr/local/Cellar/hadoop/2.7.3/libexec/etc/hadoop</code>下，找到<code>mapred-site.xml</code>文件，在其内加上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">      &lt;property&gt;</span><br><span class="line">        &lt;name&gt;mapred.job.tracker&lt;/name&gt;</span><br><span class="line">        &lt;value&gt;localhost:8021&lt;/value&gt;</span><br><span class="line">      &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>4.最后要设置hdfs的默认备份方式，默认值是3，在伪分布式系统中，需要修改为1。在目录<code>usr/local/Cellar/hadoop/2.7.3/libexec/etc/hadoop</code>下，找到<code>hdfs-site.xml</code>文件，在其内加上:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">   &lt;property&gt;</span><br><span class="line">     &lt;name&gt;dfs.replication&lt;/name&gt;</span><br><span class="line">     &lt;value&gt;1&lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>5.在运行后台程序前, 必须格式化新安装的HDFS, 并通过创建存储目录和初始化元数据创新空的文件系统, (在上述目录下)执行命令:<code>hdfs namenode -format</code>  </p>
<p>在控制台出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#生成类似下面的字符串:</span><br><span class="line">...</span><br><span class="line">#此处省略大部分信息</span><br><span class="line">STARTUP_MSG:   java = 1.7.0_79</span><br><span class="line">************************************************************</span><br><span class="line">/************************************************************</span><br><span class="line">SHUTDOWN_MSG: Shutting down NameNode at Andrew-liudeMacBook-Pro.local/192.168.1.100</span><br><span class="line">************************************************************/</span><br></pre></td></tr></table></figure></p>
<p>这样我们便完成Hadoop的配置，可以启动Hadoop了。  </p>
<h3 id="4-2启动后台程序"><a href="#4-2启动后台程序" class="headerlink" title="4.2启动后台程序"></a>4.2启动后台程序</h3><p>在<code>/usr/local/Cellar/hadoop/2.7.3/sbin</code>目录下执行如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start-dfs.sh            //启动HDFS</span><br><span class="line">./stop-dfs.sh           //停止HDFS</span><br></pre></td></tr></table></figure></p>
<p>执行启动/关闭HDFS的命令，控制台输出信息如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Starting namenodes on [localhost]</span><br><span class="line">localhost: starting namenode, logging to /usr/local/Cellar/hadoop/2.7.3/libexec/logs/hadoop-tony-namenode-tonys-MacBook-Pro-2.local.out</span><br><span class="line">localhost: starting datanode, logging to /usr/local/Cellar/hadoop/2.7.3/libexec/logs/hadoop-tony-datanode-tonys-MacBook-Pro-2.local.out</span><br><span class="line">Starting secondary namenodes [0.0.0.0]</span><br></pre></td></tr></table></figure></p>
<p>说明成功启动本地服务，此时在浏览器中打开Resource Manager输入如下网址:<code>http://localhost:50070</code>(被读者私信说hadoop3版本以上的端口从50070移到9870了，望注意～)可以看到Hadoop的页面<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-06%20%E4%B8%8B%E5%8D%882.11.28.png" alt="">  </p>
<p>还可以继续在命令行中(依旧在<code>/usr/local/Cellar/hadoop/2.7.3/sbin</code>目录下)执行如下启动/关闭脚本命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start-yarn.sh        //启动yarn，一个MapReduce框架</span><br><span class="line">./stop-yarn.sh        //停止yarn</span><br></pre></td></tr></table></figure></p>
<p>此时在浏览器中打开JobTracker: <code>http://localhost:8088</code>、Specific Node Information: <code>http://localhost:8042</code>可以分别看到如下界面:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-06%20%E4%B8%8B%E5%8D%882.16.05.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-06%20%E4%B8%8B%E5%8D%882.16.19.png" alt="">  </p>
<p>或者直接运行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start-all.sh    ##启动Hadoop </span><br><span class="line">./stop-all.sh     ##停止Hadoop</span><br></pre></td></tr></table></figure></p>
<p>该命令可以同时开启/关闭上述三个本地服务。</p>
<p>但是每次执行上述命令都必须要进入到<code>/usr/local/Cellar/hadoop/2.7.3/sbin</code>目录，为了方便所以我们需要进行Hadoop环境变量配置。使用命令:<code>sudo vim /etc/profile</code>，在其中加入Hadoop环境变量的配置信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/usr/local/Cellar/hadoop/2.7.3  #你Hadoop的安装路径</span><br><span class="line">export PATH=$PATH:$HADOOP_HOME/sbin:$HADOOP_HOME/bin</span><br></pre></td></tr></table></figure></p>
<p>然后输入命令:<code>source /etc/profile</code>使该文件生效，这样以后你就可以在用户目录下直接使用上述<code>start-dfs.sh</code>命令来启动Hadoop了。  </p>
<p>到此，尽情享受Hadoop吧。最后我来个Hadoop的小结。  </p>
<h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h2><p>Hadoop是Apache基金会下的项目，它能够处理非常大的数据集在分布式计算环境，它可以运行在三种模式下:  </p>
<ul>
<li>1.独立式:Hadoop运行所有的东西在无后台的单独的JVM中，这种模式适合在开发阶段测试与Debug MapReduce程序。</li>
<li>2.伪分布式:Hadoop做为后台应用运行在本地机器，模拟小集群。</li>
<li>3.全分布式:Hadoop做为后台应用运行真实的集群电脑中。</li>
</ul>
<p>因为本人只有一台电脑，所以本篇文章介绍的就是在伪分布式模式下进行的Hadoop的安装介绍。到这里，你可能会有疑惑:独立式、伪分布式、全分布式三种模式又有什么区别呢? 呃…自行google吧，或者点击我已经给你找好的资料链接<a href="http://www.aboutyun.com/thread-6839-1-1.html" target="_blank" rel="external">hadoop的单机、伪分布式、分布式区别</a>，不要太爱我，因为我已经有人爱了。  </p>
<p><strong>疑惑:</strong><br>很多人问我，在自己电脑上搭建好Hadoop环境以后，下一步该怎么利用Hadoop呢？亲，搭建好Hadoop后当然就可以利用Hadoop相关类对大数据进行处理了撒！  </p>
<p>如何利用Hadoop相关类?首先你得有一款能写Hadoop代码的工具吧(当然你要是想装X的话也可以跳过IDE直接通过命令行编写Hadoop相关类操作)！我这里用的eclipse(别问我为什么我还没转IDEA,我是从IDEA转过来的好嘛。。。虽然我不情愿。。。大哭)，所以就可以在eclipse中通过编写Hadoop的相关类，然后就能对大数据进行处理咯。例子可以进Apache Hadoop官网，里面有很多简单的Examples让你快速入门Hadoop编程哦(由于我赞成大家直接学习Spark，所以就不给学习Hadoop相关知识的资料链接给大家咯)。  </p>
<p>当然我本意是要学习Spark的，然而由于是新手，等好不容易在电脑上搭建完Hadoop，才知道如今学习Spark的话是得重新在电脑上搭建Spark环境的(<strong>括号内容是我学习Spark后又跑过来更的:</strong>废话！使用Spark前不搭建Spark的话那如何使用Spark?所以肯定要先搭建Spark环境了才能使用Spark啊)。。。由于下篇讲mac环境下Spark的搭建的文章<a href="http://codingxiaxw.cn/2016/12/07/60-mac-spark/">how to install Spark on Mac</a>时需要我们先搭建Hadoop的环境(为什么？点击链接看下篇文章是如何介绍的吧)，所以还是规规矩矩的按照本教程先完成Hadoop的搭建吧!</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mac下常用软件相关命令(持续更新)]]></title>
      <url>http://codingxiaxw.cn/2016/12/02/58-mac-commands/</url>
      <content type="html"><![CDATA[<p>因为mac上的很多功能都涉及到命令行的工作，然而记性差的我总是一次熟两次生，第三次就要…google，所以下面总结下自己在使用自己电脑上相关软件时涉及到的一些命令，以供自己日后参考。<a id="more"></a></p>
<p>也只是介绍了一些常用开发软件的常用命令，还有很多命令由于在其他文章中都有介绍到所以我在此篇文章中就没有列举出来。  </p>
<h2 id="hexo篇"><a href="#hexo篇" class="headerlink" title="hexo篇"></a>hexo篇</h2><!--很多人在Contact列表问我我的博客很怎样搭建的，很多朋友说很炫酷，还有朋友问我是不是自己写的。我想告诉大家的是，我目前只是从事Java开发人员中的一只咸鱼，这么炫酷的博客我肯定是写不出来的啦！所以现在统一回复那些志同道合但是还没有接触过hexo这块的朋友们，百度或者goole"如何用hexo在github上搭建博客"，很快你们就会拥有像我这样炫酷的博客。然后再搜一下"hexo 主题"，大把博客主题让你选。(不要太爱我)当然你要是喜欢我的主题，直接[点击这里](https://github.com/codingXiaxw/codingXiaxw.github)进入我github上fork我博客的相关文件codingXiaxw.github.io，然后更改相关配置就成为你的博客配置咯。-->  
<!--(有多少人是因为看了我这篇文章后跟我这里介绍的hexo搭建的博客，来来来下方评论让我看到你的双手)-->
<p>总结一下自己在使用hexo时使用到的也是最常用的一些命令啦(因为其他的根本不怎么用…)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo clean或者是hexo c  //清除缓存</span><br><span class="line"></span><br><span class="line">hexo server或者是hexo s //将博客在本地服务器上部署</span><br><span class="line"></span><br><span class="line">hexo generator或者是hexo g  //将本地博客相关配置打包成一个public目录</span><br><span class="line"></span><br><span class="line">hexo deploy或者是hexo h  //将本地博客部署到远程github上</span><br><span class="line"></span><br><span class="line">hexo new &apos;文章名称&apos;   //创建一个新文章</span><br></pre></td></tr></table></figure></p>
<p>讲真，掌握好这四条命令就够了。当然走在进阶道路上的伙伴们请自行跳过本篇。</p>
<p>查看github服务器IP地址:<code>ping yourname.github.io</code>  </p>
<h2 id="工作篇"><a href="#工作篇" class="headerlink" title="工作篇"></a>工作篇</h2><p>需求：使用webstorm进行nodejs开发过程中，修改代码后组长让我把改动的代码打patch发他。</p>
<p>步骤：</p>
<ul>
<li>1.<code>git add 改动的文件路径</code></li>
<li>2.<code>git commit -m &quot;动作: FXD-序号 message&quot;</code>；</li>
<li>3.<code>git log</code>，查看commit的日志。</li>
<li>4.复制需要打patch的commit序列号，然后按q健退出编辑界面</li>
<li>5.<code>git format-patch -1 步骤4复制的序列号</code></li>
<li>6.会在项目根目录下生成相应的patch文件。</li>
</ul>
<p>对于<code>git format-patch</code>命令中相关参数说明：</p>
<ul>
<li>1.<code>git format-patch commit序列号</code>：打出从该commit以来修改过的patch（不包含该commit）。</li>
<li>2.<code>git format-patch commit序列号1 commit序列号2</code>：打出两次commit之间修改过的patch。(包含这两个commit。</li>
<li>3.上面那种，就是打出指定commit的patch。</li>
</ul>
<p>住：其实上述命令用webstorm工具可以直接打patch。</p>
<h2 id="maven篇"><a href="#maven篇" class="headerlink" title="maven篇"></a>maven篇</h2><p>cd到一个有pom.xml文件的项目中，执行:  </p>
<ul>
<li><code>mvn install</code>:可以将1.pom.xml中涉及的jar包都下载到maven的仓库中;2.将jar包下载到当前文件目录下。</li>
<li><code>mvn clean package</code>:可以将pom.xml中涉及的jar包都下载到当前目录的jar包中。</li>
</ul>
<h2 id="gulp篇"><a href="#gulp篇" class="headerlink" title="gulp篇"></a>gulp篇</h2><p>gulp和grunt的比较。<br>gulp的四个api：</p>
<ul>
<li>gulp.task(“name”,fn);</li>
<li>gulp.watch();</li>
<li>gulp.src();</li>
<li>gulp.dest();</li>
</ul>
<p>这些命令都写在gulpfile.js文件中。在命令行中执行: <code>gulp name</code>，即可执行gulpfile文件中对应taskname的任务。</p>
<h2 id="make篇"><a href="#make篇" class="headerlink" title="make篇"></a>make篇</h2><p><a href="http://www.ruanyifeng.com/blog/2015/02/make.html" target="_blank" rel="external">参考</a></p>
<p>常用构建工具命令，构建规则都写在makefile文件中。makefile由一系列规则构成，每条规则形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target&gt; : &lt;prerequisites&gt; </span><br><span class="line">[tab]  &lt;commands&gt;</span><br></pre></td></tr></table></figure>
<p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p>
<p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p>
<p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。</p>
<p>在命令行中输入:<code>make target</code>，即可执行makefile文件中对应的目标名为target的规则后面的commands命令。</p>
<h2 id="github篇"><a href="#github篇" class="headerlink" title="github篇"></a>github篇</h2><p>github大法好啊，上面有各种开源项目供你下载供你使用。我当然要跟上潮流啊，所以我去年3月份也注册了个账号，然后开始将自己的项目源码都推到上面供那些需要项目源码的朋友学习，另一方面自己也经常在上面搜索流行开源项目进行学习。  </p>
<p>首先在github上创建一个repository，然后进去该repository，复制仓库地址，在本地命令行中执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 仓库地址    //表示将github上的仓库拷贝到本地</span><br></pre></td></tr></table></figure></p>
<p>然后这时你就会在根目录下看到一个跟该仓库名一样的文件夹,将本地项目的源码拷贝到这个文件夹下，在命令行中依次执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add .       //表示将拷贝的该目录中的所有文件本地一个叫staging area的暂存区</span><br><span class="line"></span><br><span class="line">git add 新添加的文件名  //有时候我们不需要将已经在github上的文件重新推至github而只需将新添加进该仓库的文件推至github，所以就要使用这个命令</span><br><span class="line"></span><br><span class="line">git commit -m &quot;说明&quot;  //git commit 执行将add到staging area中的文件提交到本地仓库，后面的说明是对此次commit的说明。</span><br><span class="line"></span><br><span class="line">git push origin master  //将本地仓库的文件推至对应的远程(remote)仓库，git push的两个参数:origin代表远端仓库的名字，master代表分支的名字</span><br></pre></td></tr></table></figure></p>
<p>参考下图 git 中各项操作对应的结果:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-27%20%E4%B8%8B%E5%8D%883.58.16.png" alt=""></p>
<p>这里讲讲另外一种将本地项目推至github上的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建本地仓库: mkdir test  然后cd test 进入到此仓库中</span><br><span class="line">2.初始化这个仓库: git init </span><br><span class="line">3.添加需要上传到github上的文件，然后加入暂存区: git add .</span><br><span class="line">4.推至本地仓库: git commit -m &quot;&quot;</span><br><span class="line">5.与远程仓库进行连接: git remote add origin 远程仓库地址</span><br><span class="line">6.推送至远程仓库: git push (-u) origin master</span><br></pre></td></tr></table></figure></p>
<p>其中涉及一些常用git命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.git status  查看本地库的当前状态</span><br><span class="line">2.git branch  在与远程仓库建立连接后使用该命令查看远程仓库当前分支</span><br><span class="line">3.git branch 分支名;  在远程仓库中创建新分支</span><br><span class="line">4.git checkout;  查看分支状态</span><br><span class="line">5.git checkout 分支名；切换到该分支下</span><br><span class="line">6.git merge 分支名； 将该分支与当前分支合并。</span><br><span class="line">7.git clone -b 分支名 地址；拷贝对应分支名的仓库</span><br></pre></td></tr></table></figure></p>
<p>具体git命令参考这片文章:<a href="https://www.w3ctrain.com/2016/06/26/learn-git-in-30-minutes/" target="_blank" rel="external">git 从入门到放弃</a></p>
<h2 id="eclipse篇"><a href="#eclipse篇" class="headerlink" title="eclipse篇"></a>eclipse篇</h2><p>其实我是IDEA党啦，之前还让eclipse党快点转IDEA的，结果现在我自己又转回到eclipse了。绝对不是因为现在自己又觉得eclipse更好了，大家不要误会！IDEA大法好，只是因为一些社会因素…所以我是不得不转回来呀！说下我在使用eclipse时遇到一些必须使用命令行的坑。  </p>
<p>运行maven项目用到一个tamcat插件时或者一个普通web项目启动tomcat时常遇到端口被占用的问题，输入<code>lsof -i:占用端口号</code>，这个命令可以帮助你看到电脑上哪些程序正在占用这个端口号。然后输入<code>kill -9:PID</code>或者<code>kill -s 9 PID</code>，将占用该端口号的程序杀死即可重新启动tomcat。对于某个正在运行的进程，如果不知道其占用的端口号，可以使用命令<code>ps aux|grep 进程名</code>或者<code>ps -ef | grep 进程名</code>,如我在服务器上跑了一个python进程，想要杀死这个进程，先在命令行输入<code>ps -ef | grep python</code>查出该python进程的PID，然后使用<code>kill -9 PID</code>或者<code>kill -s 9 PID</code>(中间要加冒号否？) or 直接使用<code>kill PID</code>命令将该进程杀死。  </p>
<p>查看Java版本，在命令行输入:<code>java -version</code></p>
<p>查看JAVA_HOME环境变量配置的路径:<code>echo $JAVA_HOME</code><br>查看SCALA_HOME(scala语言的环境变量)配置路径:<code>echo $SCALA_HOME</code><br>查看ant环境变量路径:<code>echo $ANT_HOME</code><br>查看系统环境变量:<code>echo $PATH</code></p>
<h2 id="jstack篇"><a href="#jstack篇" class="headerlink" title="jstack篇"></a>jstack篇</h2><p>  1.jps或top或ps -ef|grep java,找到需要的进程pid；<br>  2.jstack pid，查看pid的所有线程状态信息；<br>  3.或者jstack pid &gt; 1.log；将信息输出到1.log文件中</p>
<h2 id="Redis篇"><a href="#Redis篇" class="headerlink" title="Redis篇"></a>Redis篇</h2><p><code>redis-server</code>:在本地启动redis服务器<br><code>redis-cli</code>:进入redis命令环境，接下来便可以通过redis命令来操作本地redis服务器了<br><code>dbsize</code>:查看redis服务器中存储数据的大小<br><code>keys *</code>:查看redis服务器中存储的数据</p>
<h2 id="Homebrew篇"><a href="#Homebrew篇" class="headerlink" title="Homebrew篇"></a>Homebrew篇</h2><p>相信很多的人都没有听说过Homebrew吧，我也是刚刚接触。这里先给大家讲讲Homebrew的由来，Homebrew是用来干嘛的?  </p>
<p>Mac OS X是基于Unix的操作系统，可以安装大部分为Unix/Linux开发的软件。然而，如果只是以使用为目的，对每个软件都进行手工编译不是很方便，也不利于管理已安装的软件，于是出现了类似于Linux中APT、Yum等类似的软件包管理系统，其中最著名的有MacPorts、Fink、Homebrew等。  </p>
<p>Homebrew的原则是:它尽可能地利用系统自带的各种库，使得软件包的编译时间大为缩短；同时由于几乎不会造成冗余，软件包的管理也清晰、灵活了许多。Homebrew的另一个特点是使用Ruby定义软件包安装配置（叫做formula），定制非常简单。MacPorts、Fink大家自行了解，以上进行了Homebrew的相关知识介绍，下面介绍Homebrew的常用命令。  </p>
<p>要实用Homebrew的命令对mac上已安装的软件进行管理，所以首先我们要安装Homebrew:<code>ruby -e &quot;$(curl -fsSL https://raw.github.com/mxcl/homebrew/go)&quot;</code>  </p>
<p>执行过程需要输入root命令，当控制台出现:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.......</span><br><span class="line">==&gt; Installation successful!</span><br><span class="line">.......</span><br></pre></td></tr></table></figure></p>
<p>的信息时，说明Homebrew安装成功，然后便可以使用Homebrew的相关命令对mac上的软件执行管理了。以软件wget为例，查看其相关信息的命令为:  </p>
<p>查找wget软件包:<code>brew search wget</code>  </p>
<p>安装wget软件包:<code>brew install wget</code>  </p>
<p>删除wget软件包:<code>brew remove wget</code>  </p>
<p>查看wget软件包信息(例如安装路径):<code>brew info wget</code>  </p>
<p>列出wget软件包的依赖关系:<code>brew deps wget</code>  </p>
<p>列出系统中已经安装的软件包:<code>brew list</code>  </p>
<p>更新brew:<code>brew update</code>  </p>
<p>列出过时的软件包（已安装但不是最新版本）:<code>brew outdated</code>  </p>
<p>更新过时的软件包（全部或指定):<code>brew upgrade</code> 或 <code>brew upgrade wget</code></p>
<h2 id="mysql篇"><a href="#mysql篇" class="headerlink" title="mysql篇"></a>mysql篇</h2><p>mysql是目前市场上最火的一款数据库，而且还是免费开源给大家的，所以你要是不使用它总觉得自己亏了不少！就像库克要是有一天库克宣布以后出来的iphone都免费提供给你，你难道不会抛弃掉手中的小米或者华为而选择它？？？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql -u用户名 -p密码;  //登录进mysql服务器</span><br><span class="line"></span><br><span class="line">source sql脚本路径;   //在数据库中导入sql语句</span><br><span class="line"></span><br><span class="line">quit 或者  exit;  //退出mysql服务器</span><br><span class="line"></span><br><span class="line">mysql -V;   //查看mysql版本,我的版本是5.7.15</span><br></pre></td></tr></table></figure>
<p>关于sql语句这一块更多的命令请点击链接前往我博客<a href="http://codingxiaxw.cn/2016/10/09/15-SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/">mysql学习笔记</a>下进行学习吧。 </p>
<h2 id="系统篇"><a href="#系统篇" class="headerlink" title="系统篇"></a>系统篇</h2><p>另外我有时候需要查看隐藏目录，你要是告诉我在Finder中如何如何进行设置就好…这也太low了吧！即使我很菜我也是有追求的人好吗?不多说了附上命令快上车:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">隐藏Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool false</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">显示Mac隐藏文件的命令：defaults write com.apple.finder AppleShowAllFiles -bool true</span><br></pre></td></tr></table></figure></p>
<p>运行命令后可能仍然无法显示/隐藏mac下的隐藏文件，你需要按住option然后双击Finder选择重新启动Finder即可。还有很多我用到的系统命令在其他文章中都有复述到，所以这里就不重复累赘的进行一一介绍了。</p>
<p><code>echo $PATH</code>，查看系统环境变量。  </p>
<p>查看当前主机名:<code>echo $HOST</code>,网上有说是<code>echo $HOSTNAME</code>，我试过不行。</p>
<h2 id="Hadoop安装搭建篇"><a href="#Hadoop安装搭建篇" class="headerlink" title="Hadoop安装搭建篇"></a>Hadoop安装搭建篇</h2><p>启动Hadoop，进入到<code>/usr/local/Cellar/hadoop/2.7.3/sbin</code>目录，然后执行:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-dfs.sh</span><br></pre></td></tr></table></figure></p>
<p>关闭Hadoop:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./stop-dfs.sh</span><br></pre></td></tr></table></figure></p>
<p>还可以继续在命令行中(依旧在<code>/usr/local/Cellar/hadoop/2.7.3/sbin</code>目录下)执行如下启动/关闭脚本命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start-yarn.sh        //启动yarn，一个MapReduce框架</span><br><span class="line">./stop-yarn.sh        //停止yarn</span><br></pre></td></tr></table></figure></p>
<p>当然上述两个命令可以直接通过如下命令直接开启全部服务:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动Hadoop ./start-all.sh</span><br><span class="line">停止Hadoop ./stop-all.sh</span><br></pre></td></tr></table></figure></p>
<p>当然要是在配置了Hadoop的环境变量后就不用在进去<code>/usr/local/Cellar/hadoop/2.7.3/sbin</code>目录而是可以直接在当前用户目录使用上述命令了。</p>
<p>在某一目录下执行命令:<code>jps</code>可以查看当前正在运行的java进程。</p>
<p>查看hadoop版本:<code>hadoop version</code></p>
<p>关于Hadoop详细安装搭建命令请参考我这篇文章<a href="http://codingxiaxw.cn/2016/12/06/59-mac-hadoop/">mac下Hadoop的安装与使用</a></p>
<h2 id="Hadoop命令篇"><a href="#Hadoop命令篇" class="headerlink" title="Hadoop命令篇"></a>Hadoop命令篇</h2><p><code>hadoop fs -ls /</code>:列出远程Hadoop机的根目录下文件<br><code>hadoop fs -lsr /</code>:递归列出远程Hadoop机的根目录下所有文件</p>
<p><code>hadoop fs -put ~/A文件名 /</code>:将本机根目录下的文件A推到远程Hadoop机的根目录下。</p>
<p><code>hadoop fs -mkdir 文件夹路径/文件夹名</code>:在远程主机上创建文件夹</p>
<h2 id="zsh篇"><a href="#zsh篇" class="headerlink" title="zsh篇"></a>zsh篇</h2><p>输入:<code>cat /etc/shells</code>查看当前系统有几种shell。<br>查看系统当前使用的shell：<code>echo $SHELL</code></p>
<p>启动iTerm 2 默认使用bash改用zsh解决方法:<code>chsh -s /bin/zsh</code>，当然这个命令中的<code>/bin/zsh</code>要跟<code>/etc/shells</code>文件中的zsh的路径一致<br>查看当前zsh版本:<code>zsh --version</code>或者 <code>echo $ZSH_VERSION</code>  </p>
<h2 id="SSH篇"><a href="#SSH篇" class="headerlink" title="SSH篇"></a>SSH篇</h2><h3 id="1-SSH是什么"><a href="#1-SSH是什么" class="headerlink" title="1.SSH是什么"></a>1.SSH是什么</h3><p>简单说，SSH是一种网络协议，用于计算机之间的加密登录。  </p>
<p>如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。  </p>
<p>最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者Tatu Ylonen设计了SSH协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为Linux系统的标准配置。  </p>
<p>需要指出的是，SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的实现是OpenSSH，它是自由软件，应用非常广泛。  </p>
<p>此外，本文只讨论SSH在Linux Shell中的用法。如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，这需要另文介绍。</p>
<h3 id="2-最基本的用法"><a href="#2-最基本的用法" class="headerlink" title="2.最基本的用法"></a>2.最基本的用法</h3><p>SSH主要用于远程登录。假定你要以用户名user，登录远程主机host，只要一条简单命令就可以了:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br></pre></td></tr></table></figure></p>
<p>其中user代表远程用户名，host代表远程主机ip。如果本地用户名与远程用户名一致，登录时可以省略用户名:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh host</span><br></pre></td></tr></table></figure></p>
<p>SSH的默认端口是22，也就是说，你的登录请求会送进远程主机的22端口。使用p参数，可以修改这个端口:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -p 2222 user@host</span><br></pre></td></tr></table></figure></p>
<p>上面这条命令表示，ssh直接连接远程主机的2222端口。</p>
<h4 id="2-1使用口令登陆远程主机"><a href="#2-1使用口令登陆远程主机" class="headerlink" title="2.1使用口令登陆远程主机"></a>2.1使用口令登陆远程主机</h4><p>如果你是第一次登录对方主机，系统会出现下面的提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">　　The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.</span><br><span class="line">　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">　　Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure></p>
<p>这段话的意思是，无法确认host主机的真实性，只知道它的公钥指纹，问你还想继续连接吗？  </p>
<p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。  </p>
<p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。  </p>
<p>假定经过风险衡量以后，用户决定接受这个远程主机的公钥:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　Are you sure you want to continue connecting (yes/no)? yes</span><br></pre></td></tr></table></figure>
<p>系统会出现一句提示，表示host主机已经得到认可:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　Warning: Permanently added &apos;host,12.18.429.21&apos; (RSA) to the list of known hosts.</span><br></pre></td></tr></table></figure></p>
<p>然后，会要求输入密码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　Password: (enter password)</span><br></pre></td></tr></table></figure></p>
<p>如果密码正确，就可以登录了。  </p>
<p>当远程主机的公钥被接受以后，它就会被保存在文件<code>$HOME/.ssh/known_hosts</code>之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。  </p>
<p>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是<code>/etc/ssh/ssh_known_hosts</code>，保存一些对所有用户都可信赖的远程主机的公钥。  </p>
<h4 id="2-2使用公钥登录远程主机"><a href="#2-2使用公钥登录远程主机" class="headerlink" title="2.2使用公钥登录远程主机"></a>2.2使用公钥登录远程主机</h4><p>使用密码登录，每次都必须输入密码，非常麻烦。好在SSH还提供了公钥登录，可以省去输入密码的步骤。  </p>
<p>所谓”公钥登录”，原理很简单，就是用户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录shell，不再要求密码。  </p>
<p>这种方法要求用户必须提供自己的公钥。如果没有现成的，可以直接用ssh-keygen生成一个：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ ssh-keygen</span><br></pre></td></tr></table></figure></p>
<p>运行上面的命令以后，系统会出现一系列提示，可以一路回车。其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，这里可以设置一个。  </p>
<p>运行结束以后，在<code>$HOME/.ssh/</code>目录下，会新生成两个文件：id_rsa.pub和id_rsa。前者是你的公钥，后者是你的私钥。  </p>
<p>这时再输入下面的命令，将公钥传送到远程主机host上面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　$ ssh-copy-id user@host</span><br></pre></td></tr></table></figure></p>
<p>好了，从此你再登录，就不需要输入密码了。  </p>
<p>如果还是不行，就打开远程主机的<code>/etc/ssh/sshd_config</code>这个文件，检查下面几行前面”#”注释是否取掉:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　  RSAAuthentication yes</span><br><span class="line">　　PubkeyAuthentication yes</span><br><span class="line">　　AuthorizedKeysFile .ssh/authorized_keys</span><br></pre></td></tr></table></figure></p>
<p>然后，重启远程主机的ssh服务:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　// ubuntu系统</span><br><span class="line">　　service ssh restart</span><br><span class="line">　　// debian系统</span><br><span class="line">　　/etc/init.d/ssh restart</span><br></pre></td></tr></table></figure></p>
<h3 id="3-authorized-keys文件"><a href="#3-authorized-keys文件" class="headerlink" title="3.authorized_keys文件"></a>3.authorized_keys文件</h3><p>远程主机将用户的公钥，保存在登录后的用户主目录的<code>$HOME/.ssh/authorized_keys</code>文件中。公钥就是一段字符串，只要把它追加在authorized_keys文件的末尾就行了。</p>
<p>这里不使用上面的ssh-copy-id命令，改用下面的命令，解释公钥的保存过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　$ ssh user@host &apos;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&apos; &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p>
<p>这条命令由多个语句组成，依次分解开来看：（1）<code>$ ssh user@host</code>，表示登录远程主机；（2）单引号中的<code>mkdir .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys</code>，表示登录后在远程shell上执行的命令：（3）<code>$ mkdir -p .ssh</code>的作用是，如果用户主目录中的.ssh目录不存在，就创建一个；（4）<code>｀cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code>的作用是，将本地的公钥文件<code>~/.ssh/id_rsa.pub</code>，重定向追加到远程文件authorized_keys的末尾。  </p>
<p>写入authorized_keys文件后，公钥登录的设置就完成了。</p>
<p>需要补充说明的是，在我们使用github或者gitlab的时候也会在自己的电脑上设置一套连接github/gitlab的ssh，我们在终端上从github/gitlab上clone项目时可以使用https或者ssh,两种方法的区别可以自行google。二者(github/gitlab)可以直接共用一套ssh-key，mac用户可以在本地目录下的.ssh目录中(如我的目录就是/Users/codingBoy/.ssh)找到一个叫id_rsa.pub的文件，里面的内容就是你的ssh-key，使用一套ssh-key的好处就是不用配置多个ssh，坏处就是当修改这个ssh-key时，涉及到这个ssh-key的所有平台的ssh-key都要更新。</p>
<p>测试本地ssh是否成功配置到github/gitlab上的命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitlab.com</span><br><span class="line">或者</span><br><span class="line">ssh -T git@github.com</span><br><span class="line">区别，这里测试gitlab和github的命令有点不同，测试gitlab的时候需要将后面的命令git@gitlab.com换成git@服务器域名。</span><br></pre></td></tr></table></figure></p>
<p>若出现<code>welcome to XX,用户名</code>则表示配置成功。</p>
<h2 id="远程目录传输命令SCP"><a href="#远程目录传输命令SCP" class="headerlink" title="远程目录传输命令SCP"></a>远程目录传输命令SCP</h2><h3 id="scp是什么"><a href="#scp是什么" class="headerlink" title="scp是什么"></a>scp是什么</h3><p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。</p>
<h3 id="scp有什么用"><a href="#scp有什么用" class="headerlink" title="scp有什么用"></a>scp有什么用</h3><p>1、我们需要获得远程服务器上的某个文件，远程服务器既没有配置ftp服务器，没有开启web服务器，也没有做共享，无法通过常规途径获得文件时，只需要通过scp命令便可轻松的达到目的。</p>
<p>2、我们需要将本机上的文件上传到远程服务器上，远程服务器没有开启ftp服务器或共享，无法通过常规途径上传是，只需要通过scp命令便可以轻松的达到目的。</p>
<h3 id="scp基本使用"><a href="#scp基本使用" class="headerlink" title="scp基本使用"></a>scp基本使用</h3><h4 id="获取远程服务器上的文件"><a href="#获取远程服务器上的文件" class="headerlink" title="获取远程服务器上的文件"></a>获取远程服务器上的文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 root@www.vpser.net:/root/lnmp0.4.tar.gz /home/lnmp0.4.tar.gz</span><br></pre></td></tr></table></figure>
<p>上端口大写P 为参数，2222 表示更改SSH端口后的端口，如果没有更改SSH端口可以不用添加该参数。 <code>root@www.vpser.net</code> 表示使用root用户登录远程服务器<code>www.vpser.net</code>，<code>:/root/lnmp0.4.tar.gz</code> 表示远程服务器上的文件，最后面的<code>/home/lnmp0.4.tar.gz</code>表示保存在本地上的路径和文件名。还可能会用到p参数保持目录文件的权限访问时间等。</p>
<h4 id="获取远程服务器上的目录"><a href="#获取远程服务器上的目录" class="headerlink" title="获取远程服务器上的目录"></a>获取远程服务器上的目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 -r root@www.vpser.net:/root/lnmp0.4/ /home/lnmp0.4/</span><br></pre></td></tr></table></figure>
<p>上端口大写P 为参数，2222 表示更改SSH端口后的端口，如果没有更改SSH端口可以不用添加该参数。-r 参数表示递归复制（即复制该目录下面的文件和目录）；<code>root@www.vpser.net</code> 表示使用root用户登录远程服务器<code>www.vpser.net</code>，<code>:/root/lnmp0.4/</code> 表示远程服务器上的目录，最后面的<code>/home/lnmp0.4/</code>表示保存在本地上的路径。</p>
<h4 id="将本地文件上传到服务器上"><a href="#将本地文件上传到服务器上" class="headerlink" title="将本地文件上传到服务器上"></a>将本地文件上传到服务器上</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 /home/lnmp0.4.tar.gz root@www.vpser.net:/root/lnmp0.4.tar.gz</span><br></pre></td></tr></table></figure>
<p>上端口大写P 为参数，2222 表示更改SSH端口后的端口，如果没有更改SSH端口可以不用添加该参数。 <code>/home/lnmp0.4.tar.gz</code>表示本地上准备上传文件的路径和文件名。<code>root@www.vpser.net</code> 表示使用root用户登录远程服务器<code>www.vpser.net</code>，<code>:/root/lnmp0.4.tar.gz</code>表示保存在远程服务器上目录和文件名。</p>
<h4 id="将本地目录上传到服务器上"><a href="#将本地目录上传到服务器上" class="headerlink" title="将本地目录上传到服务器上"></a>将本地目录上传到服务器上</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 2222 -r /home/lnmp0.4/ root@www.vpser.net:/root/lnmp0.4/</span><br></pre></td></tr></table></figure>
<p>上 端口大写P 为参数，2222 表示更改SSH端口后的端口，如果没有更改SSH端口可以不用添加该参数。-r 参数表示递归复制（即复制该目录下面的文件和目录）；<code>/home/lnmp0.4/</code>表示准备要上传的目录，<code>root@www.vpser.net</code> 表示使用root用户登录远程服务器<code>www.vpser.net</code>，<code>:/root/lnmp0.4/</code> 表示保存在远程服务器上的目录位置。</p>
<h2 id="Linux篇"><a href="#Linux篇" class="headerlink" title="Linux篇"></a>Linux篇</h2><p>大家都知道mac OSX系统的前身是Linux(到底是不是的????)，所以在mac上运行linux命令是必不可少啦。我常用到的Linux命令有:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cd   //切换到根目录下</span><br><span class="line">cd 文件名A  //切换到文件A目录下</span><br><span class="line">cd .. //退回到上一目录</span><br><span class="line">cd ./文件A   //切换到当前目录下的A目录下</span><br><span class="line"></span><br><span class="line">ls  //列出当前文件夹下所有文件(不包括隐藏文件)</span><br><span class="line">ls -a  //列出当前文件夹下所有文件(包括隐藏文件)</span><br><span class="line">ls -l //列出长数据串，包含文件的属性与权限数据等</span><br><span class="line">ls -al  //列出长数据串，包含文件的属性与权限数据等</span><br><span class="line"></span><br><span class="line">mv A文件所在路径 B路径/  //将文件A从A文件所在路径下移动到B路径下</span><br><span class="line">mv A文件所在路径 B路径/C文件名  //将文件A从A文件所在路径下移动到B路径下并改名为C</span><br><span class="line">mv ./A文件名 ./B文件名  //将文件A的文件名改为B文件名</span><br><span class="line">mv既可以移动文件／目录、又可以改名文件／目录</span><br><span class="line"></span><br><span class="line">cp A文件 B文件  //将A文件拷贝一份并以B文件名命名</span><br><span class="line"></span><br><span class="line">mkdir 目录   //创建目录</span><br><span class="line">mkdir -p 目录1/目录2/目录3  //一次性创建这些目录</span><br><span class="line">rmdir 目录  //删除一个空目录</span><br><span class="line">rmdir -r 目录   //删除目录下所有文件及该目录(递归删除)</span><br><span class="line"></span><br><span class="line">rm 文件  //删除该文件</span><br><span class="line">rm -rf 目录  //递归删除该目录下所有文件及该目录</span><br><span class="line">pwd   //显示目前的目录路径</span><br><span class="line">touch  文件  // 创建文件</span><br><span class="line"></span><br><span class="line">whereis／find 文件名     //搜索该文件名的完整目录</span><br></pre></td></tr></table></figure></p>
<p>linux删除目录很简单，很多人还是习惯用<code>rmdir</code>，不过一旦目录非空，就陷入深深的苦恼之中，现在使用<code>rm -rf</code>命令即可。<br>直接rm就可以了，不过要加两个参数-rf 即：<code>rm -rf 目录名字</code><br>-r 就是向下递归，不管有多少级目录，一并删除<br>-f 就是直接强行删除，不作任何提示的意思</p>
<p>解压.tgz压缩文件到当前目录:<code>tar -zfx 文件名.tgz</code>或者是:<code>tar (-)zxvf 文件名.tgz</code><br>解压.tgz压缩文件到目标目录:<code>tar 文件名.tgz -C 目标路径</code></p>
<p>显示日历:<code>cal [year]</code>或者:<code>cal [month][year]</code>  </p>
<p>显示时间:<code>date</code></p>
<p>显示当前终端的语言:<code>locale</code><br>更改当前终端的语言:<code>LANG=en_US.utf8</code>，修改成中文的:<code>LANG=zh_CN.utf8</code>  </p>
<p>退出终端:<code>exit</code>或者快捷键<code>control+d</code>或者<code>logout</code>  </p>
<p>翻页:尽量不要使用鼠标滚动，使用组合键<code>shift+page up(down)</code>实现翻页。貌似我在mac上只能使用<code>fn+page up(down)</code>实现翻页  </p>
<p>求助:<code>指令 --help</code>或者<code>man 指令</code>，直接输入<code>q</code>回到终端</p>
<p>使用计算机:<code>bc</code>,/表示除法，^指数，%余数，若要支持小数点结果应在计算前输入:<code>scale=number</code>命令，number表示保留小数点位数，使用<code>quit</code>命令离开bc环境,输入<code>exit</code>命令bc环境返回0。</p>
<p>对于上述命令，若是在只有管理员才能权限操作的文件下，需要在命令前面加上<code>sudo</code> 关键字获取管理员权限然后才能对文件进行更改。</p>
<p><code>alias</code>，显示系统的所有别名设置</p>
<p><code>alias 别名=&#39;原来的命令&#39;</code>，进行别名的设置<br><code>unalias 别名</code>，移除别名</p>
<p><code>ifconfig</code>,mac或者linux系统下查看本机ip地址。<br><code>ipconfig</code>,windows下查看本机ip地址。<br><code>ping 同局域网下另一台机器ip</code>,和同局域网下另一台机器通信。  </p>
<p><code>passwd (机器用户名)</code>,修改本机(或者另外一台机器)登陆密码。<br><code>passwd -d (机器用户名)</code>,删除本机(或者另外一台机器)登陆密码。</p>
<p><code>su -</code>,从普通用户切换到root用户。<br><code>exit</code>，从root用户切换到普通用户。</p>
<p>使用<code>wget</code>命令直接通过命令行从网站下载文件时要是出现<code>--no-check-certificate</code>的报错，只需要在wget后面加上<code>--no-check-certificate</code>就可以，即需要一个认证下载指令而已。</p>
<p>修改目录及目录下所有文件的使用权限:<code>chown -R 用户名:用户名 目录路径</code>，如我在自己的221服务器上修改根目录下pic文件夹及该文件夹下所有文件的使用权限，我的用户名叫brown:<code>chown -R brown:brown /pic</code></p>
<p>上述Linux命令大家只是看的话估计没有什么效果，照着我的笔记敲效果也很低下，建议买一本&lt;&lt;鸟叔的Linux私房菜&gt;&gt;去学习Linux及其相关命令,博主目前也在恶补学习…</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>博主目前使用到相关软件的命令就这么多，以后用到又觉得比较重要的我会经常更新的，希望对你有所帮助吧。  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[『 Socket 』使用Socket实现TCP编程及聊天室的编写]]></title>
      <url>http://codingxiaxw.cn/2016/11/29/57-socket-chatroom/</url>
      <content type="html"><![CDATA[<p>本篇文章分为两个部分，一个部分是总结使用Socket实现TCP的编程的知识，主要就是完成服务器端和客户端两个对象的代码编写；另一个部分是通过Java写一个聊天室来对我们的Socket编程进行巩固。<a id="more"></a>  </p>
<p><strong>文章结构:</strong>首先是对TCP的简单介绍，然后在分析Socket通信的模型后进行Java Socket实现TCP编程的代码编写，最后是利用Socket的知识编写一个简单的聊天室。  </p>
<h2 id="1-TCP简介"><a href="#1-TCP简介" class="headerlink" title="1.TCP简介"></a>1.TCP简介</h2><p>TCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。在简化的计算机网络OSI模型中，它完成第四层传输层所指定的功能，用户数据报协议（UDP，本篇文章不介绍UDP)是同一层内另一个重要的传输协议。在因特网协议族(Internet protocol suite)中，TCP层是位于IP层之上，应用层之下的中间层。不同主机的应用层之间经常需要可靠的、像管道一样的连接，但是IP层不提供这样的流机制，而是提供不可靠的包交换。  </p>
<p>首先了解一下网络模型中的数据传递:应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段(通常受该计算机连接的网络的数据链路层的最大传输单元(MTU)的限制)。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。TCP用一个校验和函数来检验数据是否有错误；在发送和接收时都要计算校验和。  </p>
<h2 id="2-Socket通信模型"><a href="#2-Socket通信模型" class="headerlink" title="2.Socket通信模型"></a>2.Socket通信模型</h2><p>所谓socket 通常也称作”套接字“，用于描述IP地址和端口，是一个通信链的句柄。应用程序通常通过”套接字”向网络发出请求或者应答网络请求。首先我们看看Socket基于TCP的通信模型图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-29%20%E4%B8%8B%E5%8D%887.18.56.png" alt=""></p>
<p>图中通信模型的各个步骤如下:  </p>
<ol>
<li>在服务端建立一个ServerSocket,绑定相应的端口，并且在指定的端口进行侦听，等待客户端的连接。</li>
<li>当客户端创建连接Socket并且向服务端发送请求。</li>
<li>服务器收到请求，并且接受客户端的请求信息。一旦接收到客户端的连接请求后，会创建一个连接socket，用来与客户端的socket进行通信。通过相应的输入/输出流进行数据的交换，数据的发送接收以及数据的响应等等。</li>
<li>当客户端和服务端通信完毕后，需要分别关闭socket，结束通信。</li>
</ol>
<p>也就是基于服务器和客户端的开发，所以在服务器端和客户端我们分别需要完成的代码就是:  </p>
<p>对于服务器端需要完成的工作是:  </p>
<ol>
<li>创建ServerSocket对象，绑定监听器</li>
<li>通过accept（）方法监听客户端请求</li>
<li>连接建立以后通过读取客户端发送请求消息</li>
<li>通过输出流向客户端发送响应信息</li>
<li>关闭资源  </li>
</ol>
<p>ServerSocket类中涉及到的常用方法:</p>
<ul>
<li>ServerSocket(int port)——创建并绑定到特定端口的服务器套接字</li>
<li>accept()——侦听并接受到此套接字的连接</li>
<li>close()——关闭此套接字</li>
<li>getInetAddress()——得到ServerSocket对象绑定的IP地址。如果ServerSocket对象未绑定IP地址，返回0.0.0.0</li>
<li>getLocalPort()——返回此套接字在其上侦听的端口</li>
</ul>
<p>客户端需要完成的工作是:  </p>
<ol>
<li>创建Socket对象，指明需要连接的服务器地址和端口号(1023以后的端口,因为0~1023之间的端口号是我们系统需要使用的端口号)</li>
<li>连接建立后，通过输出流向服务器端请求</li>
<li>通过输入流获取服务器响应信息</li>
<li>关闭资源</li>
</ol>
<p>Socket类中常用的方法:</p>
<ul>
<li>Socket(InetAddress address, int port)——创建一个套接字并将其连接到指定ip地址的指定端口号</li>
<li>Socket(String host, int port)——创建一个套接字并将其连接到指定主机上的指定端口号</li>
<li>close()——关闭此套接字</li>
<li>getInetAddress()——返回套接字连接的地址</li>
<li>getInputStream()——返回此套接字的输入流</li>
<li>getOutputStream——返回此套接字的输出流</li>
</ul>
<p>好了，通过上述的描述，对Socket的编程就讲述的很清楚了，接下来针对上述描述进行我们服务器和客户端代码的编码工作。</p>
<h2 id="3-基于Tcp的Socket开发代码编写"><a href="#3-基于Tcp的Socket开发代码编写" class="headerlink" title="3.基于Tcp的Socket开发代码编写"></a>3.基于Tcp的Socket开发代码编写</h2><p>首先是服务器端Server.java的代码编写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by codingBoy on 16/11/29.</span><br><span class="line"> * 基于TCP协议的Socket通信，实现客户登录</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个服务器Socket，即ServerSocket,指定绑定的端口，并坚挺</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket=<span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2，调用accept()开始监听，等待客户端的链接</span></span><br><span class="line">            System.out.println(<span class="string">"****服务器即将启动，等待客户端的连接****"</span>);</span><br><span class="line">            Socket socket=serverSocket.accept();</span><br><span class="line">            <span class="comment">//3.获取输入流并获取客户信息</span></span><br><span class="line">            InputStream in=socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            InputStreamReader isr=<span class="keyword">new</span> InputStreamReader(in,<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">            BufferedReader br=<span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">            String info;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((info=br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(info);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"我是服务器，客户端发来的消息为:"</span>+sb);</span><br><span class="line"></span><br><span class="line">            socket.shutdownInput();<span class="comment">//关闭输入流</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.获取输出流，用于响应客户端的请求</span></span><br><span class="line">            OutputStream os=socket.getOutputStream();</span><br><span class="line">            PrintWriter pw=<span class="keyword">new</span> PrintWriter(os);</span><br><span class="line">            pw.write(<span class="string">"欢迎您"</span>);</span><br><span class="line">            pw.flush();<span class="comment">//将缓冲输出</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.关闭相关资源</span></span><br><span class="line">            pw.close();</span><br><span class="line">            os.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            br.close();</span><br><span class="line">            isr.close();</span><br><span class="line">            in.close();</span><br><span class="line">            socket.close();</span><br><span class="line">            serverSocket.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是客户端Client.java的代码编写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建客户端Socket,指定服务器端地址和端口号</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Socket socket=<span class="keyword">new</span> Socket(<span class="string">"localhost"</span>,<span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2.获取输出流，用来向服务器端发送登录信息</span></span><br><span class="line">            OutputStream os=socket.getOutputStream();</span><br><span class="line"></span><br><span class="line">            PrintWriter pw=<span class="keyword">new</span> PrintWriter(os);<span class="comment">//将输出流打包成打印流</span></span><br><span class="line">            pw.write(<span class="string">"用户名:codingxiaxw;密码:123"</span>);</span><br><span class="line">            pw.flush();<span class="comment">//刷新缓存</span></span><br><span class="line"></span><br><span class="line">            socket.shutdownOutput();<span class="comment">//关闭输出流</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.获取服务器传过来的输入流，读取服务器的响应信息</span></span><br><span class="line">            InputStream in=socket.getInputStream();</span><br><span class="line">            BufferedReader br=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in,<span class="string">"utf-8"</span>));</span><br><span class="line">            String info;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((info=br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(info);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"我是客户端，服务器给我的信息为:"</span>+sb);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.关闭资源</span></span><br><span class="line"></span><br><span class="line">            br.close();</span><br><span class="line">            in.close();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            pw.close();</span><br><span class="line">            os.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时我们的客户端和服务器端的代码便完成了，首先运行服务器Server.java，代码在执行到<code>Socket socket=serverSocket.accept();</code>时会在此阻塞，控制台输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">****服务器即将启动，等待客户端的连接****</span><br></pre></td></tr></table></figure></p>
<p>直到等到客户端连接到该端口号的服务器后服务器的代码才会向下执行，此时运行客户端Client.java，客户端的控制台输出:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我是客户端，服务器给我的信息为:欢迎您</span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>然后此时切换到服务器的控制台，发现输出信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">****服务器即将启动，等待客户端的连接****</span><br><span class="line">我是服务器，客户端发来的消息为:用户名:codingxiaxw;密码:123</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure></p>
<p>此时我们便使用Socket完成了一个服务器和一个客户端之间的通信，那么问题来了，如何实现一个服务器与多个客户端之间的通信呢？我们使用多线程服务器的方式。创建一个ServerThread.java用于编写服务器端多线程接收客户端传递过来的信息的代码编写，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(Socket socket)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket=socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//3.获取输入流并获取客户信息</span></span><br><span class="line">        InputStream in= <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader isr=<span class="keyword">null</span>;</span><br><span class="line">        BufferedReader br=<span class="keyword">null</span>;</span><br><span class="line">        OutputStream os=<span class="keyword">null</span>;</span><br><span class="line">        PrintWriter pw=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            in = socket.getInputStream();</span><br><span class="line">            isr=<span class="keyword">new</span> InputStreamReader(in,<span class="string">"utf-8"</span>);</span><br><span class="line">            br=<span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">            String info;</span><br><span class="line"></span><br><span class="line">            StringBuilder sb=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((info=br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sb.append(info);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"我是服务器，客户端发来的消息为:"</span>+sb);</span><br><span class="line"></span><br><span class="line">            socket.shutdownInput();<span class="comment">//关闭输入流</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.获取输出流，用于响应客户端的请求</span></span><br><span class="line">            os=socket.getOutputStream();</span><br><span class="line">            pw=<span class="keyword">new</span> PrintWriter(os);</span><br><span class="line">            pw.write(<span class="string">"欢迎您"</span>);</span><br><span class="line">            pw.flush();<span class="comment">//将缓冲输出</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.关闭相关资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (pw!=<span class="keyword">null</span>) pw.close();</span><br><span class="line">                <span class="keyword">if</span> (os!=<span class="keyword">null</span>) os.close();</span><br><span class="line">                <span class="keyword">if</span> (br!=<span class="keyword">null</span>) br.close();</span><br><span class="line">                <span class="keyword">if</span> (isr!=<span class="keyword">null</span>) isr.close();</span><br><span class="line">                <span class="keyword">if</span> (in!=<span class="keyword">null</span>) in.close();</span><br><span class="line">                <span class="keyword">if</span> (socket!=<span class="keyword">null</span>) socket.close();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上我们就是将之前写在Server.java中获取客户端传递过来的信息的那部分代码拿出来写在了该线程中，然后修改Server.java中的代码为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个服务器Socket，即ServerSocket,指定绑定的端口，并坚挺</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerSocket serverSocket=<span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2，调用accept()开始监听，等待客户端的链接</span></span><br><span class="line">            System.out.println(<span class="string">"****服务器即将启动，等待客户端的连接****"</span>);</span><br><span class="line">            <span class="comment">//记录客户端的数量</span></span><br><span class="line">            <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//调用accept()方法开始监听，等待客户端的连接</span></span><br><span class="line">                Socket socket = serverSocket.accept();</span><br><span class="line">                <span class="comment">//创建一个新的线程</span></span><br><span class="line">                ServerThread serverThread=<span class="keyword">new</span> ServerThread(socket);</span><br><span class="line">                <span class="comment">//启动线程</span></span><br><span class="line">                serverThread.start();  <span class="comment">//如果不要启动线程的话这里直接调用run()也行.</span></span><br><span class="line"></span><br><span class="line">                count++;<span class="comment">//统计客户端的数量</span></span><br><span class="line">                System.out.println(<span class="string">"客户端的数量："</span>+count);</span><br><span class="line"></span><br><span class="line">                InetAddress address=socket.getInetAddress();</span><br><span class="line">                System.out.println(<span class="string">"当前客户端的IP："</span>+address.getHostAddress());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行Server.java，服务器控制台输出信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">****服务器即将启动，等待客户端的连接****</span><br></pre></td></tr></table></figure></p>
<p>然后运行Client.java，客户端控制台输出信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我是客户端，服务器给我的信息为:欢迎您</span><br></pre></td></tr></table></figure></p>
<p>此时跳转到服务器控制台，信息变为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">****服务器即将启动，等待客户端的连接****</span><br><span class="line">我是服务器，客户端发来的消息为:用户名:codingxiaxw;密码:123</span><br><span class="line">客户端的数量：1</span><br><span class="line">当前客户端的IP：127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p>然后更改Client.java中传递给服务器的数据代码为:<code>pw.write(&quot;用户名:codingxiaxw;密码:456&quot;);</code>，再运行Client.java，发现服务器的控制台输出信息变为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">****服务器即将启动，等待客户端的连接****</span><br><span class="line">我是服务器，客户端发来的消息为:用户名:codingxiaxw;密码:13</span><br><span class="line">客户端的数量：1</span><br><span class="line">当前客户端的IP：127.0.0.1</span><br><span class="line">我是服务器，客户端发来的消息为:用户名:codingxiaxw;密码:456</span><br><span class="line">客户端的数量：2</span><br><span class="line">当前客户端的IP：127.0.0.1</span><br></pre></td></tr></table></figure></p>
<p>这样我们便完成了多线程服务器的编码工作，到此我们便成功使用Socket完成了基于TCP协议的编程。接下来趁热打铁，用Socket实现一个简单的聊天室功能。  </p>
<h2 id="4-使用Socket实现一个简单的聊天室"><a href="#4-使用Socket实现一个简单的聊天室" class="headerlink" title="4.使用Socket实现一个简单的聊天室"></a>4.使用Socket实现一个简单的聊天室</h2><p>功能概述:客户端用于发送信息(在控制台中发送信息),将在控制台输出的信息转换为输出流输出到服务器端，服务器通过<code>socket.getOutputStream()</code>方法接收客户端传来的信息，并将发送该信息的客户端地址及信息发送在控制台中，这样我们便简单的实现了我们的聊天室。  </p>
<p>这里给大家讲讲qq通信的原理:qq使用c/s模式进行通信，qq中的用户A发送信息给用户B，过程是这样的:当A打开和B的聊天窗口时即和B还有服务器建立了一个聊天室(同时服务器和客户端开启连接)，A发送信息，其实是发送到了qq聊天室服务器的接收容器中，然后qq服务器将该客户端地址(即qq头像)和信息内容显示在聊天室中(即聊天窗口)，你每和一个好友进行聊天打开一个窗口就等于和她(另一个客户端)还有我们的qq服务器组成了一个聊天室(当然聊天室的服务器肯定是多线程的)。qq上还有多人聊天的功能，实现道理也是这样，只是该聊天室中有多个客户端给服务器发送消息罢了。(这是qq刚兴起时的聊天功能设计，也就是我们本篇文章需要实现的简单的聊天室功能，下面的内容与设计聊天室无关，但是我觉得还是有必要跟大家介绍清楚如今的qq时怎样工作的，了解便可)  </p>
<p>qq服务器挂在腾讯的某台主机上，相当于起了一个中转站的成分，这种聊天功能的实现对于客户端数量比较少时服务器端还能接受，但是在客户端数量很多时服务器肯定要瘫痪。  </p>
<p>所以为了减少服务器端的压力，需要实现客户端和客户端之间的直接通信，这样客户端上的qq既要实现服务器端的功能(用于接收信息)又要实现客户端的功能(用于发送信息)。此时qq服务器就不再作为一个中转站的功能了，它主要用于:用于客户端程序登陆,验证用户名密码,获取其他在线好友信息等等。</p>
<p>分析了功能后接下来进行我们服务器端和客户端代码的编写，首先创建一个ChatRoom.java，运行后用于开启服务器和客户端的连接，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">待更新。</span><br></pre></td></tr></table></figure></p>
<p>待更新。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="5-联系"><a href="#5-联系" class="headerlink" title="5.联系"></a>5.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java高并发秒杀系统API(三)之Web层开发]]></title>
      <url>http://codingxiaxw.cn/2016/11/28/55-seckill-web/</url>
      <content type="html"><![CDATA[<p>本篇文章总结自己开发秒杀系统Web层的过程，主要介绍前端交互设计、Restful:url满足Restful设计规范、Spring MVC、bootstrap+jquery这四个方面的开发。<a id="more"></a>  </p>
<h2 id="1-前端交互流程设计"><a href="#1-前端交互流程设计" class="headerlink" title="1.前端交互流程设计"></a>1.前端交互流程设计</h2><p>对于一个系统，需要产品经理、前端工程师和后端工程师的参数，产品经理将用户的需求做成一个开发文档交给前端工程师和后端工程师，前端工程师为系统完成页面的开发，后端工程师为系统完成业务逻辑的开发。对于我们这个秒杀系统，它的前端交互流程设计如下图:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-28%20%E4%B8%8B%E5%8D%886.13.55.png" alt="">  </p>
<p>这个流程图就告诉了我们详情页的流程逻辑，前端工程师根据这个流程图设计页面，而我们后端工程师根据这个流程图开发我们对应的代码。前端交互流程是系统开发中很重要的一部分，接下来进行Restful接口设计的学习。  </p>
<h2 id="2-Restful接口设计学习"><a href="#2-Restful接口设计学习" class="headerlink" title="2.Restful接口设计学习"></a>2.Restful接口设计学习</h2><p>什么是Restful?它就是一种优雅的URI表述方式，用来设计我们资源的访问URL。通过这个URL的设计，我们就可以很自然的感知到这个URL代表的是哪种业务场景或者什么样的数据或资源。基于Restful设计的URL，对于我们接口的使用者、前端、web系统或者搜索引擎甚至是我们的用户，都是非常友好的。关于Restful的了解大家去网上一搜一大把，我这里就不再做介绍了。下面看看我们这个秒杀系统的URL设计:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-28%20%E4%B8%8B%E5%8D%886.49.47.png" alt=""></p>
<p>接下来基于上述资源接口来开始我们对Spring MVC框架的使用。  </p>
<h2 id="3-整合配置Spring-MVC框架"><a href="#3-整合配置Spring-MVC框架" class="headerlink" title="3.整合配置Spring MVC框架"></a>3.整合配置Spring MVC框架</h2><p>首先在WEB-INF的web.xml中进行我们前端控制器DispatcherServlet的配置，如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span><br><span class="line">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span><br><span class="line">         <span class="attr">version</span>=<span class="string">"3.0"</span></span><br><span class="line">         <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用maven创建的web-app需要修改servlet的版本为3.1--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>seckill-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span><br><span class="line">            配置SpringMVC 需要配置的文件</span><br><span class="line">            spring-dao.xml，spring-service.xml,spring-web.xml</span><br><span class="line">            Mybites -&gt; spring -&gt; springMvc</span><br><span class="line">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring/spring-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>seckill-dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--默认匹配所有请求--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在spring容器中进行web层相关bean(即Controller)的配置，在spring包下创建一个spring-web.xml，内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context </span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/mvc </span><br><span class="line">        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置spring mvc--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1,开启springmvc注解模式</span><br><span class="line">    a.自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter</span><br><span class="line">    b.默认提供一系列的功能:数据绑定，数字和日期的format@NumberFormat,@DateTimeFormat</span><br><span class="line">    c:xml,json的默认读写支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.静态资源默认servlet配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span><br><span class="line">        1).加入对静态资源处理：js,gif,png</span><br><span class="line">        2).允许使用 "/" 做整体映射</span><br><span class="line">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3：配置JSP 显示ViewResolver--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--4:扫描web相关的bean--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.codingxiaxw.web"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们便完成了Spring MVC的相关配置(即将Spring MVC框架整合到了我们的项目中)，接下来就要基于Restful接口进行我们项目的Controller开发工作了。</p>
<h2 id="4-Controller开发"><a href="#4-Controller开发" class="headerlink" title="4.Controller开发"></a>4.Controller开发</h2><p>Controller中的每一个方法都对应我们系统中的一个资源URL，其设计应该遵循Restful接口的设计风格。在cn.codingxiaxw包下创建一个web包用于放web层Controller开发的代码，在该包下创建一个SeckillController.java，内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/seckill"</span>)<span class="comment">//url:模块/资源/&#123;&#125;/细分</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillController</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SeckillService seckillService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/list"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//list.jsp+mode=ModelAndView</span></span><br><span class="line">        <span class="comment">//获取列表页</span></span><br><span class="line">        List&lt;Seckill&gt; list=seckillService.getSeckillList();</span><br><span class="line">        model.addAttribute(<span class="string">"list"</span>,list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"list"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;seckillId&#125;/detail"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">detail</span><span class="params">(@PathVariable(<span class="string">"seckillId"</span>)</span> Long seckillId, Model model)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (seckillId == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:/seckill/list"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Seckill seckill=seckillService.getById(seckillId);</span><br><span class="line">        <span class="keyword">if</span> (seckill==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"forward:/seckill/list"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(<span class="string">"seckill"</span>,seckill);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"detail"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ajax ,json暴露秒杀接口的方法</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;seckillId&#125;/exposer"</span>,</span><br><span class="line">                    method = RequestMethod.POST,</span><br><span class="line">                    produces = &#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillResult&lt;Exposer&gt; <span class="title">exposer</span><span class="params">(Long seckillId)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        SeckillResult&lt;Exposer&gt; result;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Exposer exposer=seckillService.exportSeckillUrl(seckillId);</span><br><span class="line">            result=<span class="keyword">new</span> SeckillResult&lt;Exposer&gt;(<span class="keyword">true</span>,exposer);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            result=<span class="keyword">new</span> SeckillResult&lt;Exposer&gt;(<span class="keyword">false</span>,e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="meta">@RequestMapping</span>(value = <span class="string">"/&#123;seckillId&#125;/&#123;md5&#125;/execution"</span>,</span><br><span class="line">            method = RequestMethod.POST,</span><br><span class="line">            produces = &#123;<span class="string">"application/json;charset=UTF-8"</span>&#125;)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillResult&lt;SeckillExecution&gt; <span class="title">execute</span><span class="params">(@PathVariable(<span class="string">"seckillId"</span>)</span> Long seckillId,</span><br><span class="line">                                                   @<span class="title">PathVariable</span><span class="params">(<span class="string">"md5"</span>)</span> String md5,</span><br><span class="line">                                                   @<span class="title">CookieValue</span><span class="params">(value = <span class="string">"killPhone"</span>,required = <span class="keyword">false</span>)</span> Long phone)</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (phone==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">false</span>,<span class="string">"未注册"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SeckillResult&lt;SeckillExecution&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SeckillExecution execution = seckillService.executeSeckill(seckillId, phone, md5);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">true</span>, execution);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RepeatKillException e1)</span><br><span class="line">        &#123;</span><br><span class="line">            SeckillExecution execution=<span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.REPEAT_KILL);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">false</span>,execution);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SeckillCloseException e2)</span><br><span class="line">        &#123;</span><br><span class="line">            SeckillExecution execution=<span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.END);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">false</span>,execution);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            SeckillExecution execution=<span class="keyword">new</span> SeckillExecution(seckillId, SeckillStatEnum.INNER_ERROR);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;SeckillExecution&gt;(<span class="keyword">false</span>,execution);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取系统时间</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/time/now"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillResult&lt;Long&gt; <span class="title">time</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        Date now=<span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SeckillResult&lt;Long&gt;(<span class="keyword">true</span>,now.getTime());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Controller开发中的方法完全是对照Service接口方法进行开发的，第一个方法用于访问我们商品的列表页，第二个方法访问商品的详情页，第三个方法用于返回一个json数据，数据中封装了我们商品的秒杀地址，第四个方法用于封装用户是否秒杀成功的信息，第五个方法用于返回系统当前时间。代码中涉及到一个将返回秒杀商品地址封装为json数据的一个Vo类，即SeckillResult.java，在dto包中创建它，内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将所有的ajax请求返回类型，全部封装成json数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> success;</span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    <span class="keyword">private</span> String error;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillResult</span><span class="params">(<span class="keyword">boolean</span> success, T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillResult</span><span class="params">(<span class="keyword">boolean</span> success, String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccess</span><span class="params">(<span class="keyword">boolean</span> success)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.success = success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getError</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setError</span><span class="params">(String error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，Controller的开发任务完成，接下来进行我们的页面开发。</p>
<h2 id="5-页面开发"><a href="#5-页面开发" class="headerlink" title="5.页面开发"></a>5.页面开发</h2><p>页面由前端工程师完成，这里直接拷贝<a href="https://github.com/codingXiaxw/seckill" target="_blank" rel="external">我github上源代码</a>中jsp的代码(webapp包下的所有资源)即可。 </p>
<p>然后运行Tomcat服务器,在浏览器中输入<code>http://localhost:8080/seckill/list</code>，即可访问我们的秒杀列表页面:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-28%20%E4%B8%8B%E5%8D%889.14.36.png" alt="">  </p>
<p>点击相应商品后面的详情页链接即可查看该商品是否开启秒杀、秒杀该商品等活动。到此，web层的开发也结束，我们的系统开发便告一段落。但往往这样一个秒杀系统，往往是会有成千上万的人进行参与，我们目前的系统是抗不起多少高并发操作的，所以后面我们会对本系统进行高并发的优化。请查看我的下篇文章<a href="">Java高并发秒杀API之高并发优化(待更新)</a>  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java高并发秒杀系统API(二)之Service层开发]]></title>
      <url>http://codingxiaxw.cn/2016/11/28/54-seckill-service/</url>
      <content type="html"><![CDATA[<p>开始Service层的编码之前，我们首先需要进行Dao层编码之后的思考:在Dao层我们只完成了针对表的相关操作包括写了接口方法和映射文件中的sql语句，并没有编写逻辑的代码，例如对多个Dao层方法的拼接，当我们用户成功秒杀商品时我们需要进行商品的减库存操作(调用SeckillDao接口)和增加用户明细(调用SuccessKilledDao接口)，这些逻辑我们都需要在Service层完成。<a id="more"></a>这也是一些初学者容易出现的错误，他们喜欢在Dao层进行逻辑的编写，其实Dao就是数据访问的缩写，它只进行数据的访问操作，接下来我们便进行Service层代码的编写。</p>
<h2 id="1-秒杀Service接口设计"><a href="#1-秒杀Service接口设计" class="headerlink" title="1.秒杀Service接口设计"></a>1.秒杀Service接口设计</h2><p>在cn.codingxiaxw包下创建一个service包用于存放我们的Service接口和其实现类，创建一个exception包用于存放service层出现的异常例如重复秒杀商品异常、秒杀已关闭等异常，一个dto包作为传输层,dto和entity的区别在于:entity用于业务数据的封装，而dto用于完成web和service层的数据传递。  </p>
<p>首先创建我们Service接口，里面的方法应该是按”使用者”(程序员)的角度去设计，SeckillService.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SeckillService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 查询全部的秒杀记录</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">List&lt;Seckill&gt; <span class="title">getSeckillList</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     *查询单个秒杀记录</span><br><span class="line">     * <span class="doctag">@param</span> seckillId</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">Seckill <span class="title">getById</span><span class="params">(<span class="keyword">long</span> seckillId)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//再往下，是我们最重要的行为的一些接口</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 在秒杀开启时输出秒杀接口的地址，否则输出系统时间和秒杀时间</span><br><span class="line">     * <span class="doctag">@param</span> seckillId</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">Exposer <span class="title">exportSeckillUrl</span><span class="params">(<span class="keyword">long</span> seckillId)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 执行秒杀操作，有可能失败，有可能成功，所以要抛出我们允许的异常</span><br><span class="line">     * <span class="doctag">@param</span> seckillId</span><br><span class="line">     * <span class="doctag">@param</span> userPhone</span><br><span class="line">     * <span class="doctag">@param</span> md5</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">SeckillExecution <span class="title">executeSeckill</span><span class="params">(<span class="keyword">long</span> seckillId,<span class="keyword">long</span> userPhone,String md5)</span></span><br><span class="line">            <span class="keyword">throws</span> SeckillException,RepeatKillException,SeckillCloseException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该接口中前面两个方法返回的都是跟我们业务相关的对象，而后两个方法返回的对象与业务不相关，这两个对象我们用于封装service和web层传递的数据，方法的作用我们已在注释中给出。相应在的dto包中创建Exposer.java，用于封装秒杀的地址信息，各个属性的作用在代码中已给出注释，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by codingBoy on 16/11/27.</span><br><span class="line"> * 暴露秒杀地址(接口)DTO</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Exposer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否开启秒杀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> exposed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对秒杀地址加密措施</span></span><br><span class="line">    <span class="keyword">private</span> String md5;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//id为seckillId的商品的秒杀地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seckillId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//系统当前时间(毫秒)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀的开启时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀的结束时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exposer</span><span class="params">(<span class="keyword">boolean</span> exposed, String md5, <span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exposed = exposed;</span><br><span class="line">        <span class="keyword">this</span>.md5 = md5;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exposer</span><span class="params">(<span class="keyword">boolean</span> exposed, <span class="keyword">long</span> seckillId,<span class="keyword">long</span> now, <span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exposed = exposed;</span><br><span class="line">        <span class="keyword">this</span>.seckillId=seckillId;</span><br><span class="line">        <span class="keyword">this</span>.now = now;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Exposer</span><span class="params">(<span class="keyword">boolean</span> exposed, <span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exposed = exposed;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExposed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exposed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExposed</span><span class="params">(<span class="keyword">boolean</span> exposed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exposed = exposed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMd5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> md5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMd5</span><span class="params">(String md5)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.md5 = md5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSeckillId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeckillId</span><span class="params">(<span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNow</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.now = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStart</span><span class="params">(<span class="keyword">long</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getEnd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(<span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和SeckillExecution.java，用于判断秒杀是否成功，成功就返回秒杀成功的所有信息(包括秒杀的商品id、秒杀成功状态、成功信息、用户明细)，失败就抛出一个我们允许的异常(重复秒杀异常、秒杀结束异常),代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 封装执行秒杀后的结果:是否秒杀成功</span><br><span class="line"> * Created by codingBoy on 16/11/27.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillExecution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seckillId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀执行结果的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//状态的明文标识</span></span><br><span class="line">    <span class="keyword">private</span> String stateInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当秒杀成功时，需要传递秒杀成功的对象回去</span></span><br><span class="line">    <span class="keyword">private</span> SuccessKilled successKilled;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀成功返回所有信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillExecution</span><span class="params">(<span class="keyword">long</span> seckillId, <span class="keyword">int</span> state, String stateInfo, SuccessKilled successKilled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">        <span class="keyword">this</span>.successKilled = successKilled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀失败</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillExecution</span><span class="params">(<span class="keyword">long</span> seckillId, <span class="keyword">int</span> state, String stateInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSeckillId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeckillId</span><span class="params">(<span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStateInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stateInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStateInfo</span><span class="params">(String stateInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stateInfo = stateInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SuccessKilled <span class="title">getSuccessKilled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successKilled;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessKilled</span><span class="params">(SuccessKilled successKilled)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successKilled = successKilled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后需要创建我们在秒杀业务过程中允许的异常，重复秒杀异常RepeatKillException.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 重复秒杀异常，是一个运行期异常，不需要我们手动try catch</span><br><span class="line"> * Mysql只支持运行期异常的回滚操作</span><br><span class="line"> * Created by codingBoy on 16/11/27.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatKillException</span> <span class="keyword">extends</span> <span class="title">SeckillException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepeatKillException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RepeatKillException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>秒杀关闭异常SeckillCloseException.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 秒杀关闭异常，当秒杀结束时用户还要进行秒杀就会出现这个异常</span><br><span class="line"> * Created by codingBoy on 16/11/27.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillCloseException</span> <span class="keyword">extends</span> <span class="title">SeckillException</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillCloseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillCloseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和一个异常包含与秒杀业务所有出现的异常SeckillException.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 秒杀相关的所有业务异常</span><br><span class="line"> * Created by codingBoy on 16/11/27.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SeckillException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，接口的工作便完成，接下来进行接口实现类的编码工作。  </p>
<h2 id="2-秒杀Service接口的实现"><a href="#2-秒杀Service接口的实现" class="headerlink" title="2.秒杀Service接口的实现"></a>2.秒杀Service接口的实现</h2><p>在service包下创建impl包存放它的实现类，SeckillServiceImpl.java，内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SeckillService</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//日志对象</span></span><br><span class="line">    <span class="keyword">private</span> Logger logger= LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入一个混淆字符串(秒杀接口)的salt，为了我避免用户猜出我们的md5值，值任意给，越复杂越好</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String salt=<span class="string">"shsdssljdd'l."</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入Service依赖</span></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SeckillDao seckillDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span> <span class="comment">//@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SuccessKilledDao successKilledDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Seckill&gt; <span class="title">getSeckillList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckillDao.queryAll(<span class="number">0</span>,<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Seckill <span class="title">getById</span><span class="params">(<span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckillDao.queryById(seckillId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Exposer <span class="title">exportSeckillUrl</span><span class="params">(<span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        Seckill seckill=seckillDao.queryById(seckillId);</span><br><span class="line">        <span class="keyword">if</span> (seckill==<span class="keyword">null</span>) <span class="comment">//说明查不到这个秒杀产品的记录</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">false</span>,seckillId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//若是秒杀未开启</span></span><br><span class="line">        Date startTime=seckill.getStartTime();</span><br><span class="line">        Date endTime=seckill.getEndTime();</span><br><span class="line">        <span class="comment">//系统当前时间</span></span><br><span class="line">        Date nowTime=<span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">if</span> (startTime.getTime()&gt;nowTime.getTime() || endTime.getTime()&lt;nowTime.getTime())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">false</span>,seckillId,nowTime.getTime(),startTime.getTime(),endTime.getTime());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//秒杀开启，返回秒杀商品的id、用给接口加密的md5</span></span><br><span class="line">        String md5=getMD5(seckillId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Exposer(<span class="keyword">true</span>,md5,seckillId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getMD5</span><span class="params">(<span class="keyword">long</span> seckillId)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        String base=seckillId+<span class="string">"/"</span>+salt;</span><br><span class="line">        String md5= DigestUtils.md5DigestAsHex(base.getBytes());</span><br><span class="line">        <span class="keyword">return</span> md5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//秒杀是否成功，成功:减库存，增加明细；失败:抛出异常，事务回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SeckillExecution <span class="title">executeSeckill</span><span class="params">(<span class="keyword">long</span> seckillId, <span class="keyword">long</span> userPhone, String md5)</span></span><br><span class="line">            <span class="keyword">throws</span> SeckillException, RepeatKillException, SeckillCloseException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (md5==<span class="keyword">null</span>||!md5.equals(getMD5(seckillId)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SeckillException(<span class="string">"seckill data rewrite"</span>);<span class="comment">//秒杀数据被重写了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行秒杀逻辑:减库存+增加购买明细</span></span><br><span class="line">        Date nowTime=<span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//减库存</span></span><br><span class="line">            <span class="keyword">int</span> updateCount=seckillDao.reduceNumber(seckillId,nowTime);</span><br><span class="line">            <span class="keyword">if</span> (updateCount&lt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//没有更新库存记录，说明秒杀结束</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SeckillCloseException(<span class="string">"seckill is closed"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//否则更新了库存，秒杀成功,增加明细</span></span><br><span class="line">                <span class="keyword">int</span> insertCount=successKilledDao.insertSuccessKilled(seckillId,userPhone);</span><br><span class="line">                <span class="comment">//看是否该明细被重复插入，即用户是否重复秒杀</span></span><br><span class="line">                <span class="keyword">if</span> (insertCount&lt;=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RepeatKillException(<span class="string">"seckill repeated"</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//秒杀成功,得到成功插入的明细记录,并返回成功秒杀的信息</span></span><br><span class="line">                    SuccessKilled successKilled=successKilledDao.queryByIdWithSeckill(seckillId,userPhone);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> SeckillExecution(seckillId,<span class="number">1</span>,<span class="string">"秒杀成功"</span>,successKilled);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (SeckillCloseException e1)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> e1;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (RepeatKillException e2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> e2;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">            <span class="comment">//所以编译期异常转化为运行期异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SeckillException(<span class="string">"seckill inner error :"</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对上述代码进行分析一下，在<code>return new SeckillExecution(seckillId,1,&quot;秒杀成功&quot;,successKilled);</code>代码中，我们返回的state和stateInfo参数信息应该是输出给前端的，但是我们不想在我们的return代码中硬编码这两个参数，所以我们应该考虑用枚举的方式将这些常量封装起来，在cn.codingxiaxw包下新建一个枚举包enums，创建一个枚举类型SeckillStatEnum.java，内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SeckillStatEnum &#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">1</span>,<span class="string">"秒杀成功"</span>),</span><br><span class="line">    END(<span class="number">0</span>,<span class="string">"秒杀结束"</span>),</span><br><span class="line">    REPEAT_KILL(-<span class="number">1</span>,<span class="string">"重复秒杀"</span>),</span><br><span class="line">    INNER_ERROR(-<span class="number">2</span>,<span class="string">"系统异常"</span>),</span><br><span class="line">    DATE_REWRITE(-<span class="number">3</span>,<span class="string">"数据篡改"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line">    SeckillStatEnum(<span class="keyword">int</span> state, String info) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.info = info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SeckillStatEnum <span class="title">stateOf</span><span class="params">(<span class="keyword">int</span> index)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SeckillStatEnum state : values())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (state.getState()==index)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> state;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后修改执行秒杀操作的非业务类SeckillExecution.java里面涉及到state和stateInfo参数的构造方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//秒杀成功返回所有信息</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">SeckillExecution</span><span class="params">(<span class="keyword">long</span> seckillId, SeckillStatEnum statEnum, SuccessKilled successKilled)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">     <span class="keyword">this</span>.state = statEnum.getState();</span><br><span class="line">     <span class="keyword">this</span>.stateInfo = statEnum.getInfo();</span><br><span class="line">     <span class="keyword">this</span>.successKilled = successKilled;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//秒杀失败</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">SeckillExecution</span><span class="params">(<span class="keyword">long</span> seckillId, SeckillStatEnum statEnum)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">     <span class="keyword">this</span>.state = statEnum.getState();</span><br><span class="line">     <span class="keyword">this</span>.stateInfo = statEnum.getInfo();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后便可修改实现类方法中的返回语句为:<code>return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS,successKilled);</code>，保证了一些常用常量数据被封装在枚举类型里。  </p>
<p>目前为止我们Service的实现全部完成，接下来要将Service交给Spring的容器托管，进行一些配置。  </p>
<h2 id="3-使用Spring托管Service依赖配置"><a href="#3-使用Spring托管Service依赖配置" class="headerlink" title="3.使用Spring托管Service依赖配置"></a>3.使用Spring托管Service依赖配置</h2><p>在spring包下创建一个spring-service.xml文件，内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--扫描service包下所有使用注解的类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.codingxiaxw.service"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后采用注解的方式将Service的实现类加入到Spring IOC容器中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component @Service @Dao @Controller</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceImpl</span> <span class="keyword">implements</span> <span class="title">SeckillService</span></span></span><br></pre></td></tr></table></figure></p>
<p>下面我们来运用Spring的声明式事务对我们项目中的事务进行管理。  </p>
<h2 id="4-使用Spring声明式事务配置"><a href="#4-使用Spring声明式事务配置" class="headerlink" title="4.使用Spring声明式事务配置"></a>4.使用Spring声明式事务配置</h2><p>声明式事务的使用方式:1.早期使用的方式:ProxyFactoryBean+XMl.2.tx:advice+aop命名空间，这种配置的好处就是一次配置永久生效。3.注解@Transactional的方式。在实际开发中，建议使用第三种对我们的事务进行控制，优点见下面代码中的注释。下面让我们来配置声明式事务，在spring-service.xml中添加对事务的配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--注入数据库连接池--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置基于注解的声明式事务</span><br><span class="line">  默认使用注解来管理事务行为--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在Service实现类的方法中，在需要进行事务声明的方法上加上事务的注解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//秒杀是否成功，成功:减库存，增加明细；失败:抛出异常，事务回滚</span></span><br><span class="line">   <span class="meta">@Transactional</span></span><br><span class="line">   <span class="comment">/**</span><br><span class="line">    * 使用注解控制事务方法的优点:</span><br><span class="line">    * 1.开发团队达成一致约定，明确标注事务方法的编程风格</span><br><span class="line">    * 2.保证事务方法的执行时间尽可能短，不要穿插其他网络操作RPC/HTTP请求或者剥离到事务方法外部</span><br><span class="line">    * 3.不是所有的方法都需要事务，如只有一条修改操作、只读操作不要事务控制</span><br><span class="line">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> SeckillExecution <span class="title">executeSeckill</span><span class="params">(<span class="keyword">long</span> seckillId, <span class="keyword">long</span> userPhone, String md5)</span></span><br><span class="line">           <span class="keyword">throws</span> SeckillException, RepeatKillException, SeckillCloseException </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面针对我们之前做的业务实现类来做集成测试。  </p>
<h2 id="5-使用集成测试Service逻辑"><a href="#5-使用集成测试Service逻辑" class="headerlink" title="5.使用集成测试Service逻辑"></a>5.使用集成测试Service逻辑</h2><p>在SeckillService接口中使用IDEA快捷键<code>shift+command+T</code>，快速生成junit测试类。Service实现类中前面两个方法很好实现，获取列表或者列表中的一个商品的信息即可，测试如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="comment">//告诉junit spring的配置文件</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(&#123;<span class="string">"classpath:spring/spring-dao.xml"</span>,</span><br><span class="line">                        <span class="string">"classpath:spring/spring-service.xml"</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Logger logger= LoggerFactory.getLogger(<span class="keyword">this</span>.getClass());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SeckillService seckillService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSeckillList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;Seckill&gt; seckills=seckillService.getSeckillList();</span><br><span class="line">        System.out.println(seckills);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> seckillId=<span class="number">1000</span>;</span><br><span class="line">        Seckill seckill=seckillService.getById(seckillId);</span><br><span class="line">        System.out.println(seckill);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>重点就是<code>exportSeckillUrl()</code>方法和<code>executeSeckill()</code>方法的测试，接下来我们进行<code>exportSeckillUrl()</code>方法的测试，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exportSeckillUrl</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> seckillId=<span class="number">1000</span>;</span><br><span class="line">       Exposer exposer=seckillService.exportSeckillUrl(seckillId);</span><br><span class="line">       System.out.println(exposer);</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台中输入如下信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exposer&#123;exposed=false, md5=&apos;null&apos;, seckillId=1000, now=1480322072410, start=1451577600000, end=1451664000000&#125;</span><br></pre></td></tr></table></figure></p>
<p>没有给我们返回id为1000的商品秒杀地址，是因为我们当前的时间并不在秒杀时间开启之内，所以该商品还没有开启。需要修改数据库中该商品秒杀活动的时间在我们测试时的当前时间之内，然后再进行该方法的测试，控制台中输出如下信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exposer&#123;exposed=true, md5=&apos;bf204e2683e7452aa7db1a50b5713bae&apos;, seckillId=1000, now=0, start=0, end=0&#125;</span><br></pre></td></tr></table></figure></p>
<p>可知开启了id为1000的商品的秒杀，并给我们输出了该商品的秒杀地址。而第四个方法的测试就需要传入该地址让用户得到才能判断该用户是否秒杀到该地址的商品，然后进行第四个方法的测试,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeSeckill</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> seckillId=<span class="number">1000</span>;</span><br><span class="line">      <span class="keyword">long</span> userPhone=<span class="number">13476191876L</span>;</span><br><span class="line">      String md5=<span class="string">"bf204e2683e7452aa7db1a50b5713bae"</span>;</span><br><span class="line"></span><br><span class="line">      SeckillExecution seckillExecution=seckillService.executeSeckill(seckillId,userPhone,md5);</span><br><span class="line"></span><br><span class="line">      System.out.println(seckillExecution);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出信息:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SeckillExecution&#123;seckillId=1000, state=1, stateInfo=&apos;秒杀成功&apos;, successKilled=SuccessKilled&#123;seckillId=1000, userPhone=13476191876, state=0, createTime=Mon Nov 28 16:45:38 CST 2016&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>证明电话为13476191876的用户成功秒杀到了该商品，查看数据库，该用户秒杀商品的明细信息已经被插入明细表，说明我们的业务逻辑没有问题。但其实这样写测试方法还有点问题，此时再次执行该方法，控制台报错，因为用户重复秒杀了。我们应该在该测试方法中添加try catch,将程序允许的异常包起来而不去向上抛给junit，更改测试代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeSeckill</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">long</span> seckillId=<span class="number">1000</span>;</span><br><span class="line">     <span class="keyword">long</span> userPhone=<span class="number">13476191876L</span>;</span><br><span class="line">     String md5=<span class="string">"bf204e2683e7452aa7db1a50b5713bae"</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         SeckillExecution seckillExecution = seckillService.executeSeckill(seckillId, userPhone, md5);</span><br><span class="line"></span><br><span class="line">         System.out.println(seckillExecution);</span><br><span class="line">     &#125;<span class="keyword">catch</span> (RepeatKillException e)</span><br><span class="line">     &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;<span class="keyword">catch</span> (SeckillCloseException e1)</span><br><span class="line">     &#123;</span><br><span class="line">         e1.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样再测试该方法，junit便不会再在控制台中报错，而是认为这是我们系统允许出现的异常。由上分析可知，第四个方法只有拿到了第三个方法暴露的秒杀商品的地址后才能进行测试，也就是说只有在第三个方法运行后才能运行测试第四个方法，而实际开发中我们不是这样的，需要将第三个测试方法和第四个方法合并到一个方法从而组成一个完整的逻辑流程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span><span class="comment">//完整逻辑代码测试，注意可重复执行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSeckillLogic</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> seckillId=<span class="number">1000</span>;</span><br><span class="line">        Exposer exposer=seckillService.exportSeckillUrl(seckillId);</span><br><span class="line">        <span class="keyword">if</span> (exposer.isExposed())</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(exposer);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> userPhone=<span class="number">13476191876L</span>;</span><br><span class="line">            String md5=exposer.getMd5();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                SeckillExecution seckillExecution = seckillService.executeSeckill(seckillId, userPhone, md5);</span><br><span class="line">                System.out.println(seckillExecution);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (RepeatKillException e)</span><br><span class="line">            &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SeckillCloseException e1)</span><br><span class="line">            &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//秒杀未开启</span></span><br><span class="line">            System.out.println(exposer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该测试类，控制台成功输出信息，库存会减少，明细表也会增加内容。重复执行，控制台不会报错，只是会抛出一个允许的重复秒杀异常。  </p>
<p>目前为止，Dao层和Service层的集成测试我们都已经完成，接下来进行Web层的开发编码工作，请查看我的下篇文章<a href="http://codingxiaxw.cn/2016/11/28/55-seckill-web/">Java高并发秒杀API之Web层开发</a>。  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java高并发秒杀系统API(一)之DAO层开发]]></title>
      <url>http://codingxiaxw.cn/2016/11/27/53-maven-ssm-seckill-dao/</url>
      <content type="html"><![CDATA[<p>之前写了一个用<a href="http://codingxiaxw.cn/2016/11/15/45-smm%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">SSM框架搭建的商品查询系统</a>,分两篇文章分别记录了自己整合SSM框架的过程以及利用SSM开发的一些基础知识，由于那时候刚学完SSM框架，所以自己觉得整合的过程总结的不够好。<a id="more"></a>如今在有了一定的SSM框架开发经验后打算针对慕课网上对秒杀系统的讲解视频再写一个用Maven+SSM做的秒杀系统的文字讲解，从头到位记录自己整合SSM框架以及用SSM框架开发这个秒杀系统的过程。  </p>
<p>为什么要用maven?这个工具真是让你用了以后就爱不释手。这样给你简单的说说maven,它的强大之处就是你不用再像以前那样，如果在项目中用到spring框架还要到spring官网上去下载一系列的jar包，用了maven对项目进行管理之后你就可以直接在它的pom.xml文件中添加jar包的相应坐标，这样maven就能自动从它的中央仓库中为我们将这些jar包下载到其本地仓库中供我们使用。  </p>
<p>用maven对项目进行管理的知识很简单，关于创建maven项目的知识大家看我的这篇文章便可以在几分钟内掌握:<a href="http://codingxiaxw.cn/2016/11/24/51-first-maven-project/">Maven安装配置及创建你的第一个Maven项目</a>  </p>
<p>秒杀系统搭建环境:IDEA+Maven+SSM框架。源码<a href="https://github.com/codingXiaxw/seckill" target="_blank" rel="external">请点击这里</a>前往我的github。  </p>
<p>完成这个秒杀系统，需要完成四个模块的代码编写，分别是:  </p>
<ul>
<li>1.<a href="http://codingxiaxw.cn/2016/11/27/53-maven-ssm-seckill-dao/">Java高并发秒杀APi之业务分析与DAO层代码编写</a>。</li>
<li>2.<a href="http://codingxiaxw.cn/2016/11/28/54-seckill-service/">Java高并发秒杀APi之Service层代码编写</a>。</li>
<li>3.<a href="http://codingxiaxw.cn/2016/11/28/55-seckill-web/">Java高并发秒杀APi之Web层代码编写</a>。</li>
</ul>
<p>其实完成这三个模块就可以完成我们的秒杀系统了，但对于我们的秒杀系统中一件秒杀商品，在秒杀的时候肯定会有成千上万的用户参与进来，通过上述三个模块完成的系统无法解决这么多用户的高并发操作，所以我们还需要第四个模块:  </p>
<ul>
<li>4.<a href="">Java高并发秒杀APi之高并发优化(待更新)</a>。</li>
</ul>
<p>该系统我将按照上述4个模块通过4篇文章来完成介绍，本篇文章进行第一个模块的讲解及项目的介绍以及Dao层编码的开发。首先看看我们项目的效果图:  </p>
<p>列表页:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%883.24.50.png" alt="">  </p>
<p>详情页:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%883.25.39.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%883.25.22.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%883.25.48.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%883.26.16.png" alt="">  </p>
<p>接下来我将从如何用maven创建我们的秒杀系统seckill项目开始到完成我们的秒杀系统，详细介绍自己完成它的过程。  </p>
<h2 id="1-相关技术介绍"><a href="#1-相关技术介绍" class="headerlink" title="1.相关技术介绍"></a>1.相关技术介绍</h2><p><strong>MySQL:</strong>1.这里我们采用手写代码创建相关表，掌握这种能力对我们以后的项目二次上线会有很大的帮助；2.SQL技巧；3.事务和行级锁的理解和一些应用。  </p>
<p><strong>MyBatis:</strong>1.DAO层的设计与开发。2.MyBatis的合理使用，使用Mapper动态代理的方式进行数据库的访问。3.MyBatis和Spring框架的整合:如何高效的去整合MyBatis和Spring框架。  </p>
<p><strong>Spring:</strong>1.Spring IOC帮我们整合Service以及Service所有的依赖。2.声明式事务。对Spring声明式事务做一些分析以及它的行为分析。  </p>
<p><strong>Spring MVC:</strong>1.Restful接口设计和使用。Restful现在更多的被应用在一些互联网公司Web层接口的应用上。2.框架运作流程。3.Spring Controller的使用技巧。  </p>
<p><strong>前端:</strong>1.交互设计。2.bootstrap。3.JQuery。设计到前端的页面代码我们直接拷贝即可，毕竟真正开发中这样一个项目是由产品经理、前端工程师、后端工程师一起完成的。  </p>
<p><strong>高并发:</strong>1.高并发点和高并发分析。2.优化思路并实现。  </p>
<p>下面开始我们的项目的开发。  </p>
<h2 id="2-Java高并发秒杀APi之业务分析与DAO层代码编写"><a href="#2-Java高并发秒杀APi之业务分析与DAO层代码编写" class="headerlink" title="2.Java高并发秒杀APi之业务分析与DAO层代码编写"></a>2.Java高并发秒杀APi之业务分析与DAO层代码编写</h2><h3 id="2-1用Maven创建我们的项目seckill"><a href="#2-1用Maven创建我们的项目seckill" class="headerlink" title="2.1用Maven创建我们的项目seckill"></a>2.1用Maven创建我们的项目seckill</h3><p>在命令行中输入如下命令:  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.codingxiaxw.seckill -DartifactId=seckill -Dpackage=cn.codingxiaxw.seckill -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure>
<p>然后使用IDEA打开该项目，在IDEA中对项目按照Maven项目的标准骨架补全我们项目的相应文件包，最后的工程结构如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%883.53.43.png" width="50%">   </p>
<p>main包下进行我们项目的代码编写及相关配置文件，test包下进行我们项目的测试。  </p>
<p>打开WEB-INF下的web.xml，它默认为我们创建servlet版本为2.3，需要修改它的根标签为:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span><br><span class="line">                      http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span><br><span class="line">         <span class="attr">version</span>=<span class="string">"3.0"</span></span><br><span class="line">         <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--用maven创建的web-app需要修改servlet的版本为3.0--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后打开pom.xml，在里面添加我们需要的第三方jar包的坐标配置信息，如SSM框架、数据库、日志，如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.codingxiaxw.seckill<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>seckill<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>seckill Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--3.0的junit是使用编程的方式来进行测试，而junit4是使用注解的方式来运行junit--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--补全项目依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.日志 java日志有:slf4j,log4j,logback,common-logging</span><br><span class="line">        slf4j:是规范/接口</span><br><span class="line">        日志实现:log4j,logback,common-logging</span><br><span class="line">        使用:slf4j+logback</span><br><span class="line">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--实现slf4j接口并整合--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1.数据库相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.35<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.dao框架:MyBatis依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--mybatis自身实现的spring整合依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3.Servlet web相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--4:spring依赖--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1)spring核心依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2)spring dao层依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3)springweb相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4)spring test相关依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>seckill<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>到此，我们项目的初始化工作完成。  </p>
<h3 id="2-2秒杀系统业务分析"><a href="#2-2秒杀系统业务分析" class="headerlink" title="2.2秒杀系统业务分析"></a>2.2秒杀系统业务分析</h3><p>秒杀系统业务流程如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%884.07.38.png" alt="">  </p>
<p>由图可以发现，整个系统其实是针对库存做的系统。用户成功秒杀商品，对于我们系统的操作就是:1.减库存。2.记录用户的购买明细。下面看看我们用户对库存的业务分析:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%884.09.29.png" alt="">  </p>
<p>记录用户的秒杀成功信息，我们需要记录:1.谁购买成功了。2.购买成功的时间/有效期。3.付款/发货信息。这些数据组成了用户的秒杀成功信息，也就是用户的购买行为。  </p>
<p>为什么我们的系统需要事务?看如下这些故障:1.若是用户成功秒杀商品我们记录了其购买明细却没有减库存。导致商品的超卖。2.减了库存却没有记录用户的购买明细。导致商品的少卖。对于上述两个故障，若是没有事务的支持，损失最大的无疑是我们的用户和商家。在MySQL中，它内置的事务机制，可以准确的帮我们完成减库存和记录用户购买明细的过程。  </p>
<p>MySQL实现秒杀的难点分析:当用户A秒杀id为10的商品时，此时MySQL需要进行的操作是:1.开启事务。2.更新商品的库存信息。3.添加用户的购买明细，包括用户秒杀的商品id以及唯一标识用户身份的信息如电话号码等。4.提交事务。若此时有另一个用户B也在秒杀这件id为10的商品，他就需要等待，等待到用户A成功秒杀到这件商品然后MySQL成功的提交了事务他才能拿到这个id为10的商品的锁从而进行秒杀，而同一时间是不可能只有用户B在等待，肯定是有很多很多的用户都在等待拿到这个行级锁。秒杀的难点就在这里，如何高效的处理这些竞争？如何高效的完成事务?在后面第4个模块如何进行高并发的优化为大家讲解。  </p>
<p>我们这个系统需要完成秒杀的哪些功能?先来看看天猫的一个秒杀库存系统:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-27%20%E4%B8%8B%E5%8D%884.30.36.png" alt="">  </p>
<p>大家看了是不是觉得很复杂?当然不用担心，我们只是实现秒杀的一些功能:1.秒杀接口的暴露。2.执行秒杀的操作。3.相关查询，比如说列表查询，详情页查询。我们实现这三个功能即可。接下来进行具体的编码工作，首先是Dao层的编码。  </p>
<h3 id="2-3Dao层设计开发"><a href="#2-3Dao层设计开发" class="headerlink" title="2.3Dao层设计开发"></a>2.3Dao层设计开发</h3><p>首先创建数据库，相关表的sql语句我在main包下的sql包中已经给出。  </p>
<p>然后创建对应表的实体类，在java包下创建cn.codingxiaxw.entity包，创建一个Seckill.java实体类，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Seckill</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seckillId;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> Date startTime;</span><br><span class="line">    <span class="keyword">private</span> Date endTime;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSeckillId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeckillId</span><span class="params">(<span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNumber</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getStartTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStartTime</span><span class="params">(Date startTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.startTime = startTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getEndTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> endTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEndTime</span><span class="params">(Date endTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.endTime = endTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateTime</span><span class="params">(Date createTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Seckill&#123;"</span> +</span><br><span class="line">                <span class="string">"seckillId="</span> + seckillId +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", number="</span> + number +</span><br><span class="line">                <span class="string">", startTime="</span> + startTime +</span><br><span class="line">                <span class="string">", endTime="</span> + endTime +</span><br><span class="line">                <span class="string">", createTime="</span> + createTime +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和一个SuccessKilled.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccessKilled</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> seckillId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userPhone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">short</span> state;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多对一，因为一件商品在库存中有很多数量，对应的购买明细也有很多。</span></span><br><span class="line">    <span class="keyword">private</span> Seckill seckill;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getSeckillId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeckillId</span><span class="params">(<span class="keyword">long</span> seckillId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckillId = seckillId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getUserPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userPhone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserPhone</span><span class="params">(<span class="keyword">long</span> userPhone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userPhone = userPhone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">short</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">short</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getCreateTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCreateTime</span><span class="params">(Date createTime)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.createTime = createTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Seckill <span class="title">getSeckill</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seckill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeckill</span><span class="params">(Seckill seckill)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seckill = seckill;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SuccessKilled&#123;"</span> +</span><br><span class="line">                <span class="string">"seckillId="</span> + seckillId +</span><br><span class="line">                <span class="string">", userPhone="</span> + userPhone +</span><br><span class="line">                <span class="string">", state="</span> + state +</span><br><span class="line">                <span class="string">", createTime="</span> + createTime +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后针对实体创建出对应dao层的接口，在cn.codingxiaxw.dao包下创建Seckill.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SeckillDao</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 减库存</span><br><span class="line">     * <span class="doctag">@param</span> seckillId</span><br><span class="line">     * <span class="doctag">@param</span> killTime</span><br><span class="line">     * <span class="doctag">@return</span> 如果影响行数&gt;1，表示更新库存的记录行数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reduceNumber</span><span class="params">(<span class="keyword">long</span> seckillId, Date killTime)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据id查询秒杀的商品信息</span><br><span class="line">     * <span class="doctag">@param</span> seckillId</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">Seckill <span class="title">queryById</span><span class="params">(<span class="keyword">long</span> seckillId)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据偏移量查询秒杀商品列表</span><br><span class="line">     * <span class="doctag">@param</span> off</span><br><span class="line">     * <span class="doctag">@param</span> limit</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">List&lt;Seckill&gt; <span class="title">queryAll</span><span class="params">(<span class="keyword">int</span> off,<span class="keyword">int</span> limit)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和SuccessKilled.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuccessKilledDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 插入购买明细,可过滤重复</span><br><span class="line">     * <span class="doctag">@param</span> seckillId</span><br><span class="line">     * <span class="doctag">@param</span> userPhone</span><br><span class="line">     * <span class="doctag">@return</span>插入的行数</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertSuccessKilled</span><span class="params">(<span class="keyword">long</span> seckillId,<span class="keyword">long</span> userPhone)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据秒杀商品的id查询明细SuccessKilled对象(该对象携带了Seckill秒杀产品对象)</span><br><span class="line">     * <span class="doctag">@param</span> seckillId</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">SuccessKilled <span class="title">queryByIdWithSeckill</span><span class="params">(<span class="keyword">long</span> seckillId,<span class="keyword">long</span> userPhone)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来基于MyBatis来实现我们之前设计的Dao层接口。首先需要配置我们的MyBatis，在resources包下创建MyBatis全局配置文件mybatis-config.xml文件，在浏览器中输入<code>http://mybatis.github.io/mybatis-3/zh/index.html</code>打开MyBatis的官网文档，点击左边的”入门”栏框，找到mybatis全局配置文件，在这里有xml的一个规范，也就是它的一个xml约束，拷贝:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span><br><span class="line">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>到我们的项目mybatis全局配置文件中，然后在全局配置文件中加入如下配置信息:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span><br><span class="line">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置全局属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用jdbc的getGeneratekeys获取自增主键值--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--使用列别名替换列名　　默认值为true</span><br><span class="line">        select name as title(实体中的属性名是title) form table;</span><br><span class="line">        开启后mybatis会自动帮我们把表中name的值赋到对应实体的title属性中</span><br><span class="line">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--开启驼峰命名转换Table:create_time到 Entity(createTime)--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置文件创建好后我们需要关注的是Dao接口该如何实现，mybatis为我们提供了mapper动态代理开发的方式为我们自动实现Dao的接口。在mapper包下创建对应Dao接口的xml映射文件，里面用于编写我们操作数据库的sql语句，SeckillDao.xml和SuccessKilledDao.xml。既然又是一个xml文件，我们肯定需要它的dtd文件，在官方文档中，点击左侧”XML配置”，在它的一些事例中，找到它的xml约束:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span><br><span class="line">    PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span><br><span class="line">    "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>加入到两个mapper映射xml文件中，然后对照Dao层方法编写我们的映射文件内容如下:  </p>
<p>SeckillDao.xml:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span><br><span class="line">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.codingxiaxw.dao.SeckillDao"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的:为dao接口方法提供sql语句配置</span><br><span class="line">    即针对dao接口中的方法编写我们的sql语句--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"reduceNumber"</span>&gt;</span></span><br><span class="line">        UPDATE seckill</span><br><span class="line">        SET number = number-1</span><br><span class="line">        WHERE seckill_id=#&#123;seckillId&#125;</span><br><span class="line">        AND start_time &lt;![CDATA[ &lt;= ]]&gt; #&#123;killTime&#125;</span><br><span class="line">        AND end_time &gt;= #&#123;killTime&#125;</span><br><span class="line">        AND number &gt; 0;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryById"</span> <span class="attr">resultType</span>=<span class="string">"Seckill"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">        SELECT *</span><br><span class="line">        FROM seckill</span><br><span class="line">        WHERE seckill_id=#&#123;seckillId&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryAll"</span> <span class="attr">resultType</span>=<span class="string">"Seckill"</span>&gt;</span></span><br><span class="line">        SELECT *</span><br><span class="line">        FROM seckill</span><br><span class="line">        ORDER BY create_time DESC</span><br><span class="line">        limit #&#123;offset&#125;,#&#123;limit&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>SuccessKilledDao.xml:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span><br><span class="line">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.codingxiaxw.dao.SuccessKilledDao"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertSuccessKilled"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当出现主键冲突时(即重复秒杀时)，会报错;不想让程序报错，加入ignore--&gt;</span></span><br><span class="line">        INSERT ignore INTO success_killed(seckill_id,user_phone,state)</span><br><span class="line">        VALUES (#&#123;seckillId&#125;,#&#123;userPhone&#125;,0)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryByIdWithSeckill"</span> <span class="attr">resultType</span>=<span class="string">"SuccessKilled"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--根据seckillId查询SuccessKilled对象，并携带Seckill对象--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--如何告诉mybatis把结果映射到SuccessKill属性同时映射到Seckill属性--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以自由控制SQL语句--&gt;</span></span><br><span class="line">        SELECT</span><br><span class="line">            sk.seckill_id,</span><br><span class="line">            sk.user_phone,</span><br><span class="line">            sk.create_time,</span><br><span class="line">            sk.state,</span><br><span class="line">            s.seckill_id "seckill.seckill_id",</span><br><span class="line">            s.name "seckill.name",</span><br><span class="line">            s.number "seckill",</span><br><span class="line">            s.start_time "seckill.start_time",</span><br><span class="line">            s.end_time "seckill.end_time",</span><br><span class="line">            s.create_time "seckill.create_time"</span><br><span class="line">        FROM success_killed sk</span><br><span class="line">        INNER JOIN seckill s ON sk.seckill_id=s.seckill_id</span><br><span class="line">        WHERE sk.seckill_id=#&#123;seckillId&#125;</span><br><span class="line">        AND sk.user_phone=#&#123;userPhone&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来我们开始MyBatis和Spring的整合，整合目标:1.更少的编码:只写接口，不写实现类。2.更少的配置:别名、配置扫描映射xml文件、dao实现。3.足够的灵活性:自由定制SQL语句、自由传结果集自动赋值。  </p>
<p>在resources包下创建一个spring包，里面放置spring对Dao、Service、transaction的配置文件。在浏览器中输入<code>http://docs.spring.io/spring/docs/</code>进入到Spring的官网中下载其pdf官方文档，在其官方文档中找到它的xml的定义内容头部:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在spring包下创建一个spring配置dao层对象的配置文件spring-dao.xml，加入上述dtd约束，然后添加二者整合的配置，内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置整合mybatis过程</span><br><span class="line">    1.配置数据库相关参数--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置连接池属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 基本属性 url、user、password --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--c3p0私有属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"30"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关闭连接后不自动commit--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoCommitOnClose"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--获取连接超时时间--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span> <span class="attr">value</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--当获取连接失败重试次数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireRetryAttempts"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--约定大于配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--３.配置SqlSessionFactory对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--往下才是mybatis和spring真正整合的配置--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据库连接池--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置mybatis全局配置文件:mybatis-config.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--扫描entity包,使用别名,多个用;隔开--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"typeAliasesPackage"</span> <span class="attr">value</span>=<span class="string">"cn.codingxiaxw.entity"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--扫描sql配置文件:mapper需要的xml文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mapper/*.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--４:配置扫描Dao接口包,动态实现DAO接口,注入到spring容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入SqlSessionFactory--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 给出需要扫描的Dao接口--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"cn.codingxiaxw.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要我们在resources包下创建jdbc.properties用于配置数据库的连接信息，内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driver=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/seckill?useUnicode=true&amp;characterEncoding=utf-8</span><br><span class="line">username=root</span><br><span class="line">password=xiaxunwu1996.</span><br></pre></td></tr></table></figure></p>
<p>这样我们便完成了Dao层编码的开发，接下来就可以利用junit进行我们Dao层编码的测试了。首先测试SeckillDao.java，利用IDEA快捷键<code>shift+command+T</code>对SeckillDao.java进行测试，然后IDEA会自动在test包的java包下为我们生成对SeckillDao.java中所有方法的测试类SeckillDaoTest.java,内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceNumber</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后便可以在这个测试类中对SeckillDao接口的所有方法进行测试了,先测试queryById()方法，在该方法中添加内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by codingBoy on 16/11/27.</span><br><span class="line"> * 配置spring和junit整合，这样junit在启动时就会加载spring容器</span><br><span class="line"> */</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="comment">//告诉junit spring的配置文件</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(&#123;<span class="string">"classpath:spring/spring-dao.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeckillDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入Dao实现类依赖</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SeckillDao seckillDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryById</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> seckillId=<span class="number">1000</span>;</span><br><span class="line">        Seckill seckill=seckillDao.queryById(seckillId);</span><br><span class="line">        System.out.println(seckill.getName());</span><br><span class="line">        System.out.println(seckill);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>右键选择”debug queryById()”，测试台成功输入该id为1000的商品信息，证明Dao的该方法正确，然后测试queryAll()方法，在该方法中添加如下内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryAll</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       List&lt;Seckill&gt; seckills=seckillDao.queryAll(<span class="number">0</span>,<span class="number">100</span>);</span><br><span class="line">       <span class="keyword">for</span> (Seckill seckill : seckills)</span><br><span class="line">       &#123;</span><br><span class="line">           System.out.println(seckill);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后运行该方法，程序报错，报错信息如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.ibatis.binding.BindingException: Parameter &apos;offset&apos; not found. Available parameters are [1, 0, param1, param2]</span><br></pre></td></tr></table></figure></p>
<p>意思就是无法完成offset参数的绑定，这也是我们java编程语言的一个问题，也就是java没有保存行参的记录，java在运行的时候会把<code>List&lt;Seckill&gt; queryAll(int offset,int limit);</code>中的参数变成这样:<code>queryAll(int arg0,int arg1)</code>,这样我们就没有办法去传递多个参数。需要在SeckillDao接口中修改方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Seckill&gt; <span class="title">queryAll</span><span class="params">(@Param(<span class="string">"offset"</span>)</span> <span class="keyword">int</span> offset,@<span class="title">Param</span><span class="params">(<span class="string">"limit"</span>)</span> <span class="keyword">int</span> limit)</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样才能使我们的MyBatis识别offset和limit两个参数，将Dao层方法中的这两个参数与xml映射文件中sql语句的传入参数完成映射。然后重新测试，发现测试通过。然后测试reduceNumber()方法，在该方法中加入如下内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduceNumber</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> seckillId=<span class="number">1000</span>;</span><br><span class="line">      Date date=<span class="keyword">new</span> Date();</span><br><span class="line">      <span class="keyword">int</span> updateCount=seckillDao.reduceNumber(seckillId,date);</span><br><span class="line">      System.out.println(updateCount);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行该方法，报错:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.apache.ibatis.binding.BindingException: Parameter &apos;seckillId&apos; not found. Available parameters are [1, 0, param1, param2]</span><br></pre></td></tr></table></figure></p>
<p>发现依然是我们之前那个错误，更改SeckillDao接口的reduceNumber()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reduceNumber</span><span class="params">(@Param(<span class="string">"seckillId"</span>)</span> <span class="keyword">long</span> seckillId, @<span class="title">Param</span><span class="params">(<span class="string">"killTime"</span>)</span> Date killTime)</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后重新运行，测试通过，可是我们查询数据库发现该库存表的商品数量没有减少，是因为我们当前时间没有达到秒杀商品要求的时间，所以不会成功秒杀。接下来进行SuccessKilledDao接口相关方法的测试，依旧使用IDEA快捷键<code>shift+command+T</code>快速生成其方法的相应测试类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccessKilledDaoTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSuccessKilled</span><span class="params">()</span> <span class="keyword">throws</span> Exception 	</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryByIdWithSeckill</span><span class="params">()</span> <span class="keyword">throws</span> Exception 	</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>依然要在SuccessKilledDao的方法中用@Param注解完成参数的绑定，首先完成insertSuccessKilled()的测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="comment">//告诉junit spring的配置文件</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(&#123;<span class="string">"classpath:spring/spring-dao.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuccessKilledDaoTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> SuccessKilledDao successKilledDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertSuccessKilled</span><span class="params">()</span> <span class="keyword">throws</span> Exception 	</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> seckillId=<span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">long</span> userPhone=<span class="number">13476191877L</span>;</span><br><span class="line">        <span class="keyword">int</span> insertCount=successKilledDao.insertSuccessKilled(seckillId,userPhone);</span><br><span class="line">        System.out.println(<span class="string">"insertCount="</span>+insertCount);</span><br><span class="line">    &#125;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure></p>
<p>运行成功，测试台打印出insertCount=1的信息，即我们修改了表中的一条记录，这时查看秒杀成功明细表，发现该用户的信息已经被插入。然后再次运行该测试方法，程序没有报主键异常的错，是因为我们在编写我们的明细表的时候添加了一个联合主键的字段，它保证我们明细表中的seckillId和userPhone不能重复插入，另外在SuccessDao.xml中写的插入语句的ignore关键字也保证了这点。控制台输出0，表示没有对明细表做插入操作。然后进行queryByIdWithSeckill()方法的测试,需要在Dao层的方法中添加@Param注解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SuccessKilled <span class="title">queryByIdWithSeckill</span><span class="params">(@Param(<span class="string">"seckillId"</span>)</span> <span class="keyword">long</span> seckillId,@<span class="title">Param</span><span class="params">(<span class="string">"userPhone"</span>)</span> <span class="keyword">long</span> userPhone)</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后进行该方法的测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryByIdWithSeckill</span><span class="params">()</span> <span class="keyword">throws</span> Exception 	</span>&#123;</span><br><span class="line">        <span class="keyword">long</span> seckillId=<span class="number">1000L</span>;</span><br><span class="line">        <span class="keyword">long</span> userPhone=<span class="number">13476191877L</span>;</span><br><span class="line">        SuccessKilled successKilled=successKilledDao.queryByIdWithSeckill(seckillId,userPhone);</span><br><span class="line">        System.out.println(successKilled);</span><br><span class="line">        System.out.println(successKilled.getSeckill());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行，成功查询出我们明细表中id为1000且手机号码为13476191877的用户信息，并将表中对应的信息映射到SuccessKilled对象和Seckill对象的属性中。  </p>
<p>到此，我们成功完成了Dao层开发及测试，接下来我们将进行Service层的开发工作，请查看我的下篇文章<a href="http://codingxiaxw.cn/2016/11/28/54-seckill-service/">Java高并发秒杀API之Service层开发</a></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven核心知识]]></title>
      <url>http://codingxiaxw.cn/2016/11/26/52-Maven-core-knowledge/</url>
      <content type="html"><![CDATA[<p>上篇文章介绍了<a href="http://codingxiaxw.cn/2016/11/24/51-first-maven-project/">Maven的安装、配置及创建自己的第一个Maven项目</a>的两种方式。在往后的开发中我们需要用到Maven对我们的项目进行管理以简化项目开发过程，具体就是当我们的项目需要导入哪个第三方jar包时直接在Maven为我们生成的的pom.xml文件中添加相关jar包依赖就行。<a id="more"></a>接下来我想有必要总结一下学习Maven的相关核心知识，以方便大家对Maven有更好的了解。  </p>
<h2 id="1-maven常用构建命令-了解"><a href="#1-maven常用构建命令-了解" class="headerlink" title="1.maven常用构建命令(了解)"></a>1.maven常用构建命令(了解)</h2><ul>
<li><code>mvn -v</code>:查看maven的版本。</li>
<li><code>mvn compile</code>:编译项目。项目经过编译后会在根目录下生成一个target包(跟src包在同一目录下)，里面保存的是编译项目时字节码文件和测试报告。</li>
<li><code>mvn test</code>:测试。此命令在项目目录下</li>
<li><code>mvn package</code>:打包我们的项目。</li>
<li><code>mvn clean</code>:删除上述经过编译后生成的target包。</li>
<li><code>mvn install</code>:将我们的项目打包到本地仓库中。例如将A项目用该命令打包到本地仓库后，就可以在B项目的pom.xml文件中配置A项目的坐标来让B项目引用A项目，见下文仓库的讲解。</li>
</ul>
<p>只有第一个命令<code>mvn -v</code>是在根目录下执行，其他5个命令都是在我们的maven项目包下执行的。</p>
<p>上述知识只做了解，在实际开发中基本没有用到上述命令。  </p>
<h2 id="2-maven自动构件骨架"><a href="#2-maven自动构件骨架" class="headerlink" title="2.maven自动构件骨架"></a>2.maven自动构件骨架</h2><p>我在<a href="http://codingxiaxw.cn/2016/11/24/51-first-maven-project/">创建第一个Maven项目</a>中就有介绍过，让maven自动为我们的项目生成一个标准的骨架有两种方式，一种是通过命令行输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.codingxiaxw.helloword -DartifactId=helloworld -Dpackage=cn.codingxiaxw.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart</span><br></pre></td></tr></table></figure></p>
<p>或者:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.codingxiaxw.helloword -DartifactId=helloworld -Dpackage=cn.codingxiaxw.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></table></figure></p>
<p>第二种方式是使用IDEA开发工具为我们生成，步骤之前讲过，大家可以点击上述链接看我在那篇文章中的介绍。这里只对上述命令进行解释，如下:</p>
<ul>
<li><code>mvn</code>:表示使用的是maven命令。</li>
<li><code>archetype:generate</code>:表示使用generate这个插件为我们的maven项目自动生成一个maven骨架，即我们项目的工程结构(如下图)。后边跟的是该插件为我们创建工程结构所需要的一连串的参数。</li>
<li><code>-DgroupId</code>:标识项目的坐标元素之一，与DartifactId,Dpackaging,Dversion组成我们maven项目的坐标，四者唯一确定一个项目。它的值为我们的项目包名，我这里的格式用的我的博客网站后缀+我的用户名+项目名组成。</li>
<li><code>-DartifactId</code>:标识项目的坐标元素之一，它的值为我们的项目名。我这里指定我要生成的项目名为helloword。</li>
<li><code>-Dpackage</code>:标识项目的坐标元素之一,这里值就跟DgroupId的值保持一致即可。此属性在命令行中可选。</li>
<li><code>-Dversion</code>:指定版本号。此属性在命令行中可选</li>
<li><code>-DarchetypeArtifactId</code>:表示我们生成的工程结构为哪一种，这里的属性值为<code>maven-archetype-quickstart</code>表示生成工程目录结构为quickstart的结构。其值还可以为<code>maven-archetype-webapp</code>表示生成的工程目录结构为webapp型的结构。</li>
</ul>
<h2 id="3-maven中的坐标和仓库"><a href="#3-maven中的坐标和仓库" class="headerlink" title="3.maven中的坐标和仓库"></a>3.maven中的坐标和仓库</h2><h3 id="3-1坐标"><a href="#3-1坐标" class="headerlink" title="3.1坐标"></a>3.1坐标</h3><p>在maven的世界中，maven以构件来组成基本的控制单元，而定义这个构件的标示，maven给定义为“坐标”。坐标是maven最基本的概念，它就像每个构件的身份证号码，有了它我们就可以在数以千万计的构件中定位任何一个我们感兴趣的构件。  </p>
<p>例如我们在上篇文章中通过maven命令生成的maven项目中，其pom.xml中有这样一些配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.codingxiaxw.helloword<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloword<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面这样四个xml元素即即组成了一个坐标，唯一标识我们创建的这个项目。  </p>
<p>再如若我们要在自己的项目中引入junit测试jar包，只需在pom.xml中配置如下junit的坐标:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>maven就会根据我们给出的junit的坐标在其中央仓库中为我们找到junit 的相关jar包，然后将其下载到自己的本地仓库中。这样我们便可以在自己的项目开发中运用junit类进行测试了。  </p>
<h3 id="3-2仓库"><a href="#3-2仓库" class="headerlink" title="3.2仓库"></a>3.2仓库</h3><p>上述我们已经提到了仓库，其实当我们在自己的电脑上成功安装maven后，就已经已经生成了一个本地仓库，可以在下列地址中找到:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/codingBoy/.m2/repository</span><br></pre></td></tr></table></figure></p>
<p>打开后发现里面全是各种本地仓库中的各种引用开发jar包，这里也能发现我们在pom.xml中配置的junit，可以发现已经下载到本地仓库里面了，如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-26%20%E4%B8%8B%E5%8D%8811.14.38.png" alt="">  </p>
<p>只要我们在pom.xml中配置了相关jar包的坐标，maven都会根据这个坐标自动将这些jar包下载在该目录(也就是maven的本地仓库)下供我们开发过程中的直接引用。  </p>
<p>既然有本地仓库，那么是不是还有个远程仓库的概念呢？答案是肯定的，这个远程仓库是个大仓库，叫做中央仓库，地址为:<code>https://repo.maven.apache.org/maven2</code>。感谢开源社区的贡献，在maven的中央仓库里几乎为我们下载了所有开发都需要的jar包，如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-26%20%E4%B8%8B%E5%8D%8811.31.10.png" alt=""></p>
<p>要是此时我们又创建了一个maven项目helloword2，而且需要在这个项目中引用helloword项目，只要将helloword项目打包到本地仓库，然后在helloword2项目的pom.xml文件中引入helloword的坐标即可。通过如下步骤:  </p>
<p>1.在命令行中输入命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先cd helloword</span><br><span class="line"></span><br><span class="line">然后mvn clean</span><br></pre></td></tr></table></figure></p>
<p>通过上述步骤清除helloword经过编译后生成的target包。  </p>
<p>2.输入:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn install</span><br></pre></td></tr></table></figure></p>
<p>将helloword项目打包并发布到本地仓库中。  </p>
<p>3.此时helloword2就可以根据坐标来引入helloword项目了，在helloword2的pom.xml文件中添加helloword的坐标:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.codingxiaxw.helloword<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>helloword<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样便完成了在一个项目中对另一个项目进行引用。  </p>
<h3 id="3-3坐标和仓库的关系"><a href="#3-3坐标和仓库的关系" class="headerlink" title="3.3坐标和仓库的关系"></a>3.3坐标和仓库的关系</h3><p>有了坐标，就知道在什么位置存储构件的内容，中央仓库也是一个样，上述例子中引用的junit的可以把它的坐标描述为：junit:junit:4.8.2，在中央仓库地址中打开对应的目录果然看到了Junit的jar包:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-26%20%E4%B8%8B%E5%8D%8811.39.56.png" alt="">  </p>
<p>有了正确的坐标,Maven才能够在正确的位置找到依赖文件并使用，上述pom.xml中为junit坐标设置的<code>&lt;scope&gt;</code>标签中的test值是用来控制该依赖只在测试时可用，与坐标无关。  </p>
<p>正因为坐标是Maven核心的核心，因此规划正确的坐标至关重要，如果你使用了模糊不清的坐标，那么你的用户就很难找到你的构件，或者即使找到了，也容易写错。错误的使用坐标，还会造成冲突，如果你也使用junit这样的groupId，那就悲剧了。</p>
<h2 id="4-生命周期和插件"><a href="#4-生命周期和插件" class="headerlink" title="4.生命周期和插件"></a>4.生命周期和插件</h2><p>Maven定义了三套生命周期：clean、default、site，每个生命周期都包含了一些阶段（phase）。三套生命周期相互独立，但各个生命 周期中的phase却是有顺序的，且后面的phase依赖于前面的phase。执行某个phase时，其前面的phase会依顺序执行，但不会触发另外两 套生命周期中的任何phase。  </p>
<ul>
<li>clean，做些清理的工作。</li>
<li>default，最核心的周期，做初始化和构建的工作，里面分的阶段很多，主要是compllie,test, package, install等。</li>
<li>site，生成站点的周期，包括生成文档和发布等。</li>
</ul>
<p>maven的生命周期是抽象的，实际需要插件来完成任务，这一过程是通过将插件的目标（goal）绑定到生命周期的具体阶段（phase）来完成的。这里就像设计模式中的模板模式，父类定义好了方法模板并规定对了执行顺序，而子类定义了每个模板方法具体要做的事情。这里的父类相当于maven，而子类就像是一个个的插件。  </p>
<p>比如compile这个阶段，对应的是mvn complie这个命令，但是实际上是maven-compiler-plugin这个插件在起作用。  </p>
<p>而install这个阶段,对应的mvn install命令，实际上是maven-install-plugin这个插件在起作用。  </p>
<h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>在实际开发中，我们用到Maven对我们的项目进行管理的地方，就是通过在pom.xml文件中添加所需第三方jar包的坐标让maven在中央仓库中找到相应的jar包资源然后下载到本地仓库中为我们使用。有了maven以后，我们在用到第三方jar包时就不需要再去网上找相关的jar包进行下载及导入到path环境中，maven为我们的项目开发进行了很好的管理。  </p>
<p>我后面会总结自己用maven+SSM框架进行一个秒杀系统开发的全过程，详情请点击<a href="http://codingxiaxw.cn/2016/11/27/53-maven-ssm-seckill-dao/">用Maven+SSM框架写一个秒杀系统教程</a></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="https://www.zhihu.com/people/xia-xun-wu-56/" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[mac系统下的Maven安装配置及创建你的第一个Maven项目]]></title>
      <url>http://codingxiaxw.cn/2016/11/24/51-first-maven-project/</url>
      <content type="html"><![CDATA[<p>我是在学完SSM框架的整合与基本开发后接触的Maven，它是一个项目管理的利器，网上也有说java后台的项目管理肯定要用到maven的。为什么要用maven?<a id="more"></a>在之前学习各个框架的时候，比如用Spring框架进行开发的时候要在项目中加入Spring的各个jar包及其依赖包;用MyBatis进行开发的时候要在项目中引入MyBatis的各个jar包。这样是不是太过于繁琐?而有了maven对项目进行管理，就简单多了。为什么简单多了?有了maven，这样当我们的项目需要哪个jar包时就可以直接在maven为我们生成的pom.xml文件中添加相关jar包依赖就行，而不需要导入那么多的jar包(可以看看我的这篇文章，用<a href="http://codingxiaxw.cn/2016/11/27/53-maven-ssm-seckill-dao/">用Maven+SSM框架写一个秒杀系统教程</a>，告诉你maven是如何进行项目管理的)，而本篇文章只是教大家如何安装Maven及如何快速入门创建一个Maven项目。  </p>
<p><strong>写在前面的话:</strong>此篇文章教程是在IntelliJ IDEA中搭建的maven项目。(建议eclipse党快点转IDEA吧，IDEA大法好。逃…   </p>
<h2 id="1-maven的安装"><a href="#1-maven的安装" class="headerlink" title="1.maven的安装"></a>1.maven的安装</h2><p>前往<a href="https://maven.apache.org/download.cgi" target="_blank" rel="external">Apache Maven官网</a>点击<code>apache-maven-3.3.9-bin.zip</code>链接下载3.3.9的版本即可。下载后我将该目录放到/Users/codingBoy/的目录下，文件名为apache-maven-3.3.9。这样我们便成功安装好maven管理工具，但这还不够，还需要设置maven环境变量。  </p>
<h2 id="2-配置maven环境变量"><a href="#2-配置maven环境变量" class="headerlink" title="2.配置maven环境变量"></a>2.配置maven环境变量</h2><p>打开终端，退到根目录<code>/Users/codingBoy/</code>，输入命令:<code>$ vi ~/.bash_profile</code>打开bash_profile文件,然后添加如下两行代码:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export M2_HOME=/Users/codingBoy/apache-maven-3.3.9</span><br><span class="line">export PATH=$PATH:$M2_HOME/bin</span><br></pre></td></tr></table></figure></p>
<p>然后继续退回到根目录，输入<code>$ source ~/.bash_profile</code>使bash_profile文件添加的内容即刻生效。  </p>
<p>接下来在终端输入<code>mvn -v</code>,若出现如下内容，说明你的maven管理工具成功安装并成功配置:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%885.06.54.png" alt="">  </p>
<p>到此，Maven在mac系统下的安装和配置即完成。接下来讲解用maven进行项目管理的一些基础知识。  </p>
<h2 id="3-创建第一个maven项目"><a href="#3-创建第一个maven项目" class="headerlink" title="3.创建第一个maven项目"></a>3.创建第一个maven项目</h2><p>创建maven项目有两种方式，第一种是用命令行输入代码、运行即可生成；第二种是直接用IDEA创建web项目时选择创建maven的web项目即可(IDEA相比eclipse的第一个优点在此就显露:IDEA已经集成maven插件，所以我们可以直接在IDEA中创建maven项目；而eclipse中我们还要进行下载maven插件等一系列操作，简直不能再繁琐。)。 这里我们先介绍第一种在终端输入命令的方式创建maven项目。  </p>
<h3 id="3-1使用命令行创建Maven项目"><a href="#3-1使用命令行创建Maven项目" class="headerlink" title="3.1使用命令行创建Maven项目"></a>3.1使用命令行创建Maven项目</h3><p>在终端的根目录下输入如下命令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate -DgroupId=cn.codingxiaxw.helloword -DartifactId=helloworld -Dpackage=cn.codingxiaxw.helloword -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-quickstart</span><br></pre></td></tr></table></figure></p>
<p>命令解释如下:</p>
<ul>
<li><code>mvn</code>:表示使用的是maven命令。</li>
<li><code>archetype:generate</code>:表示使用generate这个插件为我们的maven项目自动生成一个maven骨架，即我们项目的工程结构(如下图)。后边跟的是该插件为我们创建工程结构所需要的一连串的参数。</li>
<li><code>-DgroupId</code>:标识项目的坐标元素之一，与DartifactId,Dpackaging,Dversion组成我们maven项目的坐标，四者唯一确定一个项目。它的值为我们的项目包名，我这里的格式用的我的博客网站后缀+我的用户名+项目名组成。</li>
<li><code>-DartifactId</code>:标识项目的坐标元素之一，它的值为我们的项目名。我这里指定我要生成的项目名为helloword。</li>
<li><code>-Dpackage</code>:标识项目的坐标元素之一,这里值就跟DgroupId的值保持一致即可。此属性在命令行中可选。</li>
<li><code>-Dversion</code>:指定版本号。此属性在命令行中可选</li>
<li><code>-DarchetypeArtifactId</code>:表示我们生成的工程结构为哪一种，这里的属性值为<code>maven-archetype-quickstart</code>表示生成工程目录结构为quickstart的结构。其值还可以为<code>maven-archetype-webapp</code>表示生成的工程目录结构为webapp的结构。</li>
</ul>
<p>运行该命令，可看到终端中使用的maven命令自动为我们在下载maven的各个依赖包，执行命令的过程时间可能比较久，完成时间取决于个人网络状况。</p>
<p>完成后我们可以在自己的根目录下发现一个名为”helloword”项目名，说明我们成功在终端使用maven命令创建出一个maven项目，打开该helloword项目，会发现我们生成的maven项目的目录布局为这样的:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">helloword</span><br><span class="line">   |-src</span><br><span class="line">   |---main</span><br><span class="line">   |-----java</span><br><span class="line">   |-------cn</span><br><span class="line">   |---------codingxiaxw   </span><br><span class="line">   |-----------App.java</span><br><span class="line">   |---test|-----java</span><br><span class="line">   |-------cn</span><br><span class="line">   |---------codingxiaxw</span><br><span class="line">   |-----------AppTest.java</span><br><span class="line">   |-pom.xml</span><br></pre></td></tr></table></figure></p>
<p>没错，这就是我们通过命令行自动我们生成的maven项目的骨架，在maven项目的开发中，所有的源代码放在文件夹 <code>/src/main/java/</code>下, 所有的单元测试代码放入 <code>/src/test/java/</code>。可以参考官方网站的<a href="http://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html" target="_blank" rel="external">Maven标准目录</a> 附加的一个标准的pom.xml被生成。这个POM文件类似于Ant的build.xml文件，它描述了整个项目的信息，一切从目录结构、项目的插件、项目依赖、如何构建这个项目等，关于pom的介绍我会在下文中进行讲解，你也可以参考官方网站的<a href="http://maven.apache.org/guides/introduction/introduction-to-the-pom.html" target="_blank" rel="external">POM官方指南</a>  </p>
<p>然后我们便可以打开IDEA-Import Project操作导入helloword包下pom.xml一路next即可打开该maven项目。  </p>
<p>这样我们便使用第一种使用maven命令行的方式创建了我们的maven项目。  </p>
<h3 id="3-2使用IDEA创建Maven项目"><a href="#3-2使用IDEA创建Maven项目" class="headerlink" title="3.2使用IDEA创建Maven项目"></a>3.2使用IDEA创建Maven项目</h3><p>而第二种方式更加简单，只需打开IDEA-New Project，出现如下窗口:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%885.53.04.png" alt="">  </p>
<p>选择左边的maven项目，然后点击右边框框中的任意一种模版(根据选择的模版生成我们的项目工程目录结构，选择上面讲的webapp和quickstart都可，但是二者创建的目录结构是有差别的，我们先选择创建quickstart样式的模版，然后选择创建webapp样式的模版，对比一下二者的目录结构区别)即可next到这一步:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%885.48.07.png" alt="">  </p>
<p>填写我们的项目名和包名然后next到这一步:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%885.54.44.png" alt="">  </p>
<p>然后继续填写我们的项目名后，点击finish完成创建，这样我们便通过第二种方式直接用IDEA创建了我们的maven项目。创建的项目工程结构如图:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%885.58.13.png" width="50%" height="50%"></p>
<p>发现App.java和AppTest.java图标显示不对，因为它为我们自动生成的pop.xml文件中添加了依赖但是没有自动引入jar包，需要我们点击右下角(也许你的出现在左上角?)的<code>Enable Auto-Import</code>:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%885.58.10.png" alt="">  </p>
<p>然后我们的工程才算彻底搭建好，如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%886.01.54.png" width="50%" height="50%">  </p>
<p>如上是采用的生成工程目录的模版是<code>quickstart</code>的，接下来演示创建模版是<code>webapp</code>的，而往往我们的JavaWeb采用的工程模版就是通过webapp生成的，接下来演示通过webapp创建的maven项目,还是打开IDEA–&gt;New Project，出现如下界面:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%8811.37.39.png" alt="">  </p>
<p>然后next和上述<code>quickstart</code>的步骤一样，一直到finish，我们创建的maven项目工程结构如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%8811.41.09.png" width="50%">  </p>
<p>和上述quickstart创建的模版区别一看便知，为了让此maven项目符合官网上规定的标准工程结构，所以在IDEA中打开项目配置,添加项目没有包如在src包下添加test包，在test包下添加java包和resources包，在main包下添加java包然后点击apply即可，如下图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-24%20%E4%B8%8B%E5%8D%8811.45.31.png" alt="">  </p>
<p>到此我们便完成了第一个maven项目的创建，接下来我要进行Maven核心知识的讲解,见下篇文章<a href="http://codingxiaxw.cn/2016/11/26/52-Maven-core-knowledge/">Maven核心知识(待更新)</a>。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shiro整合Web项目及整合后的开发]]></title>
      <url>http://codingxiaxw.cn/2016/11/23/50-Shiro-Integration/</url>
      <content type="html"><![CDATA[<p>将Shiro框架整合到新的web项目中很简单，就是在web项目中导入Shiro的相关jar包以及整合jar包即可完成整合(是不是很简单…哈哈就是这么简单)。难的就是整合了Shiro框架后的web项目该如何进行开发，关于这一点，我将在下方通过一个demo演示用户的登录与退出及登录后的权限管理带你入门加入了Shiro框架后的web项目开发。</p>
<a id="more"></a>  
<p><strong>写在前边的话:</strong>shiro基础知识的讲解请看前面的两篇文章。另外我在github上已经放了一个整合了Spring+SpringMVC+Mybatis的web项目(就是关于商品的增、删、改、查操作)，接下来我要讲解的就是如何在这个项目中整合进我的Shiro框架，整合Shiro框架前的项目源码<a href="https://github.com/codingXiaxw/ssm2" target="_blank" rel="external">请点击这里</a>前往我的github，并讲解了整合了Shiro框架后的web项目该如何进行开发，整合了Shiro框架后的完整源码<a href="https://github.com/codingXiaxw/shiro" target="_blank" rel="external">请点击这里</a>前往我的github。  </p>
<p>用于创建表的sql语句见github上src包下的sql包。</p>
<h2 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h2><p>在一个整合了Spring+SpringMVC+Mybatis三个框架的web项目中再整合进Shiro框架，实现基于Shiro的权限管理机制。  </p>
<h2 id="2-导入jar包"><a href="#2-导入jar包" class="headerlink" title="2.导入jar包"></a>2.导入jar包</h2><p>在原先的项目基础上只需导入三个jar包即可:1.shiro-spring.jar。2.shiro-web.jar。3.shiro-core.jar。jar包见我github上的源代码。成功导入jar包，好，下一步，整合完毕。  </p>
<p>项目相关jsp页面请在github上自行下载，我们这里只进行web后端功能的讲解。接下来在原先的项目基础上通过增加用户登录和退出的功能对用户进行权限管理来讲解如何使用Shiro 进行开发。</p>
<h2 id="3-在web-xml中配置shiro的filter"><a href="#3-在web-xml中配置shiro的filter" class="headerlink" title="3.在web.xml中配置shiro的filter"></a>3.在web.xml中配置shiro的filter</h2><p>在web系统中，shiro也是通过filter进行拦截的。filter拦截后将操作权交给Spring中配置的filterChain(过滤链儿)，shiro提供了很多的filter。  </p>
<p>在web.xml中配置shiro的filter，加入如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在这里配置shiro的filter--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- shiro过虑器，DelegatingFilterProxy通过代理模式将spring容器中的bean和filter关联起来 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.DelegatingFilterProxy<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 设置true由servlet容器控制filter的生命周期 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetFilterLifecycle<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>targetBeanName<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="4-applicationContext-shiro-xml"><a href="#4-applicationContext-shiro-xml" class="headerlink" title="4.applicationContext-shiro.xml"></a>4.applicationContext-shiro.xml</h2><p>在src包下的config包下创建applicationContext-shiro.xml，在applicationContext-shiro.xml中配置web.xml中fitler对应spring容器中的bean以及SecurityManeger和自定义Realm的配置。内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/mvc</span><br><span class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context</span><br><span class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/aop</span><br><span class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/tx</span><br><span class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--web.xml中shiro的filter对应的bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Shiro 的Web过滤器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"shiroFilter"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login.action"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--认证成功统一跳转到first.actio，建议不配置，不配置的话shiro认证成功会自动到上一个请求路径--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"successUrl"</span> <span class="attr">value</span>=<span class="string">"/first.action"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/refuse.jsp"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 过虑器链定义，从上向下顺序执行，一般将/**放在最下边 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--对静态资源设置匿名访问--&gt;</span></span><br><span class="line">                /images/**=anon</span><br><span class="line">                /js/**=anon</span><br><span class="line">                /style/**=anon</span><br><span class="line"></span><br><span class="line">                <span class="comment">&lt;!--/**=anon 表示所有的url都可以匿名访问，anon是shiro中一个过滤器的简写，关于shiro中的过滤器介绍见--&gt;</span></span><br><span class="line">                /**=anon</span><br><span class="line">            <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--securityManage--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"customRealm"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自定义realm--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customRealm"</span> <span class="attr">class</span>=<span class="string">"shiro.CustomRealm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在applicationContext-shiro.xml的配置文件中，我们对系统的任何资源进行拦截，即通过<code>/**=anon</code>设置系统的任何资源都可以进行匿名访问。运行程序，在浏览器中输入<code>http://localhost:8080/Shiro/</code>即可访问系统，发现没有任何拦截即可以正常访问系统，因为shiro的过滤器没有对系统任何资源进行拦截，若想进行拦截，可以在上述配置文件中的<code>&lt;value&gt;&lt;/value&gt;</code>标签之间加入相应的拦截语句。下面就通过增加用户的登录实现通过Shiro的filter进行认证拦截的功能。即当访问被shiro拦截的系统资源时，系统会自动跳转到登录页面提醒用户需要经过用户登录认证后才能正常访问。  </p>
<h2 id="5-用Shiro实现登录认证"><a href="#5-用Shiro实现登录认证" class="headerlink" title="5.用Shiro实现登录认证"></a>5.用Shiro实现登录认证</h2><h3 id="5-1原理"><a href="#5-1原理" class="headerlink" title="5.1原理"></a>5.1原理</h3><p>用户登录是在一个表单进行的，所以这里我们需要通过shiro的一个表单过滤器(FormAuthenticationFilter)进行实现，原理如下:  </p>
<p>用户没有认证时，请求loginurl进行认证，输入用户名和密码点击登录时将用户身份和用户密码提交数据到loginurl，然后FormAuthenticationFilter进行拦截取出request中的username和password（FormAuthenticationFilter源码中将username和password两个参数名称写死了，而我们今后是可以将这两个参数名称写在配置文件中的），然后FormAuthenticationFilter会调用realm传入一个token（将username和password传入到token中），realm认证时根据username在数据库中查询用户信息（将在数据库中查询到的信息保存在在Activeuser.java对象中，包括 userid、usercode、username、menus），然后返回一个authenticationInfo。如果查询不到，realm就返回null，同时FormAuthenticationFilter会向request域中填充一个参数（记录了异常信息）。  </p>
<h3 id="5-2登录的代码实现"><a href="#5-2登录的代码实现" class="headerlink" title="5.2登录的代码实现"></a>5.2登录的代码实现</h3><p>可想而知该代码在控制器Controller中实现，创建一个LoginController.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span></span><br><span class="line"></span>&#123;</span><br><span class="line"> 	<span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果登录失败从request中获取认证异常信息,shiroLoginFailure就是shiro异常类的全限定名</span></span><br><span class="line">        String exceptionClassName= (String) request.getAttribute(<span class="string">"shiroLoginFailure"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据shiro返回的异常类路径判断，抛出指定异常信息</span></span><br><span class="line">        <span class="keyword">if</span>(exceptionClassName!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (UnknownAccountException.class.getName().equals(exceptionClassName)) &#123;</span><br><span class="line">                <span class="comment">//最终会抛给异常处理器</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">"账号不存在"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IncorrectCredentialsException.class.getName().equals(</span><br><span class="line">                    exceptionClassName)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">"用户名/密码错误"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"randomCodeError"</span>.equals(exceptionClassName))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">"验证码错误"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//最终在异常处理器生成未知错误</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-3配置认证拦截过滤器"><a href="#5-3配置认证拦截过滤器" class="headerlink" title="5.3配置认证拦截过滤器"></a>5.3配置认证拦截过滤器</h3><p>在applicationContext.xml的<code>&lt;bean&gt;标签</code>中加入如下标签配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- loginUrl认证提交地址，如果没有认证将会请求此地址进行认证，请求此地址将由formAuthenticationFilter进行表单认证 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"loginUrl"</span> <span class="attr">value</span>=<span class="string">"/login.action"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>并在<code>&lt;value&gt;</code>标签之间加入相应的拦截语句:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- -/**=authc 表示所有的url都必须认证通过才可以访问- --&gt;</span></span><br><span class="line"> /** = authc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!--/**=anon 表示所有的url都可以匿名访问--&gt;</span></span><br><span class="line">可以匿名访问的页面我们以后再配置</span><br></pre></td></tr></table></figure>
<p>运行服务器，访问系统首页发现系统会对我们访问的资源进行拦截并退回到登录页面，但是这里会有个问题发现登录页面的静态资源也被拦截了，所以我们应在<code>&lt;value&gt;</code>标签之间加入对静态资源设置匿名访问的设置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--对静态资源设置匿名访问--&gt;</span></span><br><span class="line">               /images/**=anon</span><br><span class="line">               /js/**=anon</span><br><span class="line">               /style/**=anon</span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!--请求这个地址就自动退出--&gt;</span></span><br><span class="line">               /logout.action=logout</span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!--商品查询需要商品查询权限--&gt;</span></span><br><span class="line">               /items/queryItems.action=perms[item:query]</span><br><span class="line"></span><br><span class="line">               /items/editItems.action=perms[item:edit]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!-- -/**=authc 表示所有的url都必须认证通过才可以访问- --&gt;</span></span><br><span class="line">               /** = authc</span><br><span class="line"></span><br><span class="line">               <span class="comment">&lt;!--/**=anon 表示所有的url都可以匿名访问--&gt;</span></span><br><span class="line">               可以匿名访问的页面我们以后再配置</span><br></pre></td></tr></table></figure></p>
<p>然后运行程序，访问系统资源时系统发现用户信息没有得到认证所以会退回到登录页面让你进行登录，你只有输入了密码为111111后才能成功完成登录，因为我们在自定义CustomRealm.java文件中只是模拟从数据库中查到的数据(我们设置查到的密码为111111)。登录成功后便可进行系统的访问了，但是登录成功后只能访问系统的首页，因为我们还没有对该用户进行权限分配指定该用户可以对系统的哪些资源进行操作了，所以这里当然只能访问系统首页。当然运行程序之前你得完成自定义CustomRealm的代码，我们采用前篇文章的自定义CustomRealm的内容，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入service</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysService sysService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置realm的名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"customRealm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//token是用户输入的</span></span><br><span class="line">        <span class="comment">//第一步:丛token中取出身份信息</span></span><br><span class="line">        String userCode= (String) token.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步:根据用户输入的userCode丛数据库查询</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟丛数据库查询到的密码</span></span><br><span class="line">        String password=<span class="string">"111111"</span>;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果查不到返回null，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果查询到，返回认证信息AuthenticationInfo</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///将activeUser设置到simpleAuthenticationInfo</span></span><br><span class="line">        SimpleAuthenticationInfo simpleAuthenticationInfo=<span class="keyword">new</span></span><br><span class="line">                SimpleAuthenticationInfo(userCode,password,<span class="keyword">this</span>.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> simpleAuthenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> 	</span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样便完成用户的认证功能，接下来是退出功能。</p>
<h2 id="6-退出"><a href="#6-退出" class="headerlink" title="6.退出"></a>6.退出</h2><p>退出功能就是当用户点击退出按钮时清楚保存在session中信息，这个功能不用我们实现，交给Shiro的LogoutFilter过滤器即可实现:当我们访问一个退出的url时，由LogoutFilter拦截住，然后清楚session。  </p>
<h3 id="6-1配置退出过滤器"><a href="#6-1配置退出过滤器" class="headerlink" title="6.1配置退出过滤器"></a>6.1配置退出过滤器</h3><p>在applicationContext-shiro.xml的<code>&lt;value&gt;</code>标签中加入如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--请求这个地址就自动退出--&gt;</span></span><br><span class="line">/logout.action=logout</span><br></pre></td></tr></table></figure></p>
<p>即完成清楚session即退出系统的功能。  </p>
<h2 id="7-实现用户成功登录后将认证信息显示在页面上"><a href="#7-实现用户成功登录后将认证信息显示在页面上" class="headerlink" title="7.实现用户成功登录后将认证信息显示在页面上"></a>7.实现用户成功登录后将认证信息显示在页面上</h2><p>需求:1.认证后用户菜单在首页显示。2.认证后用户的信息(例如用户名)在页头显示。</p>
<h3 id="7-1修改自定义Realm设置完整的认证信息"><a href="#7-1修改自定义Realm设置完整的认证信息" class="headerlink" title="7.1修改自定义Realm设置完整的认证信息"></a>7.1修改自定义Realm设置完整的认证信息</h3><p>先前我们通过realm在数据库中通过用户名查询到的用户信息只有密码，而现在我们需要查询到的数据包括用户可以操作的用户菜单、usercode用户id、username用户名等。  </p>
<p>我们先将这些信息用静态代码实现(即仍然没有涉及到数据库的查询):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟丛数据库查询到的密码</span></span><br><span class="line">    String password=<span class="string">"111111"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//activeUser就是用户的身份信息</span></span><br><span class="line">    ActiveUser activeUser=<span class="keyword">new</span> ActiveUser();</span><br><span class="line">    activeUser.setUserid(<span class="string">"zhangsan"</span>);</span><br><span class="line">    activeUser.setUsercode(<span class="string">"zhangsan"</span>);</span><br><span class="line">    activeUser.setUsername(<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据用户id取出菜单</span></span><br><span class="line">    <span class="comment">//通过service取出菜单</span></span><br><span class="line">    List&lt;SysPermission&gt; menus=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        menus=sysService.findMenuListByUserId(<span class="string">"zhangsan"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将用户菜单设置到activeUser</span></span><br><span class="line">    activeUser.setMenus(menus);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果查不到返回null，</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果查询到，返回认证信息AuthenticationInfo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">///将activeUser设置到simpleAuthenticationInfo</span></span><br><span class="line">    SimpleAuthenticationInfo simpleAuthenticationInfo=<span class="keyword">new</span></span><br><span class="line">            SimpleAuthenticationInfo(activeUser,password,<span class="keyword">this</span>.getName());</span><br></pre></td></tr></table></figure></p>
<p>然后修改first.action(在控制器FirstAction.java中实现该方法，当访问系统主页index.jsp时该index.jsp页面中设置将页面进行跳转到first.action)将认证信息在页面中进行显示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstAction</span> </span>&#123;</span><br><span class="line">	<span class="comment">//系统首页</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/first"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">first</span><span class="params">(Model model)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//从shiro的session中取出activeUser</span></span><br><span class="line">		Subject subject= SecurityUtils.getSubject();</span><br><span class="line">		<span class="comment">//取出身份信息</span></span><br><span class="line">		ActiveUser activeUser= (ActiveUser) subject.getPrincipal();</span><br><span class="line">		<span class="comment">//通过model传到页面</span></span><br><span class="line">		model.addAttribute(<span class="string">"activeUser"</span>,activeUser);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"/first"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//欢迎页面</span></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/welcome"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">welcome</span><span class="params">(Model model)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"/welcome"</span>;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，登录该系统后发现出现商品管理的菜单，我们仍然没有对商品进行操作的权限，所以接下来要讲解通过Shiro如何对用户进行授权操作。仍然在自定义Realm中模拟从数据库查询到的用户权限。  </p>
<h2 id="8-授权过滤器的测试"><a href="#8-授权过滤器的测试" class="headerlink" title="8.授权过滤器的测试"></a>8.授权过滤器的测试</h2><p>在Shiro中使用PermissionsAuthorizationFilter对用户进行授权，首先在applicationContext-shiro.xml中进行配置，加入如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--商品查询需要商品查询权限--&gt;</span></span><br><span class="line">/items/queryItems.action=perms[item:query]</span><br><span class="line"><span class="comment">&lt;!--商品修改需要商品修改权限--&gt;</span></span><br><span class="line">/items/editItems.action=perms[item:edit]</span><br></pre></td></tr></table></figure></p>
<p>通过上述配置，用户在认证通过后请求<code>/items/queryItems.action</code>的资源时会被PermissionsAuthorizationFilter拦截，发现需要“item:query”权限，然后PermissionsAuthorizationFilter调用realm中的doGetAuthorizationInfo获取数据库中正确的权限，对二者进行对比，如果“item:query”在realm返回的权限列表中，授权通过。如果不通过，则授权失败，跳转到refuse.jsp页面。所以我们还需要在applicationContext-shiro.xml进行授权失败后跳转到的页面配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"unauthorizedUrl"</span> <span class="attr">value</span>=<span class="string">"/refuse.jsp"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在自定义Realm中的授权方法中加入如下内容模拟从数据库中查到的用户权限，内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于授权</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//从principals获取主身份信息</span></span><br><span class="line">      <span class="comment">//将getPrimaryPrincipal方法返回值转为真实身份类型(在上边的goGetAuthenticationInfo认证通过填充到SimpleAuthenticationInfo)</span></span><br><span class="line">      ActiveUser activeUser= (ActiveUser) principals.getPrimaryPrincipal();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//根据身份信息获取权限信息,</span></span><br><span class="line">      <span class="comment">//模拟从数据库中获取到的动态权限数据</span></span><br><span class="line">      List&lt;String&gt; permissions=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      permissions.add(<span class="string">"user:create"</span>);<span class="comment">//模拟user的创建权限</span></span><br><span class="line">      permissions.add(<span class="string">"item:query"</span>);<span class="comment">//模拟查询权限</span></span><br><span class="line">      permissions.add(<span class="string">"item:add"</span>);<span class="comment">//模拟商品的添加权限</span></span><br><span class="line">      permissions.add(<span class="string">"item:edit"</span>);<span class="comment">//模拟修改权限</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//查到权限数据，返回授权信息(包括上边的permissions)</span></span><br><span class="line">      SimpleAuthorizationInfo simpleAuthorizationInfo=<span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将上边查询到授权信息填充到simpleAuthorizationInfo对象中</span></span><br><span class="line">      simpleAuthorizationInfo.addStringPermissions(permissions);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>在该自定义Realm中设置从数据库中查询到的用户权限有创建用户、查询商品、添加商品、编辑商品等权限，所以我们在运行程序后访问服务器后就会得到这些权限。  </p>
<h2 id="9-问题总结"><a href="#9-问题总结" class="headerlink" title="9.问题总结"></a>9.问题总结</h2><p>1、在applicationContext-shiro.xml中配置过虑器链接，需要将全部的url和权限对应起来进行配置，比较发麻不方便使用。  </p>
<p>2、每次授权都需要调用realm查询数据库，对于系统性能有很大影响，可以通过shiro缓存来解决。  </p>
<h2 id="10-Shiro的过滤器"><a href="#10-Shiro的过滤器" class="headerlink" title="10.Shiro的过滤器"></a>10.Shiro的过滤器</h2><table>
<thead>
<tr>
<th>过滤器简称</th>
<th style="text-align:center">对应的java类</th>
</tr>
</thead>
<tbody>
<tr>
<td>anon</td>
<td style="text-align:center">org.apache.shiro.web.filter.authc.AnonymousFilter</td>
</tr>
<tr>
<td>authc</td>
<td style="text-align:center">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>
</tr>
<tr>
<td>authcBasic</td>
<td style="text-align:center">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>
</tr>
<tr>
<td>perms</td>
<td style="text-align:center">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td>
</tr>
<tr>
<td>port</td>
<td style="text-align:center">org.apache.shiro.web.filter.authz.PortFilter</td>
</tr>
<tr>
<td>rest</td>
<td style="text-align:center">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td>
</tr>
<tr>
<td>roles</td>
<td style="text-align:center">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td>
</tr>
<tr>
<td>ssl</td>
<td style="text-align:center">org.apache.shiro.web.filter.authz.SslFilter</td>
</tr>
<tr>
<td>user</td>
<td style="text-align:center">org.apache.shiro.web.filter.authc.UserFilter</td>
</tr>
<tr>
<td>logout</td>
<td style="text-align:center">org.apache.shiro.web.filter.authc.LogoutFilter</td>
</tr>
</tbody>
</table>
<p><code>anon:</code>例子<code>/admins/**=anon</code>,anon后面没有参数，表示该路径下的资源可以匿名使用。  </p>
<p><code>authc:</code>例如<code>/admins/user/**=authc</code>,authc后面没有参数，表示该路径下的资源需要认证(登录)才能使用，FormAuthenticationFilter是表单认证，没有参数。  </p>
<p><code>perms:</code>例子<code>/admins/user/**=perms[user:add:*]</code>,参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，例如<code>/admins/user/**=perms[&quot;user:add:*,user:modify:*&quot;]</code>，当有多个参数时必须每个参数都通过才通过，想当于isPermitedAll()方法。  </p>
<p><code>user:</code>例如<code>/admins/user/**=user</code>,user后面没有参数，表示必须存在用户, 身份认证通过或通过记住我认证通过的可以访问，当登入操作时不做检查。  </p>
<p><code>roles:</code>例如<code>/admins/user/**=roles[admin]</code>,参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，例如<code>admins/user/**=roles[&quot;admin,guest&quot;]</code>,每个参数通过才算通过，相当于hasAllRoles()方法。  </p>
<p><code>rest:</code>例如<code>/admins/user/**=rest[user]</code>,根据请求的方法，相当于<code>/admins/user/**=perms[user:method]</code>,其中method为post，get，delete等。  </p>
<p>上述涉及到的过滤器中:<code>anon，authcBasic，auchc，user</code>是认证过滤器，<code>perms，roles，ssl，rest，port</code>是授权过滤器。</p>
<p>上面我们自定义的Realm进行认证和授权时都是通过将用户输入的信息和我们自己给的数据进行比对，而没有从数据库中查询到相关信息。所以接下来要讲通过Realm从数据库中查询认证数据和权限数据的开发重新实现上述的登录和授权功能。  </p>
<h2 id="11-通过查询数据库完成认证"><a href="#11-通过查询数据库完成认证" class="headerlink" title="11.通过查询数据库完成认证"></a>11.通过查询数据库完成认证</h2><h3 id="11-1需求"><a href="#11-1需求" class="headerlink" title="11.1需求"></a>11.1需求</h3><p>修改realm的doGetAuthenticationInfo()方法，从数据库查询用户信息，realm返回的用户信息中包括(数据库库中经过md5加密后的串和salt），实现让shiro进行散列串的校验。  </p>
<h3 id="11-2修改doGetAuthenticationInfo从数据库查询用户信息"><a href="#11-2修改doGetAuthenticationInfo从数据库查询用户信息" class="headerlink" title="11.2修改doGetAuthenticationInfo从数据库查询用户信息"></a>11.2修改doGetAuthenticationInfo从数据库查询用户信息</h3><p>修改自定义CustomRealm代码，由于要向数据库中查询数据，所以需要在CustomRealm中注入SysService对象。修改后的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入service</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SysService sysService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置realm的名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"customRealm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//realm的认证方法，从数据库查询用户信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//token是用户输入的</span></span><br><span class="line">        <span class="comment">//第一步:丛token中取出身份信息</span></span><br><span class="line">        String userCode= (String) token.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步:根据用户输入的userCode丛数据库查询</span></span><br><span class="line">        SysUser sysUser =<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sysUser=sysService.findSysUserByUserCode(userCode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否从数据库中查询到用户信息</span></span><br><span class="line">        <span class="keyword">if</span> (sysService==<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从数据库查询到的密码</span></span><br><span class="line">        String password=sysUser.getPassword();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//盐salt</span></span><br><span class="line">        String salt=sysUser.getSalt();</span><br><span class="line">        System.out.println(salt);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//activeUser就是用户的身份信息</span></span><br><span class="line">        ActiveUser activeUser=<span class="keyword">new</span> ActiveUser();</span><br><span class="line">        activeUser.setUserid(sysUser.getId());</span><br><span class="line">        activeUser.setUsercode(sysUser.getUsercode());</span><br><span class="line">        activeUser.setUsername(sysUser.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据用户id取出菜单</span></span><br><span class="line">        <span class="comment">//通过service取出菜单</span></span><br><span class="line">        List&lt;SysPermission&gt; menus=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            menus=sysService.findMenuListByUserId(sysUser.getId());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将用户菜单设置到activeUser</span></span><br><span class="line">        activeUser.setMenus(menus);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果查不到返回null，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果查询到，返回认证信息AuthenticationInfo</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">///将activeUser设置到simpleAuthenticationInfo</span></span><br><span class="line">        SimpleAuthenticationInfo simpleAuthenticationInfo=<span class="keyword">new</span></span><br><span class="line">                SimpleAuthenticationInfo(activeUser,password, ByteSource.Util.bytes(salt),<span class="keyword">this</span>.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> simpleAuthenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>就是将之前的静态数据换成从数据库中查询到的动态数据。  </p>
<h3 id="11-3设置凭证匹配器"><a href="#11-3设置凭证匹配器" class="headerlink" title="11.3设置凭证匹配器"></a>11.3设置凭证匹配器</h3><p>数据库中存储到的md5的散列值，在realm中需要设置数据库中的散列值它使用散列算法及散列次数，让shiro进行散列对比时和原始数据库中的散列值使用的算法一致。在applicationContext-shiro.xml中配置如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 凭证匹配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.authc.credential.HashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashAlgorithmName"</span> <span class="attr">value</span>=<span class="string">"md5"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hashIterations"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>并将凭证匹配器设置到我们自定义realm的配置中，在自定义realm的标签中加入如下标签:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义realm--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customRealm"</span> <span class="attr">class</span>=<span class="string">"shiro.CustomRealm"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--将凭证匹配器设置到realm中，realm按照凭证匹配器要求进行散列--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"credentialsMatcher"</span> <span class="attr">ref</span>=<span class="string">"credentialsMatcher"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们便通过realm将用户输入的信息和从数据库中查到的数据进行对比从而完成了认证。  </p>
<h2 id="12-通过查询数据库完成授权"><a href="#12-通过查询数据库完成授权" class="headerlink" title="12.通过查询数据库完成授权"></a>12.通过查询数据库完成授权</h2><h3 id="12-1需求"><a href="#12-1需求" class="headerlink" title="12.1需求"></a>12.1需求</h3><p>修改realm的doGetAuthorizationInfo()方法从数据库查询权限信息。授权的方式上面介绍过三种，正式开发中我们使用注解式授权方法和jsp标签授权方法。  </p>
<h3 id="12-2修改doGetAuthorizationInfo从数据库查询权限"><a href="#12-2修改doGetAuthorizationInfo从数据库查询权限" class="headerlink" title="12.2修改doGetAuthorizationInfo从数据库查询权限"></a>12.2修改doGetAuthorizationInfo从数据库查询权限</h3><p>修改自定义Realm中的doGetAuthorizationInfo授权方法，修改后的代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于授权</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//从principals获取主身份信息</span></span><br><span class="line">       <span class="comment">//将getPrimaryPrincipal方法返回值转为真实身份类型(在上边的goGetAuthenticationInfo认证通过填充到SimpleAuthenticationInfo)</span></span><br><span class="line">       ActiveUser activeUser= (ActiveUser) principals.getPrimaryPrincipal();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//根据身份信息获取权限信息,</span></span><br><span class="line">       <span class="comment">//从数据库中获取到的动态权限数据</span></span><br><span class="line">       List&lt;SysPermission&gt; permissionList=<span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           permissionList=sysService.findPermissionListByUserId(activeUser.getUserid());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; permissions=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (permissionList!=<span class="keyword">null</span>)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span> (SysPermission sysPermission:permissionList)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="comment">//将数据库中的权限标签符放入集合</span></span><br><span class="line">               permissions.add(sysPermission.getPercode());</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//查到权限数据，返回授权信息(包括上边的permissions)</span></span><br><span class="line">       SimpleAuthorizationInfo simpleAuthorizationInfo=<span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将上边查询到授权信息填充到simpleAuthorizationInfo对象中</span></span><br><span class="line">       simpleAuthorizationInfo.addStringPermissions(permissions);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们之前给用户授权是在applicationContext-shiro.xml中的<code>&lt;value&gt;</code>标签中采用:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/items/queryItems.action=perms[item:query]</span><br><span class="line"><span class="comment">&lt;!--商品修改需要商品修改权限--&gt;</span></span><br><span class="line">/items/editItems.action=perms[item:edit]</span><br></pre></td></tr></table></figure></p>
<p>的方式给用户访问的资源进行授权，所以接下来我们讲解注解授权，将上述进行授权的内容注释掉，注解授权的步骤如下。</p>
<h3 id="12-3开启controller类aop支持"><a href="#12-3开启controller类aop支持" class="headerlink" title="12.3开启controller类aop支持"></a>12.3开启controller类aop支持</h3><p>对系统中类的方法给用户授权，建议在controller层进行方法授权，在springmvc.xml中配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启aop，对类代理 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span> <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 开启shiro注解支持 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"securityManager"</span> <span class="attr">ref</span>=<span class="string">"securityManager"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="12-4在controller方法中添加注解"><a href="#12-4在controller方法中添加注解" class="headerlink" title="12.4在controller方法中添加注解"></a>12.4在controller方法中添加注解</h3><p>给商品查询方法添加查询商品权限:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/queryItems"</span>)</span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"item:query"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryItems</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给商品修改方法添加商品更新权限:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/editItems"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"item:update"</span>)<span class="comment">//执行此方法需要item:update权限</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItems</span><span class="params">(Model model, Integer id)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>给商品修改页面的提交方法添加商品更新权限:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/editItemSubmit"</span>)</span><br><span class="line"><span class="meta">@RequiresPermissions</span>(<span class="string">"item:update"</span>)<span class="comment">//执行此方法需要item:update权限</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemSubmit</span><span class="params">(Model model,Integer id,</span><br><span class="line">                                 @Validated(value = &#123;ValidGroup1.class&#125;)</span> @<span class="title">ModelAttribute</span><span class="params">(value = <span class="string">"itemsCustom"</span>)</span> ItemsCustom itemsCustom,</span><br><span class="line">                                 BindingResult bindingResult,</span><br><span class="line">                                 <span class="comment">//上传图片</span></span><br><span class="line">                                 MultipartFile pictureFile</span><br><span class="line">                                 ) <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一种方式在jsp标签授权。</p>
<h3 id="12-5jsp标签授权"><a href="#12-5jsp标签授权" class="headerlink" title="12.5jsp标签授权"></a>12.5jsp标签授权</h3><p>在itemsList.jsp页面最上方添加如下标签:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://shiro.apache.org/tags"</span> <span class="attr">prefix</span>=<span class="string">"shiro"</span> %&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后修改itemsList.jsp页面部分内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--有item:update权限才现实修改链接，没有权限则不显示修改链接--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">shiro:hasPermission</span> <span class="attr">name</span>=<span class="string">"item:update"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasPermission</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>相关jsp标签授权的解释如下表:  </p>
<table>
<thead>
<tr>
<th>标签名称</th>
<th style="text-align:left">标签条件（均是显示标签内容）</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>&lt;shiro:authenticated&gt;</code></td>
<td style="text-align:left">登录之后</td>
</tr>
<tr>
<td><code>&lt;shiro:notAuthenticated&gt;</code></td>
<td style="text-align:left">不在登录状态时</td>
</tr>
<tr>
<td><code>&lt;shiro:guest&gt;</code></td>
<td style="text-align:left">用户在没有RememberMe时</td>
</tr>
<tr>
<td><code>&lt;shiro:user&gt;</code></td>
<td style="text-align:left">用户在RememberMe时</td>
</tr>
<tr>
<td><code>&lt;shiro:hasAnyRoles name=&quot;abc,123&quot; &gt;</code></td>
<td style="text-align:left">在有abc或者123角色时</td>
</tr>
<tr>
<td><code>&lt;shiro:hasRole name=&quot;abc&quot;&gt;</code></td>
<td style="text-align:left">拥有角色abc</td>
</tr>
<tr>
<td><code>&lt;shiro:lacksRole name=&quot;abc&quot;&gt;</code></td>
<td style="text-align:left">没有角色abc</td>
</tr>
<tr>
<td><code>&lt;shiro:hasPermission name=&quot;abc&quot;&gt;</code></td>
<td style="text-align:left">拥有权限资源abc</td>
</tr>
<tr>
<td><code>&lt;shiro:lacksPermission name=&quot;abc&quot;&gt;</code></td>
<td style="text-align:left">没有abc权限资源</td>
</tr>
<tr>
<td><code>&lt;shiro:principal&gt;</code></td>
<td style="text-align:left">显示用户身份名称</td>
</tr>
<tr>
<td><code>&lt;shiro:principal property=&quot;username&quot;/&gt;</code></td>
<td style="text-align:left">显示用户身份中的属性值</td>
</tr>
</tbody>
</table>
<h3 id="12-6授权测试"><a href="#12-6授权测试" class="headerlink" title="12.6授权测试"></a>12.6授权测试</h3><p>当调用controller的一个方法(比如ItemsController的queryItems()方法)，由于该方法加了<code>@RequiresPermissions(&quot;item:query&quot;)</code> ，shiro调用realm获取数据库中的权限信息，看”item:query”是否在权限数据中存在，如果不存在就拒绝访问，如果存在就授权通过。  </p>
<p>当展示一个jsp页面时，页面中如果遇到<code>&lt;shiro:hasPermission name=&quot;item:update&quot;&gt;</code>，shiro调用realm获取数据库中的权限信息，看item:update是否在权限数据中存在，如果不存在就拒绝访问，如果存在就授权通过。  </p>
<p>问题:只要遇到注解或jsp标签的授权，都会调用realm方法查询数据库，需要使用缓存解决此问题。  </p>
<h2 id="13-Shiro缓存"><a href="#13-Shiro缓存" class="headerlink" title="13.Shiro缓存"></a>13.Shiro缓存</h2><p>需求:针对上边授权频繁查询数据库，需要使用shiro缓存。</p>
<h3 id="13-1缓存流程"><a href="#13-1缓存流程" class="headerlink" title="13.1缓存流程"></a>13.1缓存流程</h3><p>shiro中提供了对认证信息和授权信息的缓存。shiro默认是关闭认证信息缓存的，对于授权信息的缓存shiro默认开启的。主要研究授权信息缓存，因为授权的数据量大。  </p>
<p>当用户认证通过时，该用户第一次授权:调用realm查询数据库查询该用户的授权信息然后给该用户授权。该用户第二次授权时:不调用realm查询数据库，直接从缓存中取出授权信息（权限标识符）然后给该用户授权。</p>
<h3 id="13-2使用ehcache缓存"><a href="#13-2使用ehcache缓存" class="headerlink" title="13.2使用ehcache缓存"></a>13.2使用ehcache缓存</h3><h4 id="13-2-1添加jar包"><a href="#13-2-1添加jar包" class="headerlink" title="13.2.1添加jar包"></a>13.2.1添加jar包</h4><p>包括ehcache-core.jar和整合包shiro-ehcache.jar。  </p>
<h4 id="13-2-2配置cacheManager"><a href="#13-2-2配置cacheManager" class="headerlink" title="13.2.2配置cacheManager"></a>13.2.2配置cacheManager</h4><p>在application-shiro.xml中加入ehcache的缓存管理器配置，如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 缓存管理器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"cacheManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManagerConfigFile"</span> <span class="attr">value</span>=<span class="string">"classpath:shiro-ehcache.xml"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后将缓存管理器注入到securityManager安全管理器中，在安全管理器中加入如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--securityManage--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"customRealm"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--注入缓存管理器--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后需要进行shiro-ecache的配置，跟我们在Mybatis中整合ehcache的内容一样，在config包下创建一个shiro-ehcache.xml文件，内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"../config/ehcache.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--diskStore：缓存数据持久化的目录 地址  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"/Users/codingboy/develop/ehcache"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span><br><span class="line">            <span class="attr">maxElementsInMemory</span>=<span class="string">"1000"</span></span><br><span class="line">            <span class="attr">maxElementsOnDisk</span>=<span class="string">"10000000"</span></span><br><span class="line">            <span class="attr">eternal</span>=<span class="string">"false"</span></span><br><span class="line">            <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span><br><span class="line">            <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span><br><span class="line">            <span class="attr">timeToIdleSeconds</span>=<span class="string">"120"</span></span><br><span class="line">            <span class="attr">timeToLiveSeconds</span>=<span class="string">"120"</span></span><br><span class="line">            <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">"120"</span></span><br><span class="line">            <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">defaultCache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="13-2-3缓存清空"><a href="#13-2-3缓存清空" class="headerlink" title="13.2.3缓存清空"></a>13.2.3缓存清空</h4><p>需求:如果用户正常退出，缓存自动清空;如果用户非正常退出，缓存自动清空。如果修改了用户的权限，而用户不退出系统，修改的权限无法立即生效,需要手动进行编程实现:  </p>
<p>在权限修改后调用realm的clearCache方法清除缓存，下边的代码正常开发时要放在service中调用。这里我们只是进行一下测试。  </p>
<p>在realm中添加如下方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清除缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearCached</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PrincipalCollection principals = SecurityUtils.getSubject().getPrincipals();</span><br><span class="line">        <span class="keyword">super</span>.clearCache(principals);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后便可以进行测试类的编写了，在controller包下创建一个ClearShiroCache.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClearShiroCache</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CustomRealm customRealm;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/clearShiroCache"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">clearShiroCache</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除缓存,将来开发要在service调用</span></span><br><span class="line">        customRealm.clearCached();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后进行测试，在服务器中输入<code>http://localhost:8080/Shiro</code>，进行登录，访问系统首页。此时再输入<code>http://localhost:8080/Shiro/clearShiroCache</code>即可清除该用户的权限。这里我们只进行测试，以后是在service中进行。  </p>
<h2 id="14-会话管理器sessionManager"><a href="#14-会话管理器sessionManager" class="headerlink" title="14.会话管理器sessionManager"></a>14.会话管理器sessionManager</h2><p>和shiro整合后，使用shiro的sessionManager对会话session进行管理，此外shiro还提供sessionDao操作会话数据。  </p>
<p>配置sessionManager，在application-shiro.xml中加入会话管理器的配置内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sessionManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.session.mgt.DefaultWebSessionManager"</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- session的失效时长，单位毫秒 --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"globalSessionTimeout"</span> <span class="attr">value</span>=<span class="string">"600000"</span>/&gt;</span></span><br><span class="line">     <span class="comment">&lt;!-- 删除失效的session --&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"deleteInvalidSessions"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后将该管理器注入到安全管理器中:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--securityManage--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"customRealm"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--注入缓存管理器--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">&lt;!--注入会话管理器--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="15-实现验证码"><a href="#15-实现验证码" class="headerlink" title="15.实现验证码"></a>15.实现验证码</h2><h3 id="15-1思路"><a href="#15-1思路" class="headerlink" title="15.1思路"></a>15.1思路</h3><p>shiro使用FormAuthenticationFilter进行表单认证，验证校验的功能应该加在FormAuthenticationFilter中，在认证之前进行验证码校验，而shiro为我们提供的FormAuthenticationFilter中没有对验证码进行认证。所以我们需要写FormAuthenticationFilter的子类，继承FormAuthenticationFilter，改写它的认证方法，在认证之前进行验证码校验。  </p>
<h3 id="15-2自定义FormAuthenticationFilter"><a href="#15-2自定义FormAuthenticationFilter" class="headerlink" title="15.2自定义FormAuthenticationFilter"></a>15.2自定义FormAuthenticationFilter</h3><p>在src包下的shiro包下创建一个CustomFormAuthenticationFilter.java，内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomFromAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">FormAuthenticationFilter</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAccessDenied</span><span class="params">(ServletRequest request,</span><br><span class="line">                                     ServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在这里进行验证码的校验</span></span><br><span class="line">        HttpServletRequest httpServletRequest= (HttpServletRequest) request;</span><br><span class="line">        HttpSession session=httpServletRequest.getSession();</span><br><span class="line">        <span class="comment">//取出session中的正确验证码</span></span><br><span class="line">        String validateCode= (String) session.getAttribute(<span class="string">"validateCode"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出页面的验证码</span></span><br><span class="line">        String randomcode=httpServletRequest.getParameter(<span class="string">"randomcode"</span>);</span><br><span class="line">        <span class="keyword">if</span> (randomcode!=<span class="keyword">null</span>&amp;&amp;validateCode!=<span class="keyword">null</span>&amp;&amp;!randomcode.equals(validateCode))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果校验失败，将验证码错误的失败信息，通过shiroLoginFailure设置到request中</span></span><br><span class="line">            httpServletRequest.setAttribute(<span class="string">"shiroLoginFailure"</span>,<span class="string">"randomCodeError"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//拒绝访问，不再校验账号和密码</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onAccessDenied(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-3配置自定义FormAuthenticationFilter"><a href="#15-3配置自定义FormAuthenticationFilter" class="headerlink" title="15.3配置自定义FormAuthenticationFilter"></a>15.3配置自定义FormAuthenticationFilter</h3><p>在shiro中加入配置信息:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义form认证过滤器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formAuthenticationFilter"</span></span><br><span class="line">         <span class="attr">class</span>=<span class="string">"shiro.CustomFromAuthenticationFilter"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 表单中账号的input名称 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParam"</span> <span class="attr">value</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 表单中密码的input名称 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParam"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--记住我input的名称--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeParam"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后将它注入到Shiro的过滤器中，在<code>&lt;bean id=&quot;shiroFilter&quot;&gt;</code>中加入自定义filter的配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义filter--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        !-- 将自定义的FormAuthenticationFilter注入shiroFiler中 --&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"authc"</span> <span class="attr">value-ref</span>=<span class="string">"formAuthenticationFilter"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在login.action中对验证错误进行解析:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"randomCodeError"</span>.equals(exceptionClassName))&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">"验证码错误"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在登录页面中添加验证码:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TD</span>&gt;</span>密 码：<span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">id</span>=<span class="string">"pwd"</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">style</span>=<span class="string">"WIDTH: 130px"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TR</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TD</span>&gt;</span>验证码：<span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">TD</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">id</span>=<span class="string">"randomcode"</span> <span class="attr">name</span>=<span class="string">"randomcode"</span> <span class="attr">size</span>=<span class="string">"8"</span> /&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"randomcode_img"</span> <span class="attr">src</span>=<span class="string">"$&#123;baseurl&#125;validatecode.jsp"</span> <span class="attr">alt</span>=<span class="string">""</span> <span class="attr">width</span>=<span class="string">"56"</span> <span class="attr">height</span>=<span class="string">"20"</span> <span class="attr">align</span>=<span class="string">'absMiddle'</span> /&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">javascript:randomcode_refresh()</span>&gt;</span>刷新<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">TD</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">TR</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在shiro的过滤器filter中配置匿名访问验证码的图片资源:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--对静态资源设置匿名访问--&gt;</span></span><br><span class="line">            /images/**=anon</span><br><span class="line">            /js/**=anon</span><br><span class="line">            /style/**=anon</span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--验证码--&gt;</span></span><br><span class="line">            /validatecode.jsp=anon</span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--请求这个地址就自动退出--&gt;</span></span><br><span class="line">            /logout.action=logout</span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--商品查询需要商品查询权限，取消url拦截配置，采用注解授权--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--/items/queryItems.action=perms[item:query]--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash;商品修改需要商品修改权限&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--/items/editItems.action=perms[item:edit]--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- -/**=authc 表示所有的url都必须认证通过才可以访问- --&gt;</span></span><br><span class="line">            /** = authc</span><br><span class="line">            <span class="comment">&lt;!--/**=anon 表示所有的url都可以匿名访问--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="16-实现”记住我”功能"><a href="#16-实现”记住我”功能" class="headerlink" title="16.实现”记住我”功能"></a>16.实现”记住我”功能</h2><p>用户登陆选择“自动登陆”本次登陆成功会向cookie写身份信息，下次登陆从cookie中取出身份信息实现自动登陆。</p>
<p>这里涉及到session的序列化与反序列化，所以涉及到的pojo类都应该实现java.io.Serializable接口。首先让ActiveUser.java实现java.io.Serializable接口，然后让SysPermission.java实现java.io.Serializable接口。  </p>
<h3 id="16-1配置rememberMeManager"><a href="#16-1配置rememberMeManager" class="headerlink" title="16.1配置rememberMeManager"></a>16.1配置rememberMeManager</h3><p>在application-shiro.xml中加入记住我的管理器，内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- rememberMeManager管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.CookieRememberMeManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cookie"</span> <span class="attr">ref</span>=<span class="string">"rememberMeCookie"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 记住我cookie --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rememberMeCookie"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--rememberMe时cookie的名字--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 记住我cookie生效时间30天 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxAge"</span> <span class="attr">value</span>=<span class="string">"2592000"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>并注入到securityManager中:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--securityManage--&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"securityManager"</span> <span class="attr">class</span>=<span class="string">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"realm"</span> <span class="attr">ref</span>=<span class="string">"customRealm"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--注入缓存管理器--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheManager"</span> <span class="attr">ref</span>=<span class="string">"cacheManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!--注入会话管理器--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sessionManager"</span> <span class="attr">ref</span>=<span class="string">"sessionManager"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- 记住我 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeManager"</span> <span class="attr">ref</span>=<span class="string">"rememberMeManager"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后修改登录页面，加入记住我的按钮，然后在application-shiro.xml的我们自定义form认证过滤器的配置中加入rememberMe的input名称配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--自定义form认证过滤器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"formAuthenticationFilter"</span></span><br><span class="line">         <span class="attr">class</span>=<span class="string">"shiro.CustomFromAuthenticationFilter"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 表单中账号的input名称 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"usernameParam"</span> <span class="attr">value</span>=<span class="string">"username"</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 表单中密码的input名称 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"passwordParam"</span> <span class="attr">value</span>=<span class="string">"password"</span> /&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--记住我input的名称--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"rememberMeParam"</span> <span class="attr">value</span>=<span class="string">"rememberMe"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后便可以进行测试，在登录页面输入登录信息后点击下次自动登录，登录成功后我们查看浏览器的cookie缓存会发现多了一个名叫rememberMe的cookie信息。然而此时我们若退出登录，退回到登录页面，按理说此时浏览器已经存在该cookie了所以此时若我们直接访问系统主页是可以直接访问的，然而测试结果仍然不行，因为该请求被<code>/**=authc</code>拦截了，所以我们要使用UserFilter，将记住我即可访问的地址配置让UserFilter拦截。  </p>
<h3 id="16-2使用UserFilter"><a href="#16-2使用UserFilter" class="headerlink" title="16.2使用UserFilter"></a>16.2使用UserFilter</h3><p>在application-shiro.xml的<code>&lt;value&gt;</code>中加入UserFilter拦截的资源配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--对静态资源设置匿名访问--&gt;</span></span><br><span class="line">            /images/**=anon</span><br><span class="line">            /js/**=anon</span><br><span class="line">            /style/**=anon</span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--验证码--&gt;</span></span><br><span class="line">            /validatecode.jsp=anon</span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--请求这个地址就自动退出--&gt;</span></span><br><span class="line">            /logout.action=logout</span><br><span class="line"></span><br><span class="line">            <span class="comment">&lt;!--商品查询需要商品查询权限，取消url拦截配置，采用注解授权--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--/items/queryItems.action=perms[item:query]--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&amp;lt;!&amp;ndash;商品修改需要商品修改权限&amp;ndash;&amp;gt;--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--/items/editItems.action=perms[item:edit]--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置记住我或认证通过可以访问的资源url--&gt;</span></span><br><span class="line">            /index.jsp=user</span><br><span class="line">            /first.action=user</span><br><span class="line">            /welcome.jsp=user</span><br><span class="line">            <span class="comment">&lt;!-- -/**=authc 表示所有的url都必须认证通过才可以访问- --&gt;</span></span><br><span class="line">            /** = authc</span><br><span class="line">            <span class="comment">&lt;!--/**=anon 表示所有的url都可以匿名访问--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此时登录时点击记住我，成功登录后关掉浏览器，再次输入系统的主页地址即可直接访问系统的这三个资源:<code>/index.jsp</code>、<code>/first.action</code>、<code>welcome.jsp</code>。到此，我们便简单的入门了整合了Shiro框架的SSM的web项目该如何进行开发。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="17-联系"><a href="#17-联系" class="headerlink" title="17.联系"></a>17.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shiro之实现授权]]></title>
      <url>http://codingxiaxw.cn/2016/11/22/49-shiro-authorization/</url>
      <content type="html"><![CDATA[<p>当用户的信息得到认证通过后，该用户在系统中具有哪些操作权限呢？所以在用户认证通过后，系统就要给该用户进行授权操作了。  </p>
<a id="more"></a>
<p><strong>写在前面的话:</strong>同前篇文章<a href="http://codingxiaxw.cn/2016/11/21/48-shiro-authentication/">Shiro之实现认证</a>那样，本篇文章也只是通过一个入门程序教大家学会使用Shiro实现授权功能(当然只有要在该用户的信息认证通过后才能对该用户进行授权)，没有将Shiro同Spring整合起来使用(后面的文章我们会讲解Shiro整合web开发环境的项目中如何实现授权功能，见<a href="http://codingxiaxw.cn/2016/11/23/50-Shiro-Integration/">Shiro整合Web项目及整合后的开发</a>)，所以我们就采用上篇文章的工程结构即可。本篇文章的讲解结构跟前篇文章讲解结构也是一致的，便于大家理解。  </p>
<h2 id="1-授权的概念"><a href="#1-授权的概念" class="headerlink" title="1.授权的概念"></a>1.授权的概念</h2><p>授权，也叫访问控制，即在应用中控制谁能访问哪些资源（如访问页面/编辑数据/页面操作等）。在授权中需了解的几个关键对象:主体(Subject)、资源(Resource)、权限(Permission)、角色(Role)。  </p>
<p><strong>主体:</strong>即访问应用的用户，在Shiro中使用Subject代表该用户。用户只有授权后才允许访问相应的资源。  </p>
<p><strong>资源:</strong>在应用中用户可以访问的任何东西，比如访问JSP页面、查看/编辑某些数据、访问某个业务方法、打印文本等等都是资源。用户只要授权后才能访问。  </p>
<p><strong>权限:</strong>安全策略中的原子授权单位，通过权限我们可以表示在应用中用户有没有操作某个资源的权力。即权限表示在应用中用户能不能访问某个资源，如:访问用户列表页面、查看/新增/修改/删除用户数据（即很多时候都是CRUD（增查改删）式权限控制）、打印文档等等。  </p>
<p>如上可以看出，权限代表了用户有没有操作某个资源的权利，即反映在某个资源上的操作允不允许，不反映谁去执行这个操作。所以后续还需要把权限赋予给用户，即定义哪个用户允许在某个资源上做什么操作（权限），Shiro不会去做这件事情，而是由实现人员提供。  </p>
<p><strong>角色:</strong>角色代表了操作集合，可以理解为权限的集合，一般情况下我们会赋予用户角色而不是权限，即这样用户可以拥有一组权限，赋予权限时比较方便。典型的如:项目经理、技术总监、CTO、开发工程师等都是角色，不同的角色拥有一组不同的权限。包括隐式角色和显示角色。  </p>
<p><strong>隐式角色:</strong>即直接通过角色来验证用户有没有操作权限，如在应用中CTO、技术总监、开发工程师可以使用打印机，假设某天不允许开发工程师使用打印机，此时需要从应用中删除相应代码；再如在应用中CTO、技术总监可以查看用户、查看权限；突然有一天不允许技术总监查看用户、查看权限了，需要在相关代码中把技术总监角色从判断逻辑中删除掉；即粒度是以角色为单位进行访问控制的，粒度较粗；如果进行修改可能造成多处代码修改。<br><strong>显示角色:</strong>在程序中通过权限控制谁能访问某个资源，角色聚合一组权限集合；这样假设哪个角色不能访问某个资源，只需要从角色代表的权限集合中移除即可；无须修改多处代码；即粒度是以资源/实例为单位的；粒度较细。  </p>
<p>授权的核心是权限控制，而权限控制分为基于角色的访问控制和基于资源的访问控制，二者概念我在<a href="http://codingxiaxw.cn/2016/11/20/47-first-Shiro/">初识Shiro</a>的1.3.5节的权限控制中讲过，实际开发中都是采用的基于资源的访问控制。下面的介绍中，我在入门程序中会将基于角色的访问控制和基于资源的访问控制都进行讲解，但在讲到使用自定义Realm后我就只会讲解基于资源的访问控制了。</p>
<h2 id="2-授权流程"><a href="#2-授权流程" class="headerlink" title="2.授权流程"></a>2.授权流程</h2><p>在Shiro的代码中授权的流程如下图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-22%20%E4%B8%8B%E5%8D%883.43.34.png" alt="">  </p>
<p>在写授权的代码时都要根据这个流程图来写。</p>
<h2 id="3-授权的方式"><a href="#3-授权的方式" class="headerlink" title="3.授权的方式"></a>3.授权的方式</h2><p>Shiro支持三种授权的方式。  </p>
<p>第一种:编程式:通过写if/else授权代码块完成:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject subject = SecurityUtils.getSubject();  </span><br><span class="line"><span class="keyword">if</span>(subject.hasRole(“admin”)) &#123;  </span><br><span class="line">    <span class="comment">//有权限  </span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">//无权限  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种:注解式:通过在执行的Java方法上放置相应的注解完成(没有权限将抛出相应的异常):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequiresRoles</span>(<span class="string">"admin"</span>)  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//有权限  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三种:JSP/GSP标签:在JSP/GSP页面通过相应的标签完成:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">shiro:hasRole</span> <span class="attr">name</span>=<span class="string">"admin"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">!—</span> 有权限 —&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">shiro:hasRole</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对于上述授权的三种实现方式，我们只在写入门程序时使用第一种方式，在实际开发中我们使用后两种方式进行用户的授权判断。</p>
<h2 id="4-入门程序"><a href="#4-入门程序" class="headerlink" title="4.入门程序"></a>4.入门程序</h2><p>在src包下创建一个shiro-permission.ini配置文件，用于模拟数据库中的权限数据，内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#基于用户的访问控制</span><br><span class="line">[users]</span><br><span class="line">#用户zhangsan的密码是123，此用户具有role1和role2两个角色;用户wang具有role2一个角色</span><br><span class="line">zhangsan=123,role1,role2</span><br><span class="line">wang=123,role2</span><br><span class="line"></span><br><span class="line">#基于权限的访问控制</span><br><span class="line">[roles]</span><br><span class="line">#角色role1对资源user拥有create、update权限</span><br><span class="line">role1=user:create,user:update</span><br><span class="line">#角色role2对资源user拥有create、delete权限</span><br><span class="line">role2=user:create,user:delete</span><br><span class="line">#角色role3对资源user拥有create权限</span><br><span class="line">role3=user:create</span><br></pre></td></tr></table></figure></p>
<p>对配置文件中的解释如下:  </p>
<p>权限标识符号规则：资源:操作:实例(中间使用半角:分隔)。如下:  </p>
<p><code>user：create:01</code>,表示对用户资源的01实例进行create操作。<br><code>user:create</code>,表示对用户资源进行create操作，相当于<code>user:create:*</code>，对所有用户资源实例进行create操作。<br><code>user：*：01</code>,表示对用户资源实例01进行所有操作。</p>
<p>然后写一个测试类Authorization.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthorizationTest</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//角色授权测试和资源授权测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAuthorization</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//第一步，创建SecurityManager工厂</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory=<span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:shiro-permission.ini"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步:创建SecurityManager</span></span><br><span class="line">        SecurityManager securityManager=factory.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第三步，将SecurityManager设置到系统运行环境，和spring整合后会将SecurityManager配置到spring容器中，一般单例管理</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第四步，创建subject</span></span><br><span class="line">        Subject subject=SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建token令牌,这里的用户名和密码以后由用户输入</span></span><br><span class="line">        UsernamePasswordToken token=<span class="keyword">new</span> UsernamePasswordToken(<span class="string">"zhangsan"</span>,<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//执行认证，将用户输入的信息同数据库(即.ini配置文件)中信息进行对比</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (AuthenticationException e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"认证状态:"</span>+subject.isAuthenticated());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//认证通过后才能执行授权</span></span><br><span class="line">        <span class="comment">//第一种授权方式是基于角色的授权,hasRole传入角色的标识</span></span><br><span class="line">        <span class="keyword">boolean</span> ishasRole=subject.hasRole(<span class="string">"role1"</span>);<span class="comment">//该用户是否有role1这个角色</span></span><br><span class="line">        System.out.println(<span class="string">"单个角色判断"</span>+ishasRole);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//hasAllRoles是否拥有多个角色</span></span><br><span class="line">        <span class="keyword">boolean</span> hasAllRoles=subject.hasAllRoles(Arrays.asList(<span class="string">"role1"</span>,<span class="string">"role2"</span>));</span><br><span class="line">        System.out.println(<span class="string">"多个角色判断"</span>+hasAllRoles);<span class="comment">//角色的就讲到这里了，后面我们都是通过资源进行权限讲解</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用check方法进行授权，如果授权不通过会抛出异常</span></span><br><span class="line">        subject.checkRole(<span class="string">"role3"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二种授权方式是基于资源的授权,isPermitted传入权限标识符</span></span><br><span class="line">        <span class="keyword">boolean</span> isPermitted=subject.isPermitted(<span class="string">"user:create"</span>);<span class="comment">//该用户是否有对user资源进行创建的权限</span></span><br><span class="line">        System.out.println(<span class="string">"单个权限判断"</span>+isPermitted);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//多个权限判断</span></span><br><span class="line">        <span class="keyword">boolean</span> isPermittedAll=subject.isPermittedAll(<span class="string">"user:create:1"</span>,<span class="string">"user:update"</span>);</span><br><span class="line">        System.out.println(<span class="string">"多个权限判断:"</span>+isPermittedAll);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从测试代码中我们可以知道，只有当用户信息得到认证后才能对用户进行授权操作。  </p>
<p>上面只是一个简单的入门程序，从代码中直接读取数据库(即配置文件)中的权限数据，然后将其与代码中的给定权限进行判断看该用户是否具有该权限，而实际操作中我们是通过Realm进行读取数据库中的数据的。所以接下来讲自定义Realm进行授权。  </p>
<h2 id="5-自定义Realm进行授权"><a href="#5-自定义Realm进行授权" class="headerlink" title="5.自定义Realm进行授权"></a>5.自定义Realm进行授权</h2><h3 id="5-1需求"><a href="#5-1需求" class="headerlink" title="5.1需求"></a>5.1需求</h3><p>上边的程序通过shiro-permission.ini对权限信息进行静态配置，实际开发中从数据库中获取权限数据。就需要自定义realm，由realm从数据库查询权限数据。  </p>
<p>realm根据用户身份查询权限数据，将权限数据返回给authorizer(授权器)。  </p>
<h3 id="5-2自定义Realm"><a href="#5-2自定义Realm" class="headerlink" title="5.2自定义Realm"></a>5.2自定义Realm</h3><p>在上篇文章自定义的realm中即CustomRealm.java，修改doGetAuthorizationInfo()方法，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//上边是进行认证的方法，在上篇文章中已完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于授权，当然首先要实现认证</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//从principals获取主身份信息</span></span><br><span class="line">       <span class="comment">//将getPrimaryPrincipal方法返回值转为真实身份类型(在上边的goGetAuthenticationInfo认证通过填充到SimpleAuthenticationInfo)</span></span><br><span class="line">       String userCode= (String) principals.getPrimaryPrincipal();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//根据身份信息获取权限信息,</span></span><br><span class="line">       <span class="comment">//模拟从数据库中获取到的动态权限数据</span></span><br><span class="line">       List&lt;String&gt; permissions=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       permissions.add(<span class="string">"user:create"</span>);<span class="comment">//模拟user的创建权限</span></span><br><span class="line">       permissions.add(<span class="string">"items:add"</span>);<span class="comment">//模拟商品的添加权限</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//查到权限数据，返回授权信息(包括上边的permissions)</span></span><br><span class="line">       SimpleAuthorizationInfo simpleAuthorizationInfo=<span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//将上边查询到授权信息填充到simpleAuthorizationInfo对象中</span></span><br><span class="line">       simpleAuthorizationInfo.addStringPermissions(permissions);</span><br><span class="line">       <span class="keyword">return</span> simpleAuthorizationInfo;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后要对该自定义Realm进行配置，即将自定义Realm放入SecurityManager中，上篇文章中的shiro-realm.ini配置文件中我们已实现。  </p>
<p>然后便可以进行测试了，测试代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义realm进行资源授权测试</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAuthorizationCustomRealm</span><span class="params">()</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="comment">//第一步，创建SecurityManager工厂</span></span><br><span class="line">       Factory&lt;SecurityManager&gt; factory=<span class="keyword">new</span> IniSecurityManagerFactory(<span class="string">"classpath:config/shiro-realm.ini"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第二步:创建SecurityManager</span></span><br><span class="line">       SecurityManager securityManager=factory.getInstance();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第三步，将SecurityManager设置到系统运行环境，和spring整合后会将SecurityManager配置到spring容器中，一般单例管理</span></span><br><span class="line">       SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//第四步，创建subject</span></span><br><span class="line">       Subject subject=SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//创建token令牌,这里的用户名和密码以后由用户输入</span></span><br><span class="line">       UsernamePasswordToken token=<span class="keyword">new</span> UsernamePasswordToken(<span class="string">"zhangsan"</span>,<span class="string">"111111"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//执行认证，将用户输入的信息同数据库(即.ini配置文件)中信息进行对比</span></span><br><span class="line">           subject.login(token);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (AuthenticationException e)</span><br><span class="line">       &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"认证状态:"</span>+subject.isAuthenticated());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">//基于资源的授权,调用isPermitted方法会调用CustomRealm从数据库查询正确的权限数据</span></span><br><span class="line">       <span class="comment">// isPermitted传入权限标识符，判断user:create:1是否在CustomRealm查询到的权限数据之内</span></span><br><span class="line">       <span class="keyword">boolean</span> isPermitted=subject.isPermitted(<span class="string">"user:create:1"</span>);<span class="comment">//该用户是否有对user的1资源进行创建的权限</span></span><br><span class="line">       System.out.println(<span class="string">"单个权限判断"</span>+isPermitted);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//多个权限判断</span></span><br><span class="line">       <span class="keyword">boolean</span> isPermittedAll=subject.isPermittedAll(<span class="string">"user:create:1"</span>,<span class="string">"user:create"</span>);</span><br><span class="line">       System.out.println(<span class="string">"多个权限判断:"</span>+isPermittedAll);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>代码(即授权流程讲解)讲解如下:  </p>
<ol>
<li>对subject进行授权，调用方法isPermitted（”permission串”）。</li>
<li>SecurityManager执行授权，通过ModularRealmAuthorizer执行授权。</li>
<li>ModularRealmAuthorizer执行realm（自定义的CustomRealm）从数据库查询权限数据。即调用realm的授权方法:<code>doGetAuthorizationInfo()</code>。</li>
<li>realm从数据库查询权限数据，返回ModularRealmAuthorizer。</li>
<li>ModularRealmAuthorizer调用PermissionResolver进行权限串比对。</li>
<li>如果比对后，isPermitted中”permission串”在realm查询到权限数据中，说明用户访问permission串有权限，否则 没有权限，抛出异常。</li>
</ol>
<p>上述我们也是对数据库中的明文进行的讲解，这里就不对数据库中的密文进行讲解了。经过如上入门程序，我们便了解了如何通过Shiro来完成授权功能了，接下来我要完成Shiro与web项目整合的各个功能讲解了，详情请见我往后的文章Shiro系列。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Shiro之实现认证]]></title>
      <url>http://codingxiaxw.cn/2016/11/21/48-shiro-authentication/</url>
      <content type="html"><![CDATA[<p>与其它java开源框架类似，将shiro的jar包加入项目就可以使用shiro提供的功能了。shiro-core是核心包必须选用，还提供了与web整合的shiro-web、与spring整合的shiro-spring、与任务调度quartz整合的shiro-quartz等jar包。  </p>
<a id="more"></a>
<p><strong>写在前面的话:</strong>本篇文章只是通过一个入门程序教大家学会使用Shiro实现认证功能(包括普通认证和经过散列算法对密码进行加密后的认证)，没有将Shiro同Spring整合起来使用(后面的文章我们会讲解Shiro整合web开发环境的项目中如何实现认证功能，见<a href="http://codingxiaxw.cn/2016/11/23/50-Shiro-Integration/">Shiro整合Web项目及整合后的开发</a>)，所以我们采用的jar包很少:shiro-core.jar、junit测试jar包、commons-logging.jar。</p>
<h2 id="1-认证的概念"><a href="#1-认证的概念" class="headerlink" title="1.认证的概念"></a>1.认证的概念</h2><p>身份认证,即在应用中谁能证明他就是他本人。一般提供如他们的身份ID一些标识信息来表明他就是他本人，如提供身份证，用户名/密码来证明。<br>在shiro中，用户需要提供principals （身份）和credentials（证明）给shiro，从而应用能验证用户身份:  </p>
<ul>
<li>principals：身份，即主体的标识属性，可以是任何东西，如用户名、邮箱等，唯一即可。一个主体可以有多个principals，但只有一个Primary principals，一般是用户名/密码/手机号。</li>
<li>credentials：证明/凭证，即只有主体知道的安全值，如密码/数字证书等。</li>
</ul>
<p>最常见的principals和credentials组合就是用户名/密码了。接下来先通过一个入门程序进行一个基本的身份认证。</p>
<p>另外两个相关的概念是之前提到的Subject及Realm，分别是主体及验证主体的数据源。</p>
<h2 id="2-Shiro认证流程"><a href="#2-Shiro认证流程" class="headerlink" title="2.Shiro认证流程"></a>2.Shiro认证流程</h2><p>Shiro认证流程图如下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-20%20%E4%B8%8B%E5%8D%8811.21.08.png" alt="">  </p>
<p>文字描述认证流程:  </p>
<ol>
<li>首先调用Subject.login(token)进行登录，其会自动委托给SecurityManager，调用之前必须通过SecurityUtils. setSecurityManager()设置。</li>
<li>SecurityManager负责真正的身份验证逻辑；它会委托给Authenticator进行身份验证。</li>
<li>Authenticator才是真正的身份验证者，Shiro API中核心的身份认证入口点，此处可以自定义插入自己的实现。</li>
<li>Authenticator可能会委托给相应的AuthenticationStrategy进行多Realm身份验证，默认ModularRealmAuthenticator会调用AuthenticationStrategy进行多Realm身份验证。</li>
<li>Authenticator会把相应的token传入Realm，从Realm获取身份验证信息，如果没有返回/抛出异常表示身份验证失败了。此处可以配置多个Realm，将按照相应的顺序及策略进行访问。</li>
</ol>
<p>通过Shiro认证流程图，我们在用Shiro完成认证功能时就要完全按照这个流程去写代码。导入上述所说的3个jar包后我们就可以开始写Shiro认证的入门程序了。</p>
<h2 id="3-Shiro认证入门程序"><a href="#3-Shiro认证入门程序" class="headerlink" title="3.Shiro认证入门程序"></a>3.Shiro认证入门程序</h2><p>本入门程序是通过模仿用户的登录与退出来完成认证。我们将用户登录时输入的信息与数据库中的信息进行比较，只有二者信息符合时就说明用户认证通过了。</p>
<h3 id="3-1创建shiro-first-ini"><a href="#3-1创建shiro-first-ini" class="headerlink" title="3.1创建shiro-first.ini"></a>3.1创建shiro-first.ini</h3><p>在src包下创建名为shiro-first.ini文件，程序中我们没有连接到数据库，所以采用后缀为ini的文件来模拟数据库中的数据。该文件中的数据如下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-20%20%E4%B8%8B%E5%8D%8811.29.24.png" alt="">  </p>
<p>在.ini文件中通过<code>[users]</code>指定了两个主体(Subject):用户名zhangsan和密码111111、用户名lisi和密码22222。这样在.ini文件中配置就相当于模拟了数据库中的两条用户信息。</p>
<h3 id="3-2编写入门程序"><a href="#3-2编写入门程序" class="headerlink" title="3.2编写入门程序"></a>3.2编写入门程序</h3><p>我们接下来就参照上述认证流程图来写认证的程序，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationTest</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//用户的登录和退出</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoginAndLogout</span><span class="params">()</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//创建securityManager工厂</span></span><br><span class="line">        Factory&lt;SecurityManager&gt; factory=<span class="keyword">new</span> IniSecurityManagerFactory(</span><br><span class="line">                <span class="string">"classpath:shiro-first.ini"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建SecurityManager</span></span><br><span class="line">        SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将securityManager设置到当前的运行环境中</span></span><br><span class="line">        SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//丛SecurityUtils里边的到一个subject</span></span><br><span class="line">        Subject subject = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在认证提交前准备token（令牌）</span></span><br><span class="line">        <span class="comment">// 模拟用户输入的账号和密码，将来是由用户输入进去从页面传送过来</span></span><br><span class="line">        UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"zhangsan"</span>,</span><br><span class="line">                <span class="string">"111111"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 执行认证提交</span></span><br><span class="line">            subject.login(token);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">            <span class="comment">// 认证失败</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否认证通过</span></span><br><span class="line">        <span class="keyword">boolean</span> isAuthenticated = subject.isAuthenticated();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"是否认证通过："</span> + isAuthenticated);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 退出操作</span></span><br><span class="line">        subject.logout();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，输出<code>是否认证通过:true</code>。因为该用户输入的信息和数据库中的信息匹配，所以认证成功。代码讲解:  </p>
<ol>
<li>首先通过new IniSecurityManagerFactory并指定一个ini配置文件来创建一个SecurityManager工厂。</li>
<li>接着获取SecurityManager并绑定到SecurityUtils，这是一个全局设置，设置一次即可。</li>
<li>通过SecurityUtils得到Subject，其会自动绑定到当前线程；如果在web环境在请求结束时需要解除绑定；然后获取身份验证的Token(即用户输入的信息)，如用户名/密码。</li>
<li>调用subject.login方法进行登录，其会自动委托给SecurityManager.login方法进行登录。</li>
<li>如果身份验证失败请捕获<code>AuthenticationException或其子类</code>异常，常见的如 :<code>DisabledAccountException（禁用的帐号）</code>、<code>LockedAccountException（锁定的帐号）</code>、<code>UnknownAccountException（错误的帐号）</code>、<code>ExcessiveAttemptsException（登录失败次数过多）</code>、<code>IncorrectCredentialsException （错误的凭证）</code>、<code>ExpiredCredentialsException（过期的凭证）</code>等，具体请查看其继承关系;对于页面的错误消息展示，最好使用如“用户名/密码错误”而不是“用户名错误”/“密码错误”，防止一些恶意用户非法扫描帐号库。</li>
<li>最后可以调用subject.logout退出，其会自动委托给SecurityManager.logout方法退出。</li>
</ol>
<p>从如上代码可总结出身份验证的步骤:</p>
<ol>
<li>收集用户身份/凭证，即如用户名/密码。</li>
<li>调用Subject.login进行登录，如果失败将得到相应的AuthenticationException异常，根据异常提示用户错误信息；否则登录成功。</li>
<li>最后调用Subject.logout进行退出操作。</li>
</ol>
<p>从上面的测试类中我们发现的几个问题:1、用户名/密码硬编码在ini配置文件，以后需要改成如数据库存储，且密码需要加密存储。2、用户身份Token可能不仅仅是用户名/密码，也可能还有其他的，如登录时允许用户名/邮箱/手机号同时登录。</p>
<p>上面我们是直接访问数据库(.ini文件)的，而我们真正用到Shiro时是通过Realm来访问数据库的，在这里也应该是通过Realm来访问.ini配置文件。所以下面我们来讲讲通过上面提到的Realm完成认证功能。</p>
<h2 id="4-自定义Realm"><a href="#4-自定义Realm" class="headerlink" title="4.自定义Realm"></a>4.自定义Realm</h2><p>实际开发中我们通过realm从数据库中查询用户信息，所以realm的作用可想而知:根据token中的身份信息去查询数据库（入门程序我们使用ini配置文件模拟数据库），如果查到用户则返回认证信息，如果查询不到就返回null。</p>
<p>在Shiro架构中，realm接口中的java代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">//返回一个唯一的Realm名字  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(AuthenticationToken token)</span></span>; <span class="comment">//判断此Realm是否支持此Token  </span></span><br><span class="line"></span><br><span class="line"><span class="function">AuthenticationInfo <span class="title">getAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span>  </span><br><span class="line"><span class="keyword">throws</span> AuthenticationException</span>;  <span class="comment">//根据Token获取认证信息</span></span><br></pre></td></tr></table></figure></p>
<p>而往往我们都是自定义Realm，所以我们需要自定义一个CustomRealm.java文件并让它继承AuthorizingRealm抽象类，在sric包下创建一个realm包，在realm包中创建我们的自定义Realm，java代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置realm的名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"customRealm"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//token是用户输入的</span></span><br><span class="line">        <span class="comment">//第一步:丛token中取出身份信息</span></span><br><span class="line">        String userCode= (String) token.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二步:根据用户输入的userCode丛数据库查询</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟从数据库查询到的密码</span></span><br><span class="line">        String password=<span class="string">"111111"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果查不到返回null，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果查询到，返回认证信息AuthenticationInfo</span></span><br><span class="line"></span><br><span class="line">        SimpleAuthenticationInfo simpleAuthenticationInfo=<span class="keyword">new</span></span><br><span class="line">                SimpleAuthenticationInfo(userCode,password,<span class="keyword">this</span>.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> simpleAuthenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于授权，该功能在下篇文章中进行讲解</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1配置自定义Realm"><a href="#4-1配置自定义Realm" class="headerlink" title="4.1配置自定义Realm"></a>4.1配置自定义Realm</h3><p>自定义Realm的代码实现后，我们就需要将这个自定义的Realm进行配置，在src包下创建一个shiro-reaml.ini文件(你也可以在先前我们创建的shiro-first.ini文件下进行修改)，而该配置文件跟我们入门程序中的配置文件是不一样的，入门程序中的配置文件是模拟的数据库，而这里的配置文件是将Realm进行配置，数据库中的信息我们在自定义Reaml的代码中已进行模拟，内容如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-21%20%E4%B8%8B%E5%8D%883.05.39.png" alt="">  </p>
<p>内容中的解释也在注释中给出，内容中的属性值customRealm任意取，不一定要跟Reaml实现java代码中方法setName()的值一样，当然若是你自定义了多个Realm，那么配置文件中的内容如下:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#声明多个realm  </span><br><span class="line">customRealm1=realm.CustomRealme2  </span><br><span class="line">customRealme=realm.CustomRealme2 </span><br><span class="line">#指定securityManager的realms实现  </span><br><span class="line">securityManager.realms=$myRealm1,$myRealm2</span><br></pre></td></tr></table></figure></p>
<p>完成自定义Realm的代码实现并配置后，我们便可进行该Reaml的测试了，测试代码如下，仍然模拟的用户登录认证:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户的登录和退出</span></span><br><span class="line">  <span class="meta">@Test</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCustomRealm</span><span class="params">()</span></span><br><span class="line">  </span>&#123;</span><br><span class="line">      <span class="comment">//创建securityManager工厂</span></span><br><span class="line">      Factory&lt;SecurityManager&gt; factory=<span class="keyword">new</span> IniSecurityManagerFactory(</span><br><span class="line">              <span class="string">"classpath:shiro-realm.ini"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建SecurityManager</span></span><br><span class="line">      SecurityManager securityManager = factory.getInstance();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将securityManager设置到当前的运行环境汇中</span></span><br><span class="line">      SecurityUtils.setSecurityManager(securityManager);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//丛SecurityUtils里边创建一个</span></span><br><span class="line">      Subject subject = SecurityUtils.getSubject();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 在认证提交前准备token（令牌）</span></span><br><span class="line">      <span class="comment">// 这里的账号和密码 将来是由用户输入进去</span></span><br><span class="line">      UsernamePasswordToken token = <span class="keyword">new</span> UsernamePasswordToken(<span class="string">"zhangsan"</span>,</span><br><span class="line">              <span class="string">"111111"</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">// 执行认证提交</span></span><br><span class="line">          subject.login(token);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (AuthenticationException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否认证通过</span></span><br><span class="line">      <span class="keyword">boolean</span> isAuthenticated = subject.isAuthenticated();</span><br><span class="line"></span><br><span class="line">      System.out.println(<span class="string">"是否认证通过："</span> + isAuthenticated);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，控制台输出认证通过，说明用户输入的信息与数据库(配置文件)中的信息符合，所以用户认证成功。这样我们便通过Shiro完成了认证功能的实现。  </p>
<p><strong>扩展:</strong>看到这里相信你就会使用Shiro完成认证功能了，但是这里我们是通过用户输入的密码直接去查询数据库中的明文密码，而往往为了保护用户信息所以数据库中的密码都是经过了MD5的算法进行加密后才放入数据库的，所以实际开发中我们需要通过Shiro获取数据库中经过md5加密后的密码来和用户输入的密码进行比对。所以接下来我要讲Shiro中是如何将用户输入的信息与数据库中的加密信息进行对比从而实现的认证。</p>
<h2 id="5-散列算法"><a href="#5-散列算法" class="headerlink" title="5.散列算法"></a>5.散列算法</h2><p>实际开发中为了保护用户信息的安全，我们需要对用户在注册时输入的密码进行加密后再保存到数据库，当用户登录时我们也要将用户输入的密码进行加密后再与数据库中的密码进行比对。即需要对密码进行散列，常用的散列方法有md5、sha。  </p>
<p>用md5算法对密码进行散列的问题:如果知道散列后的值可以通过穷举算法得到md5密码对应的明文。解决方法:建议对md5进行散列时加salt（盐），进行加密相当于对原始密码+盐进行散列。  </p>
<h3 id="5-1自定义realm支持散列算法"><a href="#5-1自定义realm支持散列算法" class="headerlink" title="5.1自定义realm支持散列算法"></a>5.1自定义realm支持散列算法</h3><p>那么接下来我们就讲解上述reaml支持散列算法的测试，在realm包下新建CustomRealmMd5.java类，并再里面模仿数据库中的用户名和加密密文，内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomRealmMd5</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置realm的名称</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setName(<span class="string">"customRealmMd5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于认证</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(</span><br><span class="line">            AuthenticationToken token)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// token是用户输入的</span></span><br><span class="line">        <span class="comment">// 第一步从token中取出身份信息</span></span><br><span class="line">        String userCode = (String) token.getPrincipal();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第二步：根据用户输入的userCode从数据库查询</span></span><br><span class="line">        <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查询不到返回null</span></span><br><span class="line">        <span class="comment">// 数据库中用户账号是zhangsansan</span></span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 * if(!userCode.equals("zhangsansan"))&#123;// return null; &#125;</span><br><span class="line">		 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模拟根据用户名从数据库查询到的密码,散列值</span></span><br><span class="line">        String password = <span class="string">"f3694f162729b7d0254c6e40260bf15c"</span>;</span><br><span class="line">        <span class="comment">// 从数据库获取salt</span></span><br><span class="line">        String salt = <span class="string">"qwerty"</span>;</span><br><span class="line">        <span class="comment">//上边散列值和盐对应的明文：111111</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果查询到返回认证信息AuthenticationInfo</span></span><br><span class="line">        SimpleAuthenticationInfo simpleAuthenticationInfo = <span class="keyword">new</span> SimpleAuthenticationInfo(</span><br><span class="line">                userCode, password, ByteSource.Util.bytes(salt), <span class="keyword">this</span>.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> simpleAuthenticationInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于授权</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(</span><br><span class="line">            PrincipalCollection principals)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-2在realm中配置凭证匹配器"><a href="#5-2在realm中配置凭证匹配器" class="headerlink" title="5.2在realm中配置凭证匹配器"></a>5.2在realm中配置凭证匹配器</h3><p>然后对该自定义支持md5算法的Realm进行配置，在src包下创建shiro-realm-md5.ini文件，内容如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">#自定凭证匹配器</span><br><span class="line">credentialsMatcher=org.apache.shiro.authc.credential.HashedCredentialsMatcher</span><br><span class="line">#散列的算法</span><br><span class="line">credentialsMatcher.hashAlgorithmName=md5</span><br><span class="line">#散列的次数</span><br><span class="line">credentialsMatcher.hashIterations=1</span><br><span class="line"></span><br><span class="line">#将凭证匹配器设置到我们定义的realm</span><br><span class="line">customRealm=realm.CustomRealmMd5</span><br><span class="line">customRealm.credentialsMatcher=$credentialsMatcher</span><br><span class="line">securityManager.realms=$customRealm</span><br></pre></td></tr></table></figure></p>
<h3 id="5-3测试"><a href="#5-3测试" class="headerlink" title="5.3测试"></a>5.3测试</h3><p>然后便可进行我们支持md5算法的realm测试了，测试代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MD5Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//注解用的main方法进行测试，你也可以通过junit.jar进行测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//模拟用户输入的密码</span></span><br><span class="line">        String source=<span class="string">"111111"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加入我们的盐salt</span></span><br><span class="line">        String salt=<span class="string">"qwerty"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//密码11111经过散列1次得到的密码:f3694f162729b7d0254c6e40260bf15c</span></span><br><span class="line">        <span class="keyword">int</span> hashIterations=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造方法中：</span></span><br><span class="line">        <span class="comment">//第一个参数：明文，原始密码</span></span><br><span class="line">        <span class="comment">//第二个参数：盐，通过使用随机数</span></span><br><span class="line">        <span class="comment">//第三个参数：散列的次数，比如散列两次，相当 于md5(md5(''))</span></span><br><span class="line">        Md5Hash md5Hash=<span class="keyword">new</span> Md5Hash(source,salt,hashIterations);</span><br><span class="line"></span><br><span class="line">        String password_md5=md5Hash.toString();</span><br><span class="line"></span><br><span class="line">        System.out.println(password_md5);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到此，我们便介绍完Shiro的认证功能(包括普通认证和实际开发中的经过散列算法后的认证)，当然只是一个简单的入门程序，将来我会讲解实际开发中(整合了Shiro的项目)如何通过Shiro查询数据库为大家深入讲解，下篇文章我将介绍Shiro的授权功能。见下篇文章<a href="">Shiro之实现授权</a></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[初识Shiro]]></title>
      <url>http://codingxiaxw.cn/2016/11/20/47-first-Shiro/</url>
      <content type="html"><![CDATA[<p>Shiro是Apache的一个权限管理框架，鉴于很多人对权限管理的概念都不是很清楚，所以我在正式介绍Shiro前我会谈谈权限管理的概念。</p>
<a id="more"></a>
<h2 id="1-权限管理"><a href="#1-权限管理" class="headerlink" title="1.权限管理"></a>1.权限管理</h2><h3 id="1-1什么是权限管理"><a href="#1-1什么是权限管理" class="headerlink" title="1.1什么是权限管理"></a>1.1什么是权限管理</h3><p>只要有用户参与的系统一般都要有权限管理，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略<strong>控制</strong>用户可以访问而且只能访问自己被授权的<strong>资源</strong>。权限管理包括<strong>用户认证</strong>和<strong>用户授权</strong>两部分</p>
<h3 id="1-2用户认证"><a href="#1-2用户认证" class="headerlink" title="1.2用户认证"></a>1.2用户认证</h3><p>用户认证，用户去访问系统，系统要验证用户身份的合法性。最常用的用户身份验证的方法：1、用户名密码方式。2、指纹打卡机。3、基于证书验证方法。只有当系统验证用户身份合法，用户才可访问系统的资源。</p>
<h4 id="1-2-1用户认证流程"><a href="#1-2-1用户认证流程" class="headerlink" title="1.2.1用户认证流程"></a>1.2.1用户认证流程</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-21%20%E4%B8%8B%E5%8D%8810.44.10.png" alt="">  </p>
<h4 id="1-2-2关键对象"><a href="#1-2-2关键对象" class="headerlink" title="1.2.2关键对象"></a>1.2.2关键对象</h4><p><strong>subject:</strong>主体，理解为用户,可能是程序、网络爬虫等，都要去访问系统的资源，系统需要对subject进行身份认证。  </p>
<p><strong>principal:</strong>身份信息，通常是唯一的，一个主体还有多个身份信息，但是都有一个主身份信息（primary principal）。  </p>
<p><strong>credential:</strong>凭证信息，可以是密码 、证书、指纹。  </p>
<p><strong>总结:</strong>主体在进行身份认证时需要提供身份信息和凭证信息。</p>
<h3 id="1-3用户授权"><a href="#1-3用户授权" class="headerlink" title="1.3用户授权"></a>1.3用户授权</h3><p>用户授权，简单理解为访问控制，在用户认证通过后(注意只有当用户认证通过后才能对用户进行授权)，系统对用户访问资源进行控制，用户具有资源的访问权限方可访问。</p>
<h4 id="1-3-1授权流程"><a href="#1-3-1授权流程" class="headerlink" title="1.3.1授权流程"></a>1.3.1授权流程</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-21%20%E4%B8%8B%E5%8D%8810.53.58.png" alt="">  </p>
<h4 id="1-3-2关键对象"><a href="#1-3-2关键对象" class="headerlink" title="1.3.2关键对象"></a>1.3.2关键对象</h4><p>授权的过程理解为：who对what(which)进行how操作。</p>
<p><strong>who:</strong>主体即subject，subject在认证通过后系统进行访问控制。  </p>
<p><strong>what(which):</strong>资源(Resource)，subject必须具备资源的访问权限才可访问该 资源。资源比如：系统用户列表页面、商品修改菜单、商品id为001的商品信息。资源分为资源类型和资源实例:系统的用户信息就是资源类型，相当于java类;系统中id为001的用户就是资源实例，相当于new的java对象。  </p>
<p><strong>how:</strong>权限/许可(permission) ，针对资源的权限或许可，subject具有permission访问资源，如何访问/操作需要定义permission，权限比如:用户添加、用户修改、商品删除。</p>
<h4 id="1-3-3权限模型"><a href="#1-3-3权限模型" class="headerlink" title="1.3.3权限模型"></a>1.3.3权限模型</h4><p>对1.3.2节提到的主体、资源、权限通过数据模型表示,标准权限数据模型包括 :用户(账号和密码)、角色(角色名称)、权限（包括资源和权限）、用户角色关系(用户id、角色id)、角色权限关系(角色id、权限id)。如下图:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-21%20%E4%B8%8B%E5%8D%8811.06.37.png" alt="">  </p>
<p>而通常企业开发中将资源表和权限表合并为一张权限表，如下图:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-21%20%E4%B8%8B%E5%8D%8811.07.47.png" alt="">  </p>
<p>上图常被称为权限管理的通用模型，不过企业在开发中根据系统自身的特点还会对上图进行修改，但是用户、角色、权限、用户角色关系、角色权限关系是需要去理解的。</p>
<h3 id="1-3-4分配权限"><a href="#1-3-4分配权限" class="headerlink" title="1.3.4分配权限"></a>1.3.4分配权限</h3><p>用户需要分配相应的权限才可访问相应的资源。权限是对于资源的操作许可。  </p>
<p>通常给用户分配资源权限需要将权限信息持久化，比如存储在关系数据库中。  </p>
<p>把用户信息、权限管理、用户分配的权限信息写到数据库（权限数据模型）。</p>
<h3 id="1-3-5权限控制-授权的核心"><a href="#1-3-5权限控制-授权的核心" class="headerlink" title="1.3.5权限控制(授权的核心)"></a>1.3.5权限控制(授权的核心)</h3><p>权限的控制分为基于角色的访问控制和基于资源的访问控制。  </p>
<p>基于角色的访问控制:RBAC((role  based  access  control)。比如:系统角色包括 :部门经理、总经理。（角色针对用户来划分）。  </p>
<p>系统代码中的实现为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果该user是部门经理则可以访问if中的代码</span></span><br><span class="line"><span class="keyword">if</span>(user.hasRole(<span class="string">'部门经理'</span>))&#123;</span><br><span class="line">	<span class="comment">//系统资源内容</span></span><br><span class="line">	<span class="comment">//用户报表查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>基于角色的访问控制出现的问题:角色针对人划分的，人作为用户在系统中属于活动内容，如果该 角色可以访问的资源出现变更，需要修改你的代码了，比如：需要变更为部门经理和总经理都可以进行用户报表查看，代码改为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.hasRole(<span class="string">'部门经理'</span>) || user.hasRole(<span class="string">'总经理'</span>)  )&#123;</span><br><span class="line">	<span class="comment">//系统资源内容</span></span><br><span class="line">	<span class="comment">//用户报表查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可知基于角色的访问控制是不利于系统维护(可扩展性不强)。  </p>
<p>而对于基于资源的访问控制:RBAC(Resource  based  access  control)。因为资源在系统中是不变的，比如资源有:类中的方法，页面中的按钮。对资源的访问需要具有permission权限，代码可以写为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(user.hasPermission (<span class="string">'用户报表查看（权限标识符）'</span>))&#123;</span><br><span class="line">	<span class="comment">//系统资源内容</span></span><br><span class="line">	<span class="comment">//用户报表查看</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上边的方法就可以解决用户角色变更不用修改上边权限控制的代码。如果需要变更权限只需要在分配权限模块去操作，给部门经理或总经理增或删除权限。所以在实际开发中我们建议使用基于资源的访问控制实现权限管理。</p>
<h3 id="1-4权限管理解决方案"><a href="#1-4权限管理解决方案" class="headerlink" title="1.4权限管理解决方案"></a>1.4权限管理解决方案</h3><h4 id="1-4-1什么是粗粒度和细粒度权限"><a href="#1-4-1什么是粗粒度和细粒度权限" class="headerlink" title="1.4.1什么是粗粒度和细粒度权限"></a>1.4.1什么是粗粒度和细粒度权限</h4><p><strong>粗粒度权限管理:</strong>对资源类型的权限管理。资源类型比如:菜单、url连接、用户添加页面、用户信息、类方法、页面中按钮。粗粒度权限管理比如:超级管理员可以访问户添加页面、用户信息等全部页面。部门管理员可以访问用户信息页面包括 页面中所有按钮。  </p>
<p><strong>细粒度权限管理:</strong>对资源实例的权限管理。资源实例就资源类型的具体化，比如:用户id为001的修改连接，1110班的用户信息、行政部的员工。细粒度权限管理就是数据级别的权限管理。细粒度权限管理比如:部门经理只可以访问本部门的员工信息，用户只可以看到自己的菜单，大区经理只能查看本辖区的销售订单。</p>
<p><strong>粗粒度和细粒度例子:</strong>系统有一个用户列表查询页面，对用户列表查询分权限，如果粗颗粒管理，张三和李四都有用户列表查询的权限，张三和李四都可以访问用户列表查询。<br>进一步进行细颗粒管理，张三（行政部）和李四(开发部)只可以查询自己本部门的用户信息。张三只能查看行政部 的用户信息，李四只能查看开发部门的用户信息。细粒度权限管理就是数据级别的权限管理。</p>
<h4 id="1-4-2如何实现粗粒度和细粒度权限管理"><a href="#1-4-2如何实现粗粒度和细粒度权限管理" class="headerlink" title="1.4.2如何实现粗粒度和细粒度权限管理"></a>1.4.2如何实现粗粒度和细粒度权限管理</h4><p><strong>如何实现粗粒度权限管理？</strong>  </p>
<p>粗粒度权限管理比较容易将权限管理的代码抽取出来在系统架构级别统一处理。比如:通过springmvc的拦截器实现授权。  </p>
<p><strong>如何实现细粒度权限管理？</strong>  </p>
<p>对细粒度权限管理在数据级别是没有共性可言，针对细粒度权限管理就是系统业务逻辑的一部分，如果在业务层去处理相对比较简单，如果将细粒度权限管理统一在系统架构级别去抽取，比较困难，即使抽取的功能可能也存在扩展不强。  </p>
<p>建议细粒度权限管理在业务层去控制。比如:部门经理只查询本部门员工信息，在service接口提供一个部门id的参数，controller中根据当前用户的信息得到该 用户属于哪个部门，调用service时将部门id传入service，实现该用户只查询本部门的员工。</p>
<h2 id="2-什么是Shiro"><a href="#2-什么是Shiro" class="headerlink" title="2.什么是Shiro"></a>2.什么是Shiro</h2><p>Apache Shiro是Java的一个权限管理框架，相比Spring框架中的权限管理框架Spring Security,Spring Security和Spring的依赖过于紧密，没有Shiro使用简单，而且Shiro不依赖Spring，它不仅可以实现web应用的权限管理，还可以实现c/s系统、分布式系统权限管理。  </p>
<p>Shiro属于轻量框架，可以帮助我们完成:认证、授权、加密、会话管理、与Web集成、缓存等功能,所以越来越多企业项目开始使用Shiro。而且Shiro的API也是非常简单，其基本功能点如下图:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-20%20%E4%B8%8B%E5%8D%8810.41.57.png" alt="">  </p>
<p>解释:</p>
<ul>
<li><strong>Authentication:</strong>身份认证/登录，验证用户是不是拥有相应的身份。</li>
<li><strong>Authorization:</strong>授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限。</li>
<li><strong>Session Manager:</strong>会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的。</li>
<li><strong>Cryptography:</strong>加密，保护数据的安全性，如密码加密存储到数据库，而不是明文(所谓明文，就是我们输入的文字例如登录列表的用户名和密码)存储。</li>
<li><strong>Web Support:</strong>Web支持，可以非常容易的集成到Web环境。</li>
<li><strong>Caching:</strong>缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率。</li>
<li><strong>Concurrency:</strong>shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。</li>
<li><strong>Testing:</strong>提供测试支持。</li>
<li><strong>Run As:</strong>允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</li>
<li><strong>Remember Me:</strong>记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ul>
<p><strong>记住一点:</strong>Shiro不会去维护用户、维护权限，这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。</p>
<p>接下来我们分别从外部和内部来看看Shiro的架构，对于一个好的框架，从外部来看应该具有非常简单易于使用的API，且API契约明确；从内部来看的话，其应该有一个可扩展的架构，即非常容易插入用户自定义实现，因为任何框架都不能满足所有需求。  </p>
<h2 id="3-Shiro架构"><a href="#3-Shiro架构" class="headerlink" title="3.Shiro架构"></a>3.Shiro架构</h2><h3 id="3-1从外部看Shiro架构"><a href="#3-1从外部看Shiro架构" class="headerlink" title="3.1从外部看Shiro架构"></a>3.1从外部看Shiro架构</h3><p>从外部看Shiro，即从应用程序的角度来观察如何使用Shiro完成工作。如下图Apache官网为我们提供的一张Shiro的架构图:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-20%20%E4%B8%8B%E5%8D%8810.46.22.png" alt="">  </p>
<p>解释:应用代码直接交互的对象是Subject，也就是说Shiro的对外API核心就是Subject；图中每个API的含义:  </p>
<ul>
<li><strong>Subject:</strong>主体，代表了当前“用户”，这个用户不一定是一个具体的人，与当前应用交互的任何东西都是Subject，如网络爬虫，机器人等；即一个抽象概念；所有Subject都绑定到SecurityManager，与Subject的所有交互都会委托给SecurityManager；可以把Subject认为是一个门面；SecurityManager才是实际的执行者。</li>
<li><strong>SecurityManager:</strong>安全管理器；即所有与安全有关的操作都会与SecurityManager交互；且它管理着所有Subject；可以看出它是Shiro的核心，它负责与后边介绍的其他组件进行交互，如果学习过SpringMVC，你可以把它看成DispatcherServlet前端控制器。</li>
<li><strong>Realm:</strong>域，Shiro从从Realm获取安全数据（如用户、角色、权限），就是说SecurityManager要验证用户身份，那么它需要从Realm获取相应的用户进行比较以确定用户身份是否合法；也需要从Realm得到用户相应的角色/权限进行验证用户是否能进行操作；可以把Realm看成DataSource，即安全数据源。</li>
</ul>
<p>也就是说对于我们而言，最简单的一个Shiro应用都是经过如下步骤:  </p>
<p>1、应用代码通过Subject来进行认证和授权，而Subject又委托给SecurityManager。  </p>
<p>2、我们需要给Shiro的SecurityManager注入Realm，从而让SecurityManager能得到合法的用户及其权限进行判断。</p>
<p>从以上也可以看出，Shiro不提供维护用户/权限，而是通过Realm让开发人员自己注入。  </p>
<h3 id="3-2从内部看Shiro架构"><a href="#3-2从内部看Shiro架构" class="headerlink" title="3.2从内部看Shiro架构"></a>3.2从内部看Shiro架构</h3><p>架构图如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-20%20%E4%B8%8B%E5%8D%8810.53.01.png" alt="">  </p>
<p>分析:  </p>
<ul>
<li><strong>Subject:</strong>主体，可以看到主体可以是任何可以与应用交互的“用户”。</li>
<li><strong>SecurityManager:</strong>相当于SpringMVC中的DispatcherServlet或者Struts2中的FilterDispatcher；是Shiro的心脏；所有具体的交互都通过SecurityManager进行控制；它管理着所有Subject、且负责进行认证和授权、及会话、缓存的管理。</li>
<li><strong>Authenticator:</strong>认证器，负责主体认证的，这是一个扩展点，如果用户觉得Shiro默认的不好，可以自定义实现；其需要认证策略（Authentication Strategy），即什么情况下算用户认证通过了。</li>
<li><strong>Authrizer:</strong>授权器，或者访问控制器，用来决定主体是否有权限进行相应的操作；即控制着用户能访问应用中的哪些功能。</li>
<li><strong>Realm:</strong>可以有1个或多个Realm，可以认为是安全实体数据源，即用于获取安全实体的；可以是JDBC实现，也可以是LDAP实现，或者内存实现等等；由用户提供；注意：Shiro不知道你的用户/权限存储在哪及以何种格式存储；所以我们一般在应用中都需要实现自己的Realm。</li>
<li><strong>SessionManager:</strong>如果写过Servlet就应该知道Session的概念，Session呢需要有人去管理它的生命周期，这个组件就是SessionManager；而Shiro并不仅仅可以用在Web环境，也可以用在如普通的JavaSE环境、EJB等环境；所有呢，Shiro就抽象了一个自己的Session来管理主体与应用之间交互的数据；这样的话，比如我们在Web环境用，刚开始是一台Web服务器；接着又上了台EJB服务器；这时想把两台服务器的会话数据放到一个地方，这个时候就可以实现自己的分布式会话（如把数据放到Memcached服务器）。</li>
<li><strong>SessionDAO:</strong>DAO大家都用过，数据访问对象，用于会话的CRUD，比如我们想把Session保存到数据库，那么可以实现自己的SessionDAO，通过如JDBC写到数据库；比如想把Session放到Memcached中，可以实现自己的Memcached SessionDAO；另外SessionDAO中可以使用Cache进行缓存，以提高性能；</li>
<li><strong>CacheManager:</strong>缓存控制器，来管理如用户、角色、权限等的缓存的；因为这些数据基本上很少去改变，放到缓存中后可以提高访问的性能。</li>
<li><strong>Cryptography:</strong>密码模块，Shiro提高了一些常见的加密组件用于如密码加密/解密的。</li>
</ul>
<p>到此Shiro的架构及组件就介绍完了，接下来我会总结关于如何使用这些组件。见下篇文章<a href="http://codingxiaxw.cn/2016/11/21/48-shiro-authentication/">Shiro之实现认证</a>  </p>
<p>本篇文章参考:<a href="http://jinnianshilongnian.iteye.com/blog/2018936" target="_blank" rel="external">张开涛:跟我学Shiro之Shiro简介</a>   </p>
<p>正如孔老先生所言:你对看到的、学到的知识不加以整理，又怎么会融会贯通成为你自己的知识呢?</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SSM注解开发的高级知识讲解]]></title>
      <url>http://codingxiaxw.cn/2016/11/19/46-ssm%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<p>经过前面两篇文章<a href="http://codingxiaxw.cn/2016/11/15/45-smm%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">SSM的整合和一个案例带你快速入门SSM开发</a>的讲解后，我们已经顺利的了解了利用SSM进行开发的基础知识，本篇文章将为你介绍更负责的高级知识，例如数据回显、参数绑定list数据、图片的上传、json数据的请求和响应、validation分组校验、统一异常处理、RESTful支持以及拦截器的应用。</p>
<a id="more"></a>   
<p>当然此篇文章也是在前篇文章开发的工程基础上进行讲解。<a href="https://github.com/codingXiaxw/ssm2" target="_blank" rel="external">源码请点击这里前往我的github</a></p>
<h2 id="1-数据回显"><a href="#1-数据回显" class="headerlink" title="1.数据回显"></a>1.数据回显</h2><p>需求:当提交表单时出现错误，回到表单重新填写数据时需要将刚才提交的参数在页面回显。以往我们采用将数据放在request域中然后请求转发到表单页面，运用el表达式将数据回显。在springmvc中我们通过Model对象的addAttribute(“id”,id),将简单类型的数据传入request域(注意在进入修改页面的controller方法中和提交修改商品信息方法model.addAttribute方法设置的key一致)。通过Model的addAttribute(“pojo”,pojo)方法将pojo类型的数据也是传入到request域中，然后通过el表达式完成取出request域中的数据，这是pojo类型数据回显的第一种方法，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/editItemSubmit"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemSubmit</span><span class="params">(Model model,Integer id,ItemsCustom itemsCustom)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="comment">//进行数据回显</span></span><br><span class="line">   model.addAttribute(<span class="string">"id"</span>,id);</span><br><span class="line">   model.addAttribute(<span class="string">"item"</span>,itemsCustom);</span><br><span class="line">   </span><br><span class="line">   itemsService.updateItems(id,itemsCustom);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"editItem"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二种方法是通过@ModelAttribute()注解的方式，括号内传入要回显的pojo对象，如我们这里要将itemsCustom传到request域所以我们这样写<code>@ModelAttribute(value=&quot;itemsCustom&quot;)</code>，然后便可以将代码中的将model添加到request域的代码<code>model.addAttribute(&quot;item&quot;,itemsCustom);</code>注释掉了。  </p>
<p><strong>@ModelAttribute()注解的另外一种用法:</strong>将方法的返回值填入到request域然后显示在页面上。在ItemsController.java中加入方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单独将商品类型的方法提取出来，将方法返回值填充到request域，在页面提示</span></span><br><span class="line"><span class="meta">@ModelAttribute</span>(<span class="string">"itemsType"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String,String&gt; <span class="title">getItemsType</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;String,String&gt; itemsType=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    itemsType.put(<span class="string">"001"</span>,<span class="string">"data type"</span>);</span><br><span class="line">    itemsType.put(<span class="string">"002"</span>,<span class="string">"clothes"</span>);</span><br><span class="line">    <span class="keyword">return</span> itemsType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后我们在itemsList.jsp页面中加入如下标签进行页面的展示:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;itemsType&#125;"</span> <span class="attr">var</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"$&#123;item.key&#125;"</span>&gt;</span>$&#123;item.value&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>成功使用@ModleAttribute注解将方法返回值返回到页面。其实这种注解的方式也是将数据填入到request域中，然后在页面中通过el表达式取出，同model.addAttribute()方法和modelAndView.addObject()方法。  </p>
<p>使用@ModelAttribute将公用的取数据的方法返回值传到页面，不用在每一个controller方法通过Model将数据传到页面。</p>
<h2 id="2-将页面信息绑定到参数集合类型中"><a href="#2-将页面信息绑定到参数集合类型中" class="headerlink" title="2.将页面信息绑定到参数集合类型中"></a>2.将页面信息绑定到参数集合类型中</h2><p>前面的基础知识讲解中我们都只是将简单类型和pojo类型的数据绑定到了参数中。接下来讲解高级知识的绑定。  </p>
<h3 id="2-1将页面信息绑定到数组参数中"><a href="#2-1将页面信息绑定到数组参数中" class="headerlink" title="2.1将页面信息绑定到数组参数中"></a>2.1将页面信息绑定到数组参数中</h3><p>需求:在商品查询列表页面，用户选择要删除的商品，批量删除商品。  </p>
<p>在controller方法中如何将批量提交的数据绑定成数组类型。  </p>
<p>页面的定义,在itemsList.jsp中每件商品前面添加一个checkbox:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">"delete_id"</span> <span class="attr">value</span>=<span class="string">"$&#123;item.id&#125;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在上方添加一个批量删除的按钮:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"批量删除"</span> <span class="attr">onclick</span>=<span class="string">"deleteItems()"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>因为我们form的action是点击查询后返回到itemsList.action，所以这里我们点击delete_id按钮应该返回到另一个action所以需要编写一个js脚本对该按钮进行事件监听。</p>
<p>以及点击这个按钮响应的事件:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">	<span class="function"><span class="keyword">function</span> <span class="title">deleteItems</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">//将form的action指向删除商品的地址</span></span><br><span class="line">		<span class="built_in">document</span>.itemsForm.action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/items/deleteItems.action"</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//进行form提交</span></span><br><span class="line">		<span class="built_in">document</span>.itemsForm.submit();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后需要在contronller中添加deleteItems()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除商品</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/deleteItems"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteItems</span><span class="params">(Integer[] delete_id)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//调用serive方法删除商品</span></span><br><span class="line">    <span class="comment">//这里我们就是简单的介绍完成将页面的信息绑定到数组中，所以service的方法你可以自己去完成</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后定义一个success.jsp页面输出成功删除的信息即可。</p>
<h3 id="2-2绑定页面信息到List中"><a href="#2-2绑定页面信息到List中" class="headerlink" title="2.2绑定页面信息到List中"></a>2.2绑定页面信息到List<object>中</object></h3><p>需求:批量修改商品信息提交。先进入批量修改商品页面，填写信息，点击提交。  </p>
<p>页面的定义,新建一个editItemsList.jsp页面，内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> <span class="attr">prefix</span>=<span class="string">"c"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span>  <span class="attr">prefix</span>=<span class="string">"fmt"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>批量修改商品查询<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">updateItems</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="comment">//将form的action指向删除商品的地址</span></span><br><span class="line">			<span class="built_in">document</span>.itemsForm.action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/items/deleteItems.action"</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">//进行form提交</span></span><br><span class="line">			<span class="built_in">document</span>.itemsForm.submit();</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">"itemsForm"</span> <span class="attr">action</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/items/queryItem.action"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">查询条件：</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;itemsType&#125;"</span> <span class="attr">var</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">				<span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"$&#123;item.key&#125;"</span>&gt;</span>$&#123;item.value&#125;<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"></span><br><span class="line">			<span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"查询"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"批量修改提交"</span> <span class="attr">onclick</span>=<span class="string">"updateItems()"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">商品列表：</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品价格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>生产日期<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品描述<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;itemsList &#125;"</span> <span class="attr">var</span>=<span class="string">"item"</span> <span class="attr">varStatus</span>=<span class="string">"s"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"itemsList[$&#123;s.index&#125;].name"</span> <span class="attr">value</span>=<span class="string">"$&#123;item.name&#125;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"itemsList[$&#123;s.index&#125;].price"</span> <span class="attr">value</span>=<span class="string">"$&#123;item.price&#125;"</span>&gt;</span> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">fmt:formatDate</span> <span class="attr">value</span>=<span class="string">"$&#123;item.createtime&#125;"</span> <span class="attr">pattern</span>=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;item.detail &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在controller中加入如下两个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//批量修改商品查询</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/editItemsList"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">editItemsList</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//调用servie来查询商品列表</span></span><br><span class="line">       List&lt;ItemsCustom&gt; itemsList=itemsService.findItemsList(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">       ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">       modelAndView.addObject(<span class="string">"itemsList"</span>,itemsList);</span><br><span class="line">       <span class="comment">//指定逻辑视图名itemsList.jsp</span></span><br><span class="line">       modelAndView.setViewName(<span class="string">"editItemsList"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> modelAndView;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//批量修改商品的提交</span></span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/editItemsListSubmit"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">editItemsListSubmit</span><span class="params">(ItemsQueryVo itemsQueryVo)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在xml页面中的name属性值的定义是很重要的，因为在我们提交表单后该数据是会绑定到后台中的方法参数中的，这里我们使用<code>itemsList[${s.index}].name</code>作为name的属性值，所以我们在controller的submit方法中添加了一个ItemsQueryVo的参数，若想完成绑定则需要在ItemsQueryVo中定义一个itemsList的属性，如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsQueryVo</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//商品信息</span></span><br><span class="line">	<span class="keyword">private</span> ItemsCustom itemsCustom;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个list</span></span><br><span class="line">	<span class="keyword">private</span> List&lt;ItemsCustom&gt; itemsList;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;ItemsCustom&gt; <span class="title">getItemsList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> itemsList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemsList</span><span class="params">(List&lt;ItemsCustom&gt; itemsList)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.itemsList = itemsList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ItemsCustom <span class="title">getItemsCustom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> itemsCustom;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemsCustom</span><span class="params">(ItemsCustom itemsCustom)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.itemsCustom = itemsCustom;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注释:<br><code>itemsList:</code>controller方法形参包装类型中list的属性名。<br><code>itemsList[0]或itemsList[1]...</code>的[]中是序号，从0开始。<br><code>itemsList[].name:</code>中name就是controller方法形参包装类型中list中pojo的属性名。(有点绕口)  </p>
<h2 id="3-商品图片的上传"><a href="#3-商品图片的上传" class="headerlink" title="3.商品图片的上传"></a>3.商品图片的上传</h2><p>需求:在商品修改页面，增加图片上传的功能。  </p>
<p>操作流程:用户进入商品修改页面,上传图片,点击提交（提交的是图片和商品信息,再次进入修改页面，图片在商品修改页面展示。  </p>
<h3 id="3-1图片存储问题"><a href="#3-1图片存储问题" class="headerlink" title="3.1图片存储问题"></a>3.1图片存储问题</h3><p>切记：不要把图片上传到工程目录 ，不方便进行工程维护。实际电商项目中使用专门图片服务器(http，比如apache、tomcat)。本教程使用图片虚拟目录，通过虚拟目录访问硬盘上存储的图片目录。  </p>
<p>我用的是开发工具为IDEA，虚拟目录的设置为,1.打开tomcat的设置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%883.38.02.png" alt="">  </p>
<p>2.点击External Source:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%883.39.28.png" alt="">  </p>
<p>3.进入到如下页面:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%883.39.43.png" alt="">  </p>
<p>选择硬盘上的一个路径作为虚拟目录的位置，以后上传的图片都会放在此路径上。并在Application context中添加一个在服务器上访问的路径别名，我这里设置的为<code>/pic</code>。若想访问该目录下的图片，则在浏览器网站上输入:<code>http://localhost:8080/pic/图片名称</code>，(不需要写项目名称)，即可在浏览器中成功访问到该图片。  </p>
<p><strong>注意:</strong>图片目录中尽量进行目录分级存储，提高访问速度（提交i/o）</p>
<h3 id="3-2配置图片上传解析器"><a href="#3-2配置图片上传解析器" class="headerlink" title="3.2配置图片上传解析器"></a>3.2配置图片上传解析器</h3><p>springmvc使用commons-fileupload进行图片上传。  </p>
<p>需要导入的jar包为:commons-fileupload-1.2.2.jar和依赖包commons-io-2.4.jar。  </p>
<p>然后在springmvc中配置图片上传解析器:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 文件上传</span><br><span class="line">   CommonsMultipartResolver依赖我们传入的fileupload jar包--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span></span><br><span class="line">         <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 设置上传文件的最大尺寸为5MB --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">value</span>&gt;</span>5242880<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="3-3编写上传图片的页面"><a href="#3-3编写上传图片的页面" class="headerlink" title="3.3编写上传图片的页面"></a>3.3编写上传图片的页面</h3><p>在editItem.jsp中添加图片的文件表单项:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span>商品图片<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">c:if</span> <span class="attr">test</span>=<span class="string">"$&#123;itemsCustom.pic&#125;!=null"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/pic/$&#123;itemsCustom.pic&#125;"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">c:if</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"pictureFile"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>另外涉及到文件表单项的地方需要在form标签中添加<code>enctype=&quot;multipart/form-data&quot;</code>的属性。  </p>
<h3 id="3-4编写controller方法"><a href="#3-4编写controller方法" class="headerlink" title="3.4编写controller方法"></a>3.4编写controller方法</h3><p>修改edititemSubmit方法，添加参数图片进行页面的图片信息与参数的绑定:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/editItemSubmit"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">editItemSubmit</span><span class="params">(Model model,Integer id,</span><br><span class="line">                                 @Validated(value = &#123;ValidGroup1.class&#125;)</span> @<span class="title">ModelAttribute</span><span class="params">(value = <span class="string">"itemsCustom"</span>)</span> ItemsCustom itemsCustom,</span><br><span class="line">                                 BindingResult bindingResult,</span><br><span class="line">                                 <span class="comment">//上传图片</span></span><br><span class="line">                                 MultipartFile pictureFile</span><br><span class="line">                                 ) <span class="keyword">throws</span> Exception</span><br><span class="line">    </span>&#123;</span><br><span class="line">     <span class="comment">//进行数据回显</span></span><br><span class="line">        model.addAttribute(<span class="string">"id"</span>,id);</span><br><span class="line"><span class="comment">//        model.addAttribute("item",itemsCustom);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//进行图片的上传</span></span><br><span class="line">        <span class="keyword">if</span> (pictureFile!=<span class="keyword">null</span>&amp;&amp;pictureFile.getOriginalFilename()!=<span class="keyword">null</span>&amp;&amp;pictureFile.getOriginalFilename().length()&gt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//图片上传成功后，将图片的地址写到数据库</span></span><br><span class="line">            String filePath=<span class="string">"/Users/codingBoy/Pictures/"</span>;<span class="comment">//它的值要同你设置虚拟目录时涉及的目录路径一致，</span></span><br><span class="line">            String originalFilename=pictureFile.getOriginalFilename();</span><br><span class="line"></span><br><span class="line">            String newFileName= UUID.randomUUID()+originalFilename.substring(originalFilename.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新文件</span></span><br><span class="line">            File file=<span class="keyword">new</span> File(filePath+newFileName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将内存中的文件写入磁盘</span></span><br><span class="line">            pictureFile.transferTo(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//图片上传成功</span></span><br><span class="line">            itemsCustom.setPic(newFileName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        itemsService.updateItems(id,itemsCustom);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line"><span class="comment">//        return "forward:queryItems.action";</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"editItem"</span>;</span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">        <span class="comment">//return "redirect:queryItems.action";</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后运行程序，在修改商品信息的页面上传图片，成功上传后便可在你设置的虚拟目录中找到你上传的图片。  </p>
<h2 id="4-json数据的交互"><a href="#4-json数据的交互" class="headerlink" title="4.json数据的交互"></a>4.json数据的交互</h2><p>需求:json数据格式是比较简单容易理解，json数据格式常用于远程接口传输，http传输json数据，非常方便页面进行提交/请求结果解析，对json数据的解析。</p>
<h3 id="4-1springmvc解析json需要加入的json解析包"><a href="#4-1springmvc解析json需要加入的json解析包" class="headerlink" title="4.1springmvc解析json需要加入的json解析包"></a>4.1springmvc解析json需要加入的json解析包</h3><p>Springmvc默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入jackson的包:jackson-core-sal-1.9.11.jar和jackson-mapper-asl-1.9.11.jar。  </p>
<h3 id="4-2在处理器适配器中加入MappingJacksonHttpMessageConverter配置"><a href="#4-2在处理器适配器中加入MappingJacksonHttpMessageConverter配置" class="headerlink" title="4.2在处理器适配器中加入MappingJacksonHttpMessageConverter配置"></a>4.2在处理器适配器中加入MappingJacksonHttpMessageConverter配置</h3><p>在springmvc的处理器适配器的配置中加入如下配置信息:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--加入json数据的消息转换器</span><br><span class="line">      MappingJacksonHttpMessageConverter依赖jackson的两个jar包--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"messageConverters"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.http.converter.json.MappingJacksonHttpMessageConverter"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-RequestBody和-ResponseBody注解"><a href="#4-3-RequestBody和-ResponseBody注解" class="headerlink" title="4.3@RequestBody和@ResponseBody注解"></a>4.3@RequestBody和@ResponseBody注解</h3><p>@RequestBody:将请求的json数据转成java对象。<br>@ResponseBody:将java对象转成json数据输出。  </p>
<p>图解:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%884.02.01.png" alt="">  </p>
<h3 id="4-4测试1-请求的是json数据，响应的也是json数据"><a href="#4-4测试1-请求的是json数据，响应的也是json数据" class="headerlink" title="4.4测试1:请求的是json数据，响应的也是json数据"></a>4.4测试1:请求的是json数据，响应的也是json数据</h3><p>在controller包下写一个json测试类的controller叫jsonTest.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonTest</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求的json响应json，请求商品信息(该信息为json格式，在页面中通过ajax向写入用户请求的json信息，需要加入@RequestBody注解)，商品信息用json格式输出商品信息(请求的url实际返回的是itemsCustom对象，但由于使用了@ResponseBody就将返回的pojo对象转换成了json格式的数据)</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/requestJson"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">ItemsCustom <span class="title">requestJson</span><span class="params">(@RequestBody ItemsCustom itemsCustom)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> itemsCustom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在web包下创建一个请求数据的页面jsonTest.jsp,代码如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>json测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/js/jquery-1.4.4.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line"></span><br><span class="line"><span class="comment">//请求json响应json</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requestJson</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		url:<span class="string">"$&#123;pageContext.request.contextPath &#125;/requestJson.action"</span>,</span><br><span class="line">		type:<span class="string">"post"</span>,</span><br><span class="line">		contentType:<span class="string">"application/json;charset=utf-8"</span>,</span><br><span class="line">		<span class="comment">//请求json数据,使用json表示商品信息</span></span><br><span class="line">		data:<span class="string">'&#123;"name":"手机","price":1999&#125;'</span>,</span><br><span class="line">		success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">			</span><br><span class="line">			alert(data.name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"请求json响应json"</span> <span class="attr">onclick</span>=<span class="string">"requestJson()"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"请求key/value响应json"</span> <span class="attr">onclick</span>=<span class="string">"responseJson()"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>测试追踪，在浏览器中输入:<code>http://localhost:8080/SpringMvcMybatis/jsonTest.jsp</code>直接访问改页面，点击<code>请求json响应json</code>按钮，通过抓包的方式，我们看到服务器上放回的信息为:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%884.16.17.png" alt=""></p>
<h3 id="4-5测试2-请求key-value数据，响应的json数据"><a href="#4-5测试2-请求key-value数据，响应的json数据" class="headerlink" title="4.5测试2:请求key/value数据，响应的json数据"></a>4.5测试2:请求key/value数据，响应的json数据</h3><p>在jsonTest.java中加入方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求key/value(在页面中通过ajax写入用户想要请求的key/value信息，不需要加@RequestBody注解)，响应json(由于action返回的是itemsCustom对象，所以需要加入@ResponseBody注解将pojo对象转换为json格式响应给用户)</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/responseJson"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">ItemsCustom <span class="title">responseJson</span><span class="params">(ItemsCustom itemsCustom)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> itemsCustom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在页面中加入如下代码:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求key/value响应json</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">responseJson</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	$.ajax(&#123;</span><br><span class="line">		url:<span class="string">"$&#123;pageContext.request.contextPath &#125;/responseJson.action"</span>,</span><br><span class="line">		type:<span class="string">"post"</span>,</span><br><span class="line">		<span class="comment">//contentType:"application/json;charset=utf-8",</span></span><br><span class="line">		<span class="comment">//请求key/value数据</span></span><br><span class="line">		data:<span class="string">"name=手机&amp;price=1999"</span>,</span><br><span class="line">		success:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">			</span><br><span class="line">			alert(data.name);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试追踪，在浏览器中输入网址，点击<code>请求key/value响应json</code>按钮，通过抓包的方式我们发现丛服务器上返回过来的信息为:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%884.20.04.png" alt="">  </p>
<p>可以看到，我们请求的是key/value数据，而服务器返回的信息是json格式的数据。  </p>
<h3 id="4-6小结"><a href="#4-6小结" class="headerlink" title="4.6小结"></a>4.6小结</h3><p>如果前端处理没有特殊要求建议使用第二种，请求key/value，响应json，方便客户端解析请求结果。  </p>
<h2 id="5validation校验-了解"><a href="#5validation校验-了解" class="headerlink" title="5validation校验(了解)"></a>5validation校验(了解)</h2><p>对前端的校验大多数通过js在页面校验，这种方法比较简单，如果对安全性考虑，还要在后台校验。  </p>
<p>springmvc使用JSR-303（javaEE6规范的一部分）校验规范，springmvc使用的是Hibernate Validator（和Hibernate的ORM无关）。  </p>
<h3 id="5-1加入Hibernate-Validator的jar"><a href="#5-1加入Hibernate-Validator的jar" class="headerlink" title="5.1加入Hibernate Validator的jar"></a>5.1加入Hibernate Validator的jar</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%884.23.53.png" alt="">  </p>
<h3 id="5-2在处理器适配器中配置校验器"><a href="#5-2在处理器适配器中配置校验器" class="headerlink" title="5.2在处理器适配器中配置校验器"></a>5.2在处理器适配器中配置校验器</h3><p>在springmvc.xml中的自定义webBinder标签中加入如下标签:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validator"</span> <span class="attr">ref</span>=<span class="string">"validator"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里引入了一个validator，所以我们需要在springmvc.xml中还需要加入validator的配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"validator"</span></span><br><span class="line">          <span class="attr">class</span>=<span class="string">"org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"providerClass"</span> <span class="attr">value</span>=<span class="string">"org.hibernate.validator.HibernateValidator"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 如果不指定则默认使用classpath下的ValidationMessages.properties --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationMessageSource"</span> <span class="attr">ref</span>=<span class="string">"messageSource"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 校验错误信息配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageSource"</span></span><br><span class="line">          <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ReloadableResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basenames"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>CustomValidationMessages<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fileEncodings"</span> <span class="attr">value</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"cacheSeconds"</span> <span class="attr">value</span>=<span class="string">"120"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后在src包下创建一个CustomValidationMessages.properties文件，内容为:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#校验提示信息:items.name.length.error要写在java代码中</span><br><span class="line">items.name.length.error=商品名称的长度请限制在1到30个字符</span><br><span class="line">items.createtime.is.notnull=请输入商品的生产日期</span><br></pre></td></tr></table></figure></p>
<h3 id="5-3校验规则"><a href="#5-3校验规则" class="headerlink" title="5.3校验规则"></a>5.3校验规则</h3><p>需求:商品信息提交时校验 ，商品生产日期不能为空，商品名称长度在1到30字符之间。  </p>
<p>另外首先需要知道的是规则应该在pojo对象的相应属性上规定。</p>
<p>修改pojo的Items.java内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Items</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">1</span>,max = <span class="number">30</span>,message = <span class="string">"&#123;items.name.length.error&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Float price;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="meta">@NotNull</span>(message=<span class="string">"&#123;items.createtime.is.notnull&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date createtime;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">&#125;</span><br><span class="line">省略了相应的setter和getter方法。</span><br></pre></td></tr></table></figure></p>
<p>通过上面的操作我们定义了校验的规则，那么当违反了上述规则后我们该如何捕获错误呢?需要修改controller方法，在要校验的pojo前边加上@Validated注解，在editItemSubmit()方法中添加如下内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//商品提交页面</span></span><br><span class="line">    <span class="comment">//itemsQueryVo是包装类型的pojo</span></span><br><span class="line">    <span class="comment">//在@Validated中定义使用ValidGroup1组下边的校验</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/editItemSubmit"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">editItemSubmit</span><span class="params">(Model model,Integer id,</span><br><span class="line">                                 @Validated @ModelAttribute(value = <span class="string">"itemsCustom"</span>)</span> ItemsCustom itemsCustom,</span><br><span class="line">                                 BindingResult bindingResult,</span><br><span class="line">                                 <span class="comment">//上传图片</span></span><br><span class="line">                                 MultipartFile pictureFile</span><br><span class="line">                                 ) <span class="keyword">throws</span> Exception</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//输出校验错误信息</span></span><br><span class="line">        <span class="comment">//如果参数绑定时出错</span></span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//获取错误</span></span><br><span class="line">            List&lt;ObjectError&gt; errors=bindingResult.getAllErrors();</span><br><span class="line"></span><br><span class="line">            model.addAttribute(<span class="string">"errors"</span>,errors);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (ObjectError error:errors)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//输出错误信息</span></span><br><span class="line">                System.out.println(error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果校验错误，仍然回到商品修改页面</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"editItem"</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">      ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后是在页面editItem.jsp中展示错误:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--错误信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;errors&#125;"</span> <span class="attr">var</span>=<span class="string">"error"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">color</span>=<span class="string">"red"</span>&gt;</span>$&#123;error.defaultMessage&#125;<span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>运行程序，在修改商品信息的页面当我们没有输入日起或是将商品名称超过了20个字符时便不能完成页面的跳转而是在该修改页面显示错误信息。  </p>
<p>以上我们便通过Validation完成了校验。下面我们来谈谈分组校验:针对不同的controller方法通过分组校验达到个性化校验的目的。</p>
<h3 id="5-4分组校验"><a href="#5-4分组校验" class="headerlink" title="5.4分组校验"></a>5.4分组校验</h3><p>需求:修改商品修改功能，只校验生产日期不能为空。  </p>
<p>第一步:创建分组接口,创建一个ValidGroup1.java接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidGroup1</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//接口不定义方法，相当于接口就是个类型，只标识哪些校验规则属于该ValidGroup1分组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步:定义校验规则属于哪个校验分组:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过groups指定此校验属于哪个分组，当然可以指定多个分组</span></span><br><span class="line">   <span class="meta">@NotNull</span>(message=<span class="string">"&#123;items.createtime.is.notnull&#125;"</span>,groups = &#123;ValidGroup1.class&#125;)</span><br><span class="line">   <span class="keyword">private</span> Date createtime;</span><br></pre></td></tr></table></figure></p>
<p>而属性name的校验规则没有添加groups属性。  </p>
<p>第三步:在controller方法定义使用校验的分组。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItemSubmit</span><span class="params">(Model model,Integer id,</span><br><span class="line">                              @Validated(value = &#123;ValidGroup1.class&#125;)</span> @<span class="title">ModelAttribute</span><span class="params">(value = <span class="string">"itemsCustom"</span>)</span> ItemsCustom itemsCustom,</span><br><span class="line">                              BindingResult bindingResult,</span><br><span class="line">                              <span class="comment">//上传图片</span></span><br><span class="line">                              MultipartFile pictureFile</span><br><span class="line">                              ) <span class="keyword">throws</span> Exception</span><br><span class="line"> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时运行程序，在编辑商品信息页面中只会进行日期是否为空的校验，而不能进行商品名称信息的校验。因为在pojo的name属性中我们没有指定该校验规则属于哪个分组，所以在controller的方法中就无法定义使用该校验规则的分组，也就无法进行商品名称的校验。  </p>
<h2 id="6-统一异常处理"><a href="#6-统一异常处理" class="headerlink" title="6.统一异常处理"></a>6.统一异常处理</h2><p>需求:一般项目中都需要作异常处理，基于系统架构的设计考虑，使用统一的异常处理方法。  </p>
<p>系统中异常类型有哪些？  </p>
<p>包括预期可能发生的异常、运行时异常（RuntimeException），运行时异常不是预期会发生的。  </p>
<p>针对预期可能发生的异常，在代码手动处理异常可以try/catch捕获，可以向上抛出。  </p>
<p>针对运行时异常，只能通过规范代码质量、在系统测试时详细测试等排除运行时异常。</p>
<h3 id="6-1统一异常处理解决方案"><a href="#6-1统一异常处理解决方案" class="headerlink" title="6.1统一异常处理解决方案"></a>6.1统一异常处理解决方案</h3><h4 id="6-1-2自定义系统异常类"><a href="#6-1-2自定义系统异常类" class="headerlink" title="6.1.2自定义系统异常类"></a>6.1.2自定义系统异常类</h4><p>针对预期可能发生的异常，定义很多异常类型，这些异常类型通常继承于Exception。这里定义一个系统自定义异常类CustomException.java，用于测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//异常信息</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomException</span><span class="params">(String message)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">        <span class="keyword">this</span>.message=message;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-1-2异常处理"><a href="#6-1-2异常处理" class="headerlink" title="6.1.2异常处理"></a>6.1.2异常处理</h4><p>要在一个统一异常处理的类中要处理系统抛出的所有异常，根据异常类型来处理。</p>
<p>统一异常处理的类是什么？</p>
<p>前端控制器DispatcherServlet在进行HandlerMapping、调用HandlerAdapter执行Handler过程中，如果遇到异常，都会调用这个统一异常处理类。当然该类只有实现HandlerExceptionResolver接口才能叫统一异常处理类。  </p>
<h5 id="6-1-2-1定义统一异常处理器类"><a href="#6-1-2-1定义统一异常处理器类" class="headerlink" title="6.1.2.1定义统一异常处理器类"></a>6.1.2.1定义统一异常处理器类</h5><p>创建一个CustomExceptionResolver.java文件并实现HandlerExceptionResolver接口，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//前端控制器DispatcherServlet在进行HandlerMapping、</span></span><br><span class="line">    <span class="comment">// 调用HandlerAdapter执行Handler过程中，如果遇到异常就会执行此方法</span></span><br><span class="line">    <span class="comment">//参数中的handler是最终要执行的Handler，它的真实身份是HandlerMethod</span></span><br><span class="line">    <span class="comment">//ex就是接受到的异常信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest request,</span><br><span class="line">                                         HttpServletResponse response,</span><br><span class="line">                                         Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-1-2-2配置统一异常处理器"><a href="#6-1-2-2配置统一异常处理器" class="headerlink" title="6.1.2.2配置统一异常处理器"></a>6.1.2.2配置统一异常处理器</h5><p>在springmvc.xml文件中加入统一异常处理器的配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义统一异常处理器--&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"exception.CustomExceptionResolver"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="6-1-2-3统一异常处理逻辑"><a href="#6-1-2-3统一异常处理逻辑" class="headerlink" title="6.1.2.3统一异常处理逻辑"></a>6.1.2.3统一异常处理逻辑</h5><p>根据不同的异常类型进行异常处理。</p>
<p>系统自定义的异常类是CustomException ，在controller方法中、service方法中手动抛出此类异常。</p>
<p>针对系统自定义的CustomException异常，就可以直接从异常类中获取异常信息，将异常处理在错误页面展示。<br>针对非CustomException异常，对这类重新构造成一个CustomException，异常信息为“未知错误”，此类错误需要在系统测试阶段去排除。</p>
<p>在统一异常处理器CustomExceptionResolver中实现上边的逻辑。在CustomExceptionResolver.java中加入如下内容实现上述逻辑:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出异常</span></span><br><span class="line">     ex.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="comment">//统一异常处理代码</span></span><br><span class="line">     <span class="comment">//针对系统自定义的CustomException异常，就可以直接从一场中获取一场信息，将异常处理在错误页面展示</span></span><br><span class="line">     <span class="comment">//异常信息</span></span><br><span class="line">     String message=<span class="keyword">null</span>;</span><br><span class="line">     CustomException customException=<span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">//如果ex是系统自定义的异常，我们就直接取出异常信息</span></span><br><span class="line">     <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> CustomException)</span><br><span class="line">     &#123;</span><br><span class="line">         customException= (CustomException) ex;</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         customException=<span class="keyword">new</span> CustomException(<span class="string">"未知错误"</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//错误信息</span></span><br><span class="line">     message=customException.getMessage();</span><br><span class="line"></span><br><span class="line">     request.setAttribute(<span class="string">"message"</span>,message);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">//转向到错误页面</span></span><br><span class="line">         request.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/error.jsp"</span>).forward(request,response);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (ServletException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> ModelAndView();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="6-1-2-4测试抛出异常由统一异常处理器捕获"><a href="#6-1-2-4测试抛出异常由统一异常处理器捕获" class="headerlink" title="6.1.2.4测试抛出异常由统一异常处理器捕获"></a>6.1.2.4测试抛出异常由统一异常处理器捕获</h5><p>可以在controller方法、service方法、dao实现类中抛出异常，要求dao、service、controller遇到异常全部向上抛出异常，方法向 上抛出异常throws Exception。</p>
<p>在ItemsServiceImpl.java的findItemsById方法中添加如下内容:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ItemsCustom <span class="title">findItemsById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Items items=itemsMapper.selectByPrimaryKey(id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果查询的商品信息为空，抛出系统自定义的异常</span></span><br><span class="line">    <span class="keyword">if</span> (items==<span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CustomException(<span class="string">"修改商品信息不存在"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在这里以后随着需求的变化，需要查询商品的其它相关信息，返回到controller</span></span><br><span class="line">    <span class="comment">//所以这个时候用到扩展类更好，如下</span></span><br><span class="line">    ItemsCustom itemsCustom=<span class="keyword">new</span> ItemsCustom();</span><br><span class="line">    <span class="comment">//将items的属性拷贝到itemsCustom</span></span><br><span class="line">    BeanUtils.copyProperties(items,itemsCustom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> itemsCustom;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>图解:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%884.56.44.png" alt="">  </p>
<p>测试:运行程序，在流浪器中我们输入<code>http://localhost:8080/SpringMvcMybatis/items/editItems.action?id=111</code>，由于没有哪个商品信息的id为111，所以出现异常，一旦出现异常，系统会立马走向统一异常处理器，执行统一异常处理器中的程序。</p>
<h2 id="7-RESTful支持"><a href="#7-RESTful支持" class="headerlink" title="7.RESTful支持"></a>7.RESTful支持</h2><h3 id="7-1什么RESTful"><a href="#7-1什么RESTful" class="headerlink" title="7.1什么RESTful"></a>7.1什么RESTful</h3><p>RESTful是一种软件开发理念，RESTful对http进行非常好的诠释。RESTful即Representational State Transfer的缩写。关于RESTful我建议大家去看看这篇文章<a href="http://www.ruanyifeng.com/blog/2011/09/restful.html" target="_blank" rel="external">理解RESTful架构–阮一峰的网络日志</a></p>
<h3 id="7-2url的RESTful实现"><a href="#7-2url的RESTful实现" class="headerlink" title="7.2url的RESTful实现"></a>7.2url的RESTful实现</h3><p>非RESTful的http的url:<code>http://localhost:8080/items/editItems.action?id=1&amp;....</code>  </p>
<p>RESTful的url是简洁的:<code>http:// localhost:8080/items/editItems/1</code>  </p>
<p>参数通过url传递，rest接口返回json数据</p>
<h4 id="7-2-1需求"><a href="#7-2-1需求" class="headerlink" title="7.2.1需求"></a>7.2.1需求</h4><p>根据id查看商品信息，商品信息查看的连接使用RESTful方式实现，商品信息以json返回。</p>
<h4 id="7-2-2第一步更改DispatcherServlet配置"><a href="#7-2-2第一步更改DispatcherServlet配置" class="headerlink" title="7.2.2第一步更改DispatcherServlet配置"></a>7.2.2第一步更改DispatcherServlet配置</h4><p>在web.xml中再添加一个前端控制器:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--RESTful的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc_rest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载springmvc配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置文件的地址</span><br><span class="line">        如果不配置contextConfigLocation，默认查找的配置文件名称是classpath下的:servlet名称+"-servlet.xml"即springmvc-servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:config/spring/springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc_rest<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以配置/：此工程所有的请求全部由springmvc解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析</span><br><span class="line">    可以配置*.do或者*.action,所有请求的url扩展名为.do或.action由springmvc解析，此中方法常用</span><br><span class="line">    不可以配置/*,如果配置/*,返回jsp也由springmvc解析，这是不对的--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--reft方式配置为/--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="7-2-3第二步参数通过url传递"><a href="#7-2-3第二步参数通过url传递" class="headerlink" title="7.2.3第二步参数通过url传递"></a>7.2.3第二步参数通过url传递</h4><p>在controller中添加一个方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更具商品id查看商品信息rest接口</span></span><br><span class="line">   <span class="comment">//@requestMapping中指定restful方式的url中的参数，参数需要用&#123;&#125;包起来</span></span><br><span class="line">   <span class="comment">//@PathVariable将url中的参数和形参进行绑定</span></span><br><span class="line">   <span class="meta">@RequestMapping</span>(<span class="string">"/viewItems/&#123;id&#125;"</span>)</span><br><span class="line">   <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">ItemsCustom <span class="title">viewItems</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id) <span class="keyword">throws</span> Exception</span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="comment">//调用service查询商品的信息</span></span><br><span class="line">       ItemsCustom itemsCustom=itemsService.findItemsById(id);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> itemsCustom;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>此时我们便可以在浏览器中输入<code>http://localhost:8080/SpringMvcMybatis/items/viewItems/1</code>来查看商品信息。  </p>
<p>但是此时会有个bug，我们在web.xml中将访问所有路径的方式设置为:<code>&lt;url-pattern&gt;/&lt;/url-pattern&gt;</code>即访问只要是该路径下的资源时都会经过前端控制器，这是不对的。当我们访问web包下的静态资源时也会经过前端控制器由springmvc解析，这当然是不正确的。所以我们需要设置静态资源的解析，在springmvc.xml中添加如下配置信息:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/js/"</span> <span class="attr">mapping</span>=<span class="string">"/js/**"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>表示访问web/js/包下的静态资源时不会被前端控制器拦截也就不会被springmvc.xml解析。此时便可以正常访问静态资源。</p>
<h2 id="8-springmvc拦截器"><a href="#8-springmvc拦截器" class="headerlink" title="8.springmvc拦截器"></a>8.springmvc拦截器</h2><h3 id="8-1拦截器的应用场合"><a href="#8-1拦截器的应用场合" class="headerlink" title="8.1拦截器的应用场合"></a>8.1拦截器的应用场合</h3><p>用户请求到DispatherServlet中，DispatherServlet调用HandlerMapping查找Handler，HandlerMapping返回一个拦截的链儿（多个拦截），springmvc中的拦截器是通过HandlerMapping发起的。  </p>
<p>在企业开发，使用拦截器实现用户认证（用户登陆后进行身份校验拦截），用户权限拦截。  </p>
<h3 id="8-2springmvc拦截器方法"><a href="#8-2springmvc拦截器方法" class="headerlink" title="8.2springmvc拦截器方法"></a>8.2springmvc拦截器方法</h3><p>定义一个拦截器HandlerInterceptor1.java实现HandlerInterceptor接口:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//在执行handler之前来执行的</span></span><br><span class="line">    <span class="comment">//用于用户认证校验、用户权限校验</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		 <span class="comment">//返回false表示进行拦截，不继续执行handler。返回true表示不进行拦截，继续执行handler</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在执行handerl但是返回modelandview之前来执行</span></span><br><span class="line">    <span class="comment">//如果需要向页面提供一些公用的数据或配置一些视图信息，使用此方法实现从modelAndView入手</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,</span><br><span class="line">                           HttpServletResponse response, Object handler,</span><br><span class="line">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行handler之后执行此方法</span></span><br><span class="line">    <span class="comment">//做系统统一异常处理，进行方法执行性能监控，在prehandler中设置一个时间点，在afterCompletion设置一个时间点，两个时间点的差就是执行时长</span></span><br><span class="line">    <span class="comment">//实现系统统一日志记录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span><br><span class="line">                                Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="8-3测试拦截器"><a href="#8-3测试拦截器" class="headerlink" title="8.3测试拦截器"></a>8.3测试拦截器</h3><p>再定义一个拦截器HandlerInterceptor2.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerInterceptor2</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//在执行handler之前来执行的</span></span><br><span class="line">    <span class="comment">//用于用户认证校验、用户权限校验</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"HandlerInterceptor2....postHandle"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回false表示拦截不继续执行handler，返回true表示放行</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在执行handerl但是返回modelandview之前来执行</span></span><br><span class="line">    <span class="comment">//如果需要向页面提供一些公用的数据或配置一些视图信息，使用此方法实现从modelAndView入手</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,</span><br><span class="line">                           HttpServletResponse response, Object handler,</span><br><span class="line">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"HandlerInterceptor2....postHandler"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行handler之后执行此方法</span></span><br><span class="line">    <span class="comment">//做系统统一异常处理，进行方法执行性能监控，在prehandler中设置一个时间点，在afterCompletion设置一个时间点，两个时间点的差就是执行时长</span></span><br><span class="line">    <span class="comment">//实现系统统一日志记录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span><br><span class="line">                                Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"HandlerInterceptor2....afterCompletion"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="8-3-1配置拦截器"><a href="#8-3-1配置拦截器" class="headerlink" title="8.3.1配置拦截器"></a>8.3.1配置拦截器</h4><p>配置全局的拦截器，DispatcherServlet将配置的全局拦截器加载到所有的HandlerMapping。在springmvc.xml中配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--多个拦截器,顺序执行 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.interceptor.HandlerInterceptor1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.interceptor.HandlerInterceptor2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="8-3-2测试1-拦截器1与2都放行"><a href="#8-3-2测试1-拦截器1与2都放行" class="headerlink" title="8.3.2测试1:拦截器1与2都放行"></a>8.3.2测试1:拦截器1与2都放行</h4><p>测试结果为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HandlerInterceptor1...preHandle</span><br><span class="line">HandlerInterceptor2...preHandle</span><br><span class="line"></span><br><span class="line">HandlerInterceptor2...postHandle</span><br><span class="line">HandlerInterceptor1...postHandle</span><br><span class="line"></span><br><span class="line">HandlerInterceptor2...afterCompletion</span><br><span class="line">HandlerInterceptor1...afterCompletion</span><br></pre></td></tr></table></figure></p>
<p>总结:执行preHandle是顺序执行。执行postHandle、afterCompletion是倒序执行。  </p>
<h4 id="8-3-3测试2-拦截器1放行，2不放行"><a href="#8-3-3测试2-拦截器1放行，2不放行" class="headerlink" title="8.3.3测试2:拦截器1放行，2不放行"></a>8.3.3测试2:拦截器1放行，2不放行</h4><p>此时访问界面，界面是空白的但是不会出现报错信息,控制台打印测试结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HandlerInterceptor1...preHandle</span><br><span class="line">HandlerInterceptor2...preHandle</span><br><span class="line">HandlerInterceptor1...afterCompletion</span><br></pre></td></tr></table></figure></p>
<p>总结:如果preHandle不放行，postHandle、afterCompletion都不执行。只要有一个拦截器不放行，controller不能执行完成。  </p>
<h4 id="8-3-3测试2-拦截器1和2都不放行"><a href="#8-3-3测试2-拦截器1和2都不放行" class="headerlink" title="8.3.3测试2:拦截器1和2都不放行"></a>8.3.3测试2:拦截器1和2都不放行</h4><p>测试结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerInterceptor1...preHandle</span><br></pre></td></tr></table></figure></p>
<p>将这个测试结果和测试2结果进行比较，该测试结果只有拦截器1的preHandle方法执行而2的prehandle方法没有执行；而测试2结果拦截器1和2的preHandle都执行了，说明只有前边的拦截器放行时后面拦截器的preHandle方法才会执行。  </p>
<h3 id="8-4拦截器的应用"><a href="#8-4拦截器的应用" class="headerlink" title="8.4拦截器的应用"></a>8.4拦截器的应用</h3><p>需求:用户访问系统的资源(url)，如果用户没有进行身份认证，进行拦截，系统跳转登陆页面，如果用户已经认证通过，用户可以继续访问系统的资源。  </p>
<h4 id="8-4-1用户登录及退出功能开发"><a href="#8-4-1用户登录及退出功能开发" class="headerlink" title="8.4.1用户登录及退出功能开发"></a>8.4.1用户登录及退出功能开发</h4><p>新建一个controller，LoginController.java,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginController</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户登陆提交方法</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(HttpSession session,String usercode, String password)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//调用service校验用户帐号和密码的正确性</span></span><br><span class="line">        <span class="comment">//这个东西我们讲shiro的时候再写</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果service校验通过，将用户身份记录到session</span></span><br><span class="line">        session.setAttribute(<span class="string">"usercode"</span>,usercode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重定向到商品查询页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/items/queryItems.action"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用户退出</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/logout"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">logout</span><span class="params">(HttpSession session)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//session失效</span></span><br><span class="line">        session.invalidate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重定向到商品查询页面</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/items/queryItems.action"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="8-4-2用户身份认证校验拦截器"><a href="#8-4-2用户身份认证校验拦截器" class="headerlink" title="8.4.2用户身份认证校验拦截器"></a>8.4.2用户身份认证校验拦截器</h4><p>拦截实现的思路:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-19%20%E4%B8%8B%E5%8D%885.29.43.png" alt=""></p>
<h4 id="8-4-3拦截器的编写"><a href="#8-4-3拦截器的编写" class="headerlink" title="8.4.3拦截器的编写"></a>8.4.3拦截器的编写</h4><p>新建一个拦截器LoginInterceptor.java,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//在执行handler之前来执行的</span></span><br><span class="line">    <span class="comment">//用于用户认证校验、用户权限校验</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        String url=request.getRequestURI();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否是公开地址</span></span><br><span class="line">        <span class="comment">//世纪开发中需要将公开地址配置在配置文件中</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (url.indexOf(<span class="string">"login.action"</span>)&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果是公开地址则放行</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户身份在session中是否存在</span></span><br><span class="line">        HttpSession session=request.getSession();</span><br><span class="line">        String usercode= (String) session.getAttribute(<span class="string">"usercode"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果用户身份在session中存在则放行</span></span><br><span class="line">        <span class="keyword">if</span> (usercode!=<span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//执行到这里就拦截，跳转到登陆页面，用户进行登陆</span></span><br><span class="line">        request.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/login.jsp"</span>).forward(request,response);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在执行handerl但是返回modelandview之前来执行</span></span><br><span class="line">    <span class="comment">//如果需要向页面提供一些公用的数据或配置一些视图信息，使用此方法实现从modelAndView入手</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request,</span><br><span class="line">                           HttpServletResponse response, Object handler,</span><br><span class="line">                           ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"HandlerInterceptor1....postHandle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行handler之后执行此方法</span></span><br><span class="line">    <span class="comment">//做系统统一异常处理，进行方法执行性能监控，在prehandler中设置一个时间点，在afterCompletion设置一个时间点，两个时间点的差就是执行时长</span></span><br><span class="line">    <span class="comment">//实现系统统一日志记录</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span><br><span class="line">                                Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"HandlerInterceptor1....afterCompletion"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在springmvc.xml中配置该拦截器，需要注视掉我们之前配置的拦截器:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--拦截器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--多个拦截器,顺序执行 --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--&lt;mvc:interceptor&gt;--&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--&lt;mvc:mapping path="/**"/&gt;--&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--&lt;bean class="controller.interceptor.HandlerInterceptor1"&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--&lt;/mvc:interceptor&gt;--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--&lt;mvc:interceptor&gt;--&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--&lt;mvc:mapping path="/**"/&gt;--&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--&lt;bean class="controller.interceptor.HandlerInterceptor2"&gt;&lt;/bean&gt;--&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--&lt;/mvc:interceptor&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--/**可以拦截路径不管有多少层--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.interceptor.LoginInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后运行程序，当用户访问的不是公开url且用户没有登录时，该拦截器就会将用户的请求拦截并使用户跳转到登录页面进行登录。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="9-联系"><a href="#9-联系" class="headerlink" title="9.联系"></a>9.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一个案例带你快速入门SSM开发]]></title>
      <url>http://codingxiaxw.cn/2016/11/15/45-smm%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>经过上篇文章<a href="http://codingxiaxw.cn/2016/11/15/44-ssm%E7%9A%84%E6%95%B4%E5%90%88/">Spring、Spring MVC与Mybatis整合工程搭建</a>我们便将SSM的环境搭建了，接下来我们便利用这个工程来开发项目带你快速学会使用SSM整合框架进行开发。我们同样采用的是注解处理器映射器与注解处理器适配器进行开发。</p>
<a id="more"></a>
<p><strong>写在前面的话:</strong>源代码请<a href="https://github.com/codingXiaxw/ssm" target="_blank" rel="external">点击这里前往我的github</a></p>
<h2 id="1-实现商品的列表展示"><a href="#1-实现商品的列表展示" class="headerlink" title="1.实现商品的列表展示"></a>1.实现商品的列表展示</h2><h3 id="1-1提出需求"><a href="#1-1提出需求" class="headerlink" title="1.1提出需求"></a>1.1提出需求</h3><p>功能描述:在页面中展示商品列表。</p>
<h3 id="1-2编写表"><a href="#1-2编写表" class="headerlink" title="1.2编写表"></a>1.2编写表</h3><p>sql语句见github中的.sql文件。</p>
<h3 id="1-3持久层mapper的编写"><a href="#1-3持久层mapper的编写" class="headerlink" title="1.3持久层mapper的编写"></a>1.3持久层mapper的编写</h3><p>编写好数据库后我们便可以通过MyBatis逆向工程快速生成对单表映射的sql，包括mapper.java、mapper.xml和pojo类。关于MyBatis逆向工程请见我这篇文章:<a href="http://codingxiaxw.cn/2016/11/13/41-mybatis9%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/">使用IDEA开发MyBatis逆向工程</a></p>
<p>根据逆向工程生成的这三个文件与单表都是一对一的关系，例如通过Items表会生成ItemsMapper.java、ItemsMapper.xml和Items.java的pojo类，这里我们为了便于需求的扩展，所以另外自己编写一个ItemsCustom.java并继承Items.java和Items.java的包装类ItemsQueryVo.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsQueryVo</span> </span>&#123;</span><br><span class="line">	<span class="comment">//商品信息</span></span><br><span class="line">	<span class="keyword">private</span> ItemsCustom itemsCustom;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ItemsCustom <span class="title">getItemsCustom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> itemsCustom;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemsCustom</span><span class="params">(ItemsCustom itemsCustom)</span> 	</span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.itemsCustom = itemsCustom;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后自己编写一个ItemsCustomerMapper.xml:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span><br><span class="line">PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span><br><span class="line">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"mapper.ItemsMapperCustom"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 商品查询的sql片段</span><br><span class="line">	建议是以单表为单位定义查询条件</span><br><span class="line">	建议将常用的查询条件都写出来</span><br><span class="line">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"query_items_where"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"itemsCustom!=null"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"itemsCustom.name!=null and itemsCustom.name!=''"</span>&gt;</span></span><br><span class="line">				and  name like '%$&#123;itemsCustom.name&#125;%'</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"itemsCustom.id!=null"</span>&gt;</span></span><br><span class="line">				and  id = #&#123;itemsCustom.id&#125;</span><br><span class="line">			<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 商品查询 </span><br><span class="line">	parameterType：输入 查询条件</span><br><span class="line">	--&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findItemsList"</span> <span class="attr">parameterType</span>=<span class="string">"po.ItemsQueryVo"</span></span><br><span class="line">			<span class="attr">resultType</span>=<span class="string">"po.ItemsCustom"</span>&gt;</span></span><br><span class="line">		SELECT * FROM items </span><br><span class="line">		<span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"query_items_where"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>与ItemsCustomMapper.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemsMapperCustom</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 商品查询列表</span></span><br><span class="line">	<span class="function">List&lt;ItemsCustom&gt; <span class="title">findItemsList</span><span class="params">(ItemsQueryVo itemsQueryVo)</span></span><br><span class="line">			<span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>至于Mapper的配置我们已经在springmvc.xml中通过spring组件扫描器<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--</span><br><span class="line">MapperScannerConfigurer：mapper的扫描器，将包下边的mapper接口自动创建代理对象，</span><br><span class="line">自动创建到spring容器中，bean的id是mapper的类名（首字母小写）</span><br><span class="line"> --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 配置扫描包的路径</span><br><span class="line">	如果要扫描多个包，中间使用半角逗号分隔</span><br><span class="line">	要求mapper.xml和mapper.java同名且在同一个目录</span><br><span class="line">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"mapper"</span>/&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 使用sqlSessionFactoryBeanName --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>进行了统一的配置。</p>
<p>接口里面调用xml文件中查询表中所有商品列表信息的sql语句，然后我们便可以进行业务逻辑层的代码编写.</p>
<h3 id="1-4业务逻辑层service的编写"><a href="#1-4业务逻辑层service的编写" class="headerlink" title="1.4业务逻辑层service的编写"></a>1.4业务逻辑层service的编写</h3><p>首先我们在service包下创建一个商品的service接口ItemsService.java文件，里面编写的方法和ItemsCustomMapper.java中的方法对应以实现商品列表的查询:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ItemsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品的查询列表</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ItemsCustom&gt; <span class="title">findItemsList</span><span class="params">(ItemsQueryVo itemsQueryVo)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后编写其实现类ItemsServiceImpl.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsServiceImpl</span> <span class="keyword">implements</span> <span class="title">ItemsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入mapper</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemsMapperCustom itemsMapperCustom;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//商品的查询列表</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ItemsCustom&gt; <span class="title">findItemsList</span><span class="params">(ItemsQueryVo itemsQueryVo)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> itemsMapperCustom.findItemsList(itemsQueryVo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2016.12.24日补充一下spring的知识:下方评论区有人问我没在该ItemsServiceImpl类的上方加入<code>@Service</code>的注解，那么我是如何将Service对象注入到spring的IOC容器中的呢？我想说的是，spring中将对象注入到IOC容器中的方式有多种，有一种是通过<code>&lt;bean&gt;</code>标签的方式(就是我这里的注入方式)，还有一种就是通过这位同志说的<code>@Service</code>注解的形式。当然这两种方式是可以共存的，建议大家在开发中还是将<code>@Service</code>注解加在Service实现类的上方，我这里只采用了<code>&lt;bean&gt;</code>标签的方式进行开发，给带来不解的同志我表示抱歉！另外关于spring IOC容器的注入方式建议大家参考下我的这片文章<a href="http://codingxiaxw.cn/2016/11/11/39-Spring/">Spring–程序员的春天</a>  </p>
<p>补充完毕，继续我们的代码开发:代码中通过Spring框架的DI注入依赖对象mapper即itemsMapperCustom对象，然后调用itemsMapperCustom的findItemsList方法实现商品列表查询,然后在spring配置文件applicationContext-service.xml中要进行service的配置，添加如下标签:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--商品配置的service--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemsService"</span> <span class="attr">class</span>=<span class="string">"service.impl.ItemsServiceImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>便可。接下来便应该完成控制层Controller.java的代码编写了。</p>
<h3 id="1-5控制层Controller的编写"><a href="#1-5控制层Controller的编写" class="headerlink" title="1.5控制层Controller的编写"></a>1.5控制层Controller的编写</h3><p>在controller包下创建一个ItemsController.java，里面编写代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入service</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemsService itemsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/queryItems"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryItems</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//调用servie来查询商品列表</span></span><br><span class="line">        List&lt;ItemsCustom&gt; itemsList=itemsService.findItemsList(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"itemsList"</span>,itemsList);</span><br><span class="line">        <span class="comment">//指定逻辑视图名itemsList</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">"itemsList"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过@Autowired注解完成service的依赖注入，通过@Controller注解将Controller自动添加到spring容器IOC中，通过@RequestMapping(“/queryItems”)注解指明访问该Controller的url。  </p>
<p>至于itemsList.jsp的页面编写代码如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> <span class="attr">prefix</span>=<span class="string">"c"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span>  <span class="attr">prefix</span>=<span class="string">"fmt"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>查询商品列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/items/queryItem.action"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">查询条件：</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"查询"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">商品列表：</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品价格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>生产日期<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品描述<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c:forEach</span> <span class="attr">items</span>=<span class="string">"$&#123;itemsList &#125;"</span> <span class="attr">var</span>=<span class="string">"item"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;item.name &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;item.price &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">fmt:formatDate</span> <span class="attr">value</span>=<span class="string">"$&#123;item.createtime&#125;"</span> <span class="attr">pattern</span>=<span class="string">"yyyy-MM-dd HH:mm:ss"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;item.detail &#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/items/editItems.action?id=$&#123;item.id&#125;"</span>&gt;</span>修改<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c:forEach</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后我们运行服务器，输入网址<code>http://localhost:8080/SpringMvcMybatis/queryItems.action</code>，发现无法看到页面，这是因为我们的spring配置文件没有得到加载，需要在web.xml文件中加入如下内容进行spring容器的配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置spring容器监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/classes/config/spring/applicationContext-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后重新运行服务器并输入网址，看到如下页面，说明成功使用SSM框架完成开发显示商品列表的项目:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-16%20%E4%B8%8B%E5%8D%888.00.34.png" alt=""></p>
<p>到此，我们便通过SSM的整合工程项目，完成了对商品列表的查询。接下来我们再实现对商品的另一个功能:修改商品信息。</p>
<h2 id="2-实现商品信息的修改"><a href="#2-实现商品信息的修改" class="headerlink" title="2.实现商品信息的修改"></a>2.实现商品信息的修改</h2><h3 id="2-1需求"><a href="#2-1需求" class="headerlink" title="2.1需求"></a>2.1需求</h3><p>功能描述:商品信息修改。操作流程：1.在商品列表页面点击修改连接。2.打开商品修改页面，显示了当前商品的信息(根据商品id查询商品信息)。3.修改商品信息，点击提交(更新商品信息)。  </p>
<p>通过此案例，我们也会穿插用SSM进行注解开发的基础知识如: @RequestMapping注解的改善、controller方法返回值、Controller方法中的参数与页面参数的绑定。</p>
<h3 id="2-2mapper的编写"><a href="#2-2mapper的编写" class="headerlink" title="2.2mapper的编写"></a>2.2mapper的编写</h3><p>此功能涉及到的mapper为ItemsMapper.java与ItemsMapper.xml，已使用逆向工程为我们生成。</p>
<h3 id="2-3service的编写"><a href="#2-3service的编写" class="headerlink" title="2.3service的编写"></a>2.3service的编写</h3><p>在ItemsService接口中添加方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据商品id查询商品信息</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ItemsCustom <span class="title">findItemsById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//更新商品信息</span></span><br><span class="line"> <span class="comment">/**</span><br><span class="line">  * 定义service接口，遵循单一职责，将业务参数细化(不要使用包装类型，比如map)</span><br><span class="line">  * <span class="doctag">@param</span> id 修改商品的id</span><br><span class="line">  * <span class="doctag">@param</span> itemsCustom 修改商品的信息</span><br><span class="line">  * <span class="doctag">@throws</span> Exception</span><br><span class="line">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateItems</span><span class="params">(Integer id,ItemsCustom itemsCustom)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后是实现类ItemsServiceImpl.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//注入依赖对象itemsMapper</span></span><br><span class="line"> <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> ItemsMapper itemsMapper;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ItemsCustom <span class="title">findItemsById</span><span class="params">(<span class="keyword">int</span> id)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      Items items=itemsMapper.selectByPrimaryKey(id);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//在这里以后随着需求的变化，需要查询商品的其它相关信息，返回到controller</span></span><br><span class="line">      <span class="comment">//所以这个时候用到扩展类更好，如下</span></span><br><span class="line">      ItemsCustom itemsCustom=<span class="keyword">new</span> ItemsCustom();</span><br><span class="line">      <span class="comment">//将items的属性拷贝到itemsCustom</span></span><br><span class="line">      BeanUtils.copyProperties(items,itemsCustom);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> itemsCustom;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateItems</span><span class="params">(Integer id,ItemsCustom itemsCustom)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//在service中一定要写业务代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="comment">//对于关键业务数据的非空校验</span></span><br><span class="line">      <span class="keyword">if</span> (id==<span class="keyword">null</span>)</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//抛出异常，提示调用接口的用户，id不能唯恐</span></span><br><span class="line">          <span class="comment">//...</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      itemsMapper.updateByPrimaryKeyWithBLOBs(itemsCustom);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>说一句:对service的开发是整个系统中开发最重要的部分，所以你要把service的开发放在学习的重点上。接下来就要写Controller的代码了，然而写Controller的过程中会学到很多注解开发的基础知识。</p>
<h3 id="2-4Controller的编写之-RequestMapping的特性学习"><a href="#2-4Controller的编写之-RequestMapping的特性学习" class="headerlink" title="2.4Controller的编写之@RequestMapping的特性学习"></a>2.4Controller的编写之@RequestMapping的特性学习</h3><h4 id="2-4-1窄化请求映射"><a href="#2-4-1窄化请求映射" class="headerlink" title="2.4.1窄化请求映射"></a>2.4.1窄化请求映射</h4><p>我们除了在Controller方法的上面加上一个@RequestMapping的注解指定url外(完成url映射)，还可以在Controller类的上面指定一个@RequestMapping注解指定访问路径的根url，如这里我们是对商品的操作，所以可以在Controller类上面加上一个@RequestMapping的注解指定访问商品信息的根路径(叫“窄化请求映射”):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="comment">//定义url的根路径，访问时根路径+方法名的url</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/items"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsController</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用窄化请求映射的好处:更新规范系统的url，避免url冲突。  </p>
<p>然后继续我们的Controller开发，添加方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/editItems"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">editItems</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line">    ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用service查询商品的信息</span></span><br><span class="line">    ItemsCustom itemsCustom=itemsService.findItemsById(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将模型数据传到jsp</span></span><br><span class="line">    modelAndView.addObject(<span class="string">"item"</span>,itemsCustom);</span><br><span class="line">    <span class="comment">//指定逻辑视图名</span></span><br><span class="line">    modelAndView.setViewName(<span class="string">"editItem"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> modelAndView;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写editItem.jsp页面:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">contentType</span>=<span class="string">"text/html; charset=UTF-8"</span></span><br><span class="line">    <span class="attr">pageEncoding</span>=<span class="string">"UTF-8"</span>%&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> <span class="attr">prefix</span>=<span class="string">"c"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span>  <span class="attr">prefix</span>=<span class="string">"fmt"</span>%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>修改商品信息<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"itemForm"</span> <span class="attr">action</span>=<span class="string">"$&#123;pageContext.request.contextPath &#125;/items/editItemSubmit.action"</span> <span class="attr">method</span>=<span class="string">"post"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"$&#123;id &#125;"</span>/&gt;</span></span><br><span class="line">修改商品信息：</span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">"100%"</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品名称<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"$&#123;itemsCustom.name &#125;"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品价格<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"price"</span> <span class="attr">value</span>=<span class="string">"$&#123;itemsCustom.price &#125;"</span>/&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品简介<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"3"</span> <span class="attr">cols</span>=<span class="string">"30"</span> <span class="attr">name</span>=<span class="string">"detail"</span>&gt;</span>$&#123;itemsCustom.detail &#125;<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后运行服务器，此时应该输入网址<code>http://localhost:8080/SpringMvcMybatis/items/queryItems.action</code>而不是<code>http://localhost:8080/SpringMvcMybatis/queryItems.action</code>,然后点击右边的修改链接便可以进去相应的修改页面:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-16%20%E4%B8%8B%E5%8D%888.55.33.png" alt="">  </p>
<h4 id="2-4-2限制http请求的方法"><a href="#2-4-2限制http请求的方法" class="headerlink" title="2.4.2限制http请求的方法"></a>2.4.2限制http请求的方法</h4><p>不知道你发现没有，我们在Controller的editItems()方法上的注解中加入的是<code>value = &quot;/editItems&quot;,method = RequestMethod.GET</code>参数而不再是单单的<code>&quot;/editItems&quot;</code>参数了，这里我们便用到了使用@RequestMapping注解限制http请求的方法。如果你将这里的<code>method = RequestMethod.GET</code>改为<code>method = RequestMethod.POST</code>，然后在页面中再点击修改链接时就会报错。 </p>
<p>另外method属性的属性值为数组，我们也可以将注解中的参数改为<code>ethod = {RequestMethod.GET,RequestMethod.POST}</code>表示请求既可以为POST请求又可以为GET请求。 </p>
<h3 id="2-5Controller的编写之Controller方法返回值学习"><a href="#2-5Controller的编写之Controller方法返回值学习" class="headerlink" title="2.5Controller的编写之Controller方法返回值学习"></a>2.5Controller的编写之Controller方法返回值学习</h3><h4 id="2-5-1返回ModerAndView"><a href="#2-5-1返回ModerAndView" class="headerlink" title="2.5.1返回ModerAndView"></a>2.5.1返回ModerAndView</h4><p>目前我们使用的方式都是返回的ModerAndView对象，例如我们已经编写的Controller中的queryItems()方法和editItems()方法。接下来我们看看返回字符串的方法编写。</p>
<h4 id="2-5-2返回字符串"><a href="#2-5-2返回字符串" class="headerlink" title="2.5.2返回字符串"></a>2.5.2返回字符串</h4><p>首先注释掉我们返回值为ModerAndView类型的editItems()方法。如果controller方法返回jsp页面，可以简单将方法返回值类型定义 为字符串，最终返回逻辑视图名。编写返回值为String类型的editItems()方法，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法返回字符串，字符串就是逻辑视图名，Model作用是将数据填充到request域，在页面显示</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/editItems"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">editItems</span><span class="params">(Model model)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用service查询商品的信息</span></span><br><span class="line">    ItemsCustom itemsCustom=itemsService.findItemsById(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    model.addAttribute(<span class="string">"itemsCustom"</span>,itemsCustom);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"editItem"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法中我们需要传入一个Model对象，作用是将数据填充到request域，在页面显示。然后运行服务器，输入<code>http://localhost:8080/SpringMvcMybatis/items/queryItems.action</code>照常正确访问该网站。再来介绍返回值为void的方法。</p>
<h4 id="2-5-3返回void"><a href="#2-5-3返回void" class="headerlink" title="2.5.3返回void"></a>2.5.3返回void</h4><p>同样注释掉返回值为String类型的editItems()方法，然后加入返回值为void的editItems()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/editItems"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editItems</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用service查询商品的信息</span></span><br><span class="line">    ItemsCustom itemsCustom=itemsService.findItemsById(id);</span><br><span class="line"></span><br><span class="line">    request.setAttribute(<span class="string">"item"</span>,itemsCustom);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意如果使用request转向页面，这里需要指定页面的完整路径</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/editItem.jsp"</span>).forward(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实这里就是运用的原生态的Servlet的开发方式，运行服务器，输入<code>http://localhost:8080/SpringMvcMybatis/items/queryItems.action</code>仍照常正确访问该网站。  </p>
<p>通过这种返回值为void的方法我们容易输出json、xml格式的数据，即通过response指定响应结果，例如响应json数据如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">response.getWriter().write(<span class="string">"json串"</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面我们就通过完成商品信息的编辑功能介绍了Controller中三种返回值类型的方法。而通过返回字符串的方法，有时候会返回一些特殊的字符串(例如返回<code>return &quot;forward:url路径&quot;</code>或<code>return &quot;redirect:url路径&quot;</code>)。分别代表请求转发和请求冲定向，下面我们通过完善编辑商品信息后进行提交的功能来讲解这两种返回特殊字符串类型的方法。在Controller中添加editItemSubmit()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//商品提交页面</span></span><br><span class="line">    <span class="comment">//itemsQueryVo是包装类型的pojo</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/editItemSubmit"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">editItemSubmit</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="comment">//请求转发,使用forward进行请求转发，request数据可以共享，url地址栏不会</span></span><br><span class="line"><span class="comment">//        return "forward:queryItems.action";</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用redirect进行重定向，request数据无法共享，url地址栏会发生变化的。由于我们重定向的页面queryItems.action与本页面editItemSubmit.action在同一根目录下，所以不需要加入根路径</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"redirect:queryItems.action"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>运行服务器，然后我们便可以在editItems.jsp页面通过点击”提交”按钮请求转发或者请求重定向到我们的<code>queryItems.action</code>页面。如上，我便介绍完Contoller方法返回值的知识。接下来介绍Controller方法中的参数与页面参数绑定的知识。  </p>
<h3 id="2-6Controller的编写之方法参数与页面参数的绑定"><a href="#2-6Controller的编写之方法参数与页面参数的绑定" class="headerlink" title="2.6Controller的编写之方法参数与页面参数的绑定"></a>2.6Controller的编写之方法参数与页面参数的绑定</h3><p>不知你注意到没有，在Controller的方法中我们传入的参数都是我们自己根据需求手动传入的参数，而真正的需求中我们是需要将页面中的参数传递到Controller的方法中的，那如何将页面的参数绑定到Controller的方法中呢？看下方参数绑定的过程图解:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-16%20%E4%B8%8B%E5%8D%889.33.44.png" alt=""></p>
<p>首先我们看看Controller的方法中默认支持的形参(即之前我们根据需求手动传入的参数，这些参数处理适配器会默认识别并进行赋值)有:1.HttpServletRequest:通过request对象获取请求信息。 2.HttpServletResponse:通过response处理响应信息。3.HttpSession:通过session对象得到session中存放的对象。4.Model/modelmap/map:通过model向页面传递数据，页面通过${item.XXXX}获取item对象的属性值,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用service查询商品信息</span></span><br><span class="line">Items item = itemService.findItemById(id);</span><br><span class="line">model.addAttribute(<span class="string">"item"</span>, item);</span><br></pre></td></tr></table></figure></p>
<p>但是值得我们关心的不是这些默认的参数，而是我们自定义参数传入Controller方法的形参中，继续往下面看。</p>
<h4 id="2-6-1-RequestParam"><a href="#2-6-1-RequestParam" class="headerlink" title="2.6.1@RequestParam"></a>2.6.1@RequestParam</h4><p>如果request请求的参数名和controller方法的形参数名称一致，适配器自动进行参数绑定。如果不一致可以通过<br>@RequestParam 指定request请求的参数名绑定到哪个方法形参上。</p>
<p>对于必须要传的参数，通过@RequestParam中属性required设置为true，如果不传此参数则报错。</p>
<p>对于有些参数如果不传入，还需要设置默认值，使用@RequestParam中属性defaultvalue设置默认值。</p>
<p>例如Controller中的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/editItems"</span>,method = RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">editItems</span><span class="params">(HttpServletRequest request, HttpServletResponse response,@RequestParam(value = <span class="string">"item_id"</span>,required = <span class="keyword">false</span>,defaultValue = <span class="string">"1"</span>)</span> Integer id) <span class="keyword">throws</span> Exception</span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用service查询商品的信息</span></span><br><span class="line">    ItemsCustom itemsCustom=itemsService.findItemsById(id);</span><br><span class="line"></span><br><span class="line">    request.setAttribute(<span class="string">"item"</span>,itemsCustom);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//zhuyi如果使用request转向页面，这里需要指定页面的完整路径</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/editItem.jsp"</span>).forward(request,response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>没对形参id加上@RequestParam注解时，当我们从页面进入到editItems.action时，只有从页面传入的参数名为id时该id参数值才会传到editItems()方法的id参数值上，如果从页面传入的参数明不为id而为其他参数名时例如<code>http://localhost:8080/SpringMvcMybatis/items/editItems.action?item_id=1</code>，此时通过调试会发现editItems()方法中的id属性值为null;而当我们为形参id加上了@RequestParam注解并指定了其属性<code>value = &quot;item_id&quot;</code>后，若从页面传入的参数名为item_id，则该参数值会因为添加了<code>value = &quot;item_id&quot;</code>该属性而被赋值给id属性。<code>required</code>属性若设置为true，则如果从页面进入到editItem.action时没有传入此参数则会报错。<code>defaultvalue</code>属性值表示为该参数赋默认值。</p>
<h4 id="2-6-2绑定简单类型"><a href="#2-6-2绑定简单类型" class="headerlink" title="2.6.2绑定简单类型"></a>2.6.2绑定简单类型</h4><p>上述那个editItem()方法是原始的servlet开发方法，接下来我们用返回值为String 类型的方法进行注解开发的基础知识讲解。</p>
<p>可以绑定整型、字符串、单精/双精度、日期、布尔型，很简单处理，我不进行讲解，通过下面绑定pojo类型你就会清楚了。</p>
<h4 id="2-6-3绑定pojo类型"><a href="#2-6-3绑定pojo类型" class="headerlink" title="2.6.3绑定pojo类型"></a>2.6.3绑定pojo类型</h4><p>绑定pojo类型又可以分为绑定简单pojo类型和绑定包装pojo类型。</p>
<h5 id="2-6-3-1绑定简单pojo类型"><a href="#2-6-3-1绑定简单pojo类型" class="headerlink" title="2.6.3.1绑定简单pojo类型"></a>2.6.3.1绑定简单pojo类型</h5><p>简单pojo类型只包括简单类型的属性。绑定过程:request请求的参数名称和pojo的属性名一致，就可以绑定成功。  </p>
<p>修改Controller中的editItemSubmit()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//商品提交页面</span></span><br><span class="line">    <span class="comment">//itemsQueryVo是包装类型的pojo</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/editItemSubmit"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">editItemSubmit</span><span class="params">(Integer id,ItemsCustom itemsCustom)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">    </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        itemsService.updateItems(id,itemsCustom);</span><br><span class="line">        <span class="comment">//请求转发</span></span><br><span class="line"><span class="comment">//        return "forward:queryItems.action";</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//重定向</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">"redirect:queryItems.action"</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>点击提交按钮，从editItem.jsp页面进入editItemSubmit.action时，就会将编辑页面的参数都映射到该方法的id形参和ItemsCustom对象中，此时我们修改商品的信息，然后点击提交按钮，服务器反应过程如下:点击提交按钮，页面从editItem.jsp进入到editItemSubmit.action并将修改后的商品信息提交到数据库并将这些参数传入到ItemsCustom对象的属性中，然后重定向到queryItems.action进行商品的列表信息展示。  </p>
<p><strong>问题:</strong>如果controller方法形参中有多个pojo且pojo中有重复的属性，使用简单pojo绑定无法有针对性的绑定，比如:方法形参有items和User，pojo同时存在name属性，从http请求过程的name无法有针对性的绑定到items或user。要解决此种方法我们就需要用到下面的绑定包装的pojo类型。</p>
<h5 id="2-6-3-2绑定包装的pojo类型"><a href="#2-6-3-2绑定包装的pojo类型" class="headerlink" title="2.6.3.2绑定包装的pojo类型"></a>2.6.3.2绑定包装的pojo类型</h5><p>这里我们复制editItem.jsp页面粘贴出一个editItem2.jsp页面，染护修改editItem2.jsp中的参数名为itemsCustom.name、itemsCustom.price、itemsCustom.detail，修改Controller中的editItemSubmit方法中的形参为<code>public String editItemSubmit(Integer id,ItemsCustom itemsCustom,ItemsQueryVo itemsQueryVo) throws Exception{...}</code>修改editItems的返回值类型为<code>editItems2</code>。运行程序，点击提交按钮，页面信息成功传入到itemsQueryVo的属性中。成功运行后我们还是将信息改回成原来的模样，方便后面的测试。  </p>
<h4 id="2-6-4使用属性编辑器完成自定义绑定"><a href="#2-6-4使用属性编辑器完成自定义绑定" class="headerlink" title="2.6.4使用属性编辑器完成自定义绑定"></a>2.6.4使用属性编辑器完成自定义绑定</h4><p>此时我们在editItem.jsp中添加上日期的信息展示:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span>商品生产日期<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"createtime"</span> <span class="attr">value</span>=<span class="string">"&lt;fmt:formatDate value="</span>$&#123;<span class="attr">itemsCustom.createtime</span>&#125;" <span class="attr">pattern</span>=<span class="string">"yyyy-MM-dd HH-mm-ss"</span>/&gt;</span>"/&gt;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后运行程序，当点击提交按钮时会报错，你知道为什么吗？原因是因为通过点击提交按钮，页面中参数名为”createtime”的参数名由于跟Controller方法中的形参ItemsCustom有相同的属性名createtime，所以此时页面中的日期会映射到ItemsCustom的Date属性中,但是从页面传过来的日期是字符串类型，而ItemsCustom的属性是java.util.Date类型，所以当然会报错。这样的话，我们就必须完成日期字符串向java类型日期的转换。此时我们就需要自定义日期类型的绑定，即使用属性编辑器来完成自定义的绑定。有如下两种方法:1.使用WebDataBinder（了解），在Controller中添加如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义属性编辑器</span></span><br><span class="line"><span class="meta">@InitBinder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initBinder</span><span class="params">(WebDataBinder binder)</span> <span class="keyword">throws</span>  Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Date.class必须是与controller方法形参pojo属性一致的date类型，这里是java.util.Date</span></span><br><span class="line">    binder.registerCustomEditor(Date.class,<span class="keyword">new</span> CustomDateEditor(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH-mm-ss"</span>),<span class="keyword">true</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，点击提交按钮后不会再出现报错信息，且editItem.jsp页面的createtime参数也成功传入到了ItemsCustom的createtime属性中。使用这种方法的问题是无法在多个controller共用。那我们就来介绍第二种方法:使用WebBindingInitializer（了解）。首先我们需要编写一个自定义属性编辑器CustomPropertyEditor.java，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomPropertyEditor</span> <span class="keyword">implements</span> <span class="title">PropertyEditorRegistrar</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerCustomEditors</span><span class="params">(PropertyEditorRegistry binder)</span> </span>&#123;</span><br><span class="line">        binder.registerCustomEditor(Date.class,<span class="keyword">new</span> CustomDateEditor(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH-mm-ss"</span>),<span class="keyword">true</span>));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后要在springmvc.xml文件中加入对它的配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注册属性编辑器 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customPropertyEditor"</span> <span class="attr">class</span>=<span class="string">"controller.propertyeditor.CustomPropertyEditor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 自定义webBinder --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customBinder"</span></span><br><span class="line">		<span class="attr">class</span>=<span class="string">"org.springframework.web.bind.support.ConfigurableWebBindingInitializer"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"propertyEditorRegistrars"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"customPropertyEditor"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后要在注解适配器的配置标签中加入如下属性:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webBindingInitializer"</span> <span class="attr">ref</span>=<span class="string">"customBinder"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这样我们便可以注释掉第一种属性编辑器的代码了，使用第二种方式虽然配置很繁琐，但是很适用。运行程序，也成功将editItem.jsp页面的createtime参数映射到ItemsCustom的createtime属性中。下面我再讲一种自定义绑定参数的方法。</p>
<h4 id="2-6-5使用转换器完成自定义参数绑定-想往架构师方向发展的要掌握这种方法"><a href="#2-6-5使用转换器完成自定义参数绑定-想往架构师方向发展的要掌握这种方法" class="headerlink" title="2.6.5使用转换器完成自定义参数绑定(想往架构师方向发展的要掌握这种方法)"></a>2.6.5使用转换器完成自定义参数绑定(想往架构师方向发展的要掌握这种方法)</h4><p>首先要定义一个转换器CustomDateConverter.java完成日期的转换，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH-mm-ss"</span>).parse(source);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在定义一个StringTrimConverter.java用于去除日期字符串两边的空格,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTrimConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>,<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//去掉字符串两边的空格，如果去除后为空则返回null</span></span><br><span class="line">            <span class="keyword">if</span> (source != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                source = source.trim();</span><br><span class="line">                <span class="keyword">if</span> (source.equals(<span class="string">""</span>))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> source;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>定义好后就需要对转换器进行配置:思路就是先定义一个转换器然后注入到适配器中。而对于转换器在springmvc.xml中的配置有两种方式，第一种方式针对不使用<code>&lt;mvc:annotation-driven&gt;</code>,第二种方式针对使用<code>&lt;mvc:annotation-driven&gt;</code>,我们就来讲讲第二种方式。在springmvc.xml中添加如下配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mvc的注解驱动器，通过它可以替代下边的处理器映射器和适配器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--转换器--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- conversionService --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span><br><span class="line">      <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 转换器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.converter.CustomDateConverter"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.converter.StringTrimConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用了注解驱动的配置后，我们就可以注释掉处理器映射器与处理器适配器了。运行程序，也成功将editItem.jsp页面的createtime参数映射到ItemsCustom的createtime属性中。</p>
<p>由于往后我们还要进行json数据的开发，所以这里我们还是不采用使用注解驱动的方式，还是采用注解映射器与注解适配器的方式进行开发。为了方便后面对高级注解知识的讲解，我们这里采用的自定义绑定参数的方式是通过webBindingInitializer和convertor结合的方式，修改后的最后的springmvc.xml配置信息如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用spring组件扫描</span><br><span class="line">  一次性配置此包下所有的Handler--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mvc的注解驱动器，通过它可以替代下边的处理器映射器和适配器--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--注解处理器映射器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--注解的适配器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"webBindingInitializer"</span> <span class="attr">ref</span>=<span class="string">"customBinder"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--配置视图解析器</span><br><span class="line">  要求将jstl的包加到classpath--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 自定义webBinder --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customBinder"</span></span><br><span class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.web.bind.support.ConfigurableWebBindingInitializer"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"conversionService"</span> <span class="attr">ref</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--早期的自定义属性编辑器--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;property name="propertyEditorRegistrars"&gt;--&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--&lt;list&gt;--&gt;</span></span><br><span class="line">              <span class="comment">&lt;!--&lt;ref bean="customPropertyEditor"/&gt;--&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--&lt;/list&gt;--&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;/property&gt;--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 注册属性编辑器 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"customPropertyEditor"</span> <span class="attr">class</span>=<span class="string">"controller.propertyeditor.CustomPropertyEditor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mvc的注解驱动器，通过它可以替代下边的处理器映射器和适配器--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;mvc:annotation-driven conversion-service="conversionService"&gt;--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--&lt;/mvc:annotation-driven&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--转换器--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- conversionService --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span><br><span class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.format.support.FormattingConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 转换器 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.converter.CustomDateConverter"</span>/&gt;</span></span><br><span class="line">              <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.converter.StringTrimConverter"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个converter的配置是一劳永逸的配置，也就是系统架构级别的配置，希望你能成功掌握。</p>
<p>好了，通过上述的案例，便成功的使用了SSM框架实现了商品信息的三个功能。希望通过这个案例，你能成功掌握SSM框架进行简单的注解开发，而我接下来要为你们讲解SSM开发中的高级注解开发知识,还是借用这个工程进行开发。博客链接<a href="http://codingxiaxw.cn/2016/11/19/46-ssm%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91/">SSM注解开发的高级知识讲解</a>,源码链接<a href="https://github.com/codingXiaxw/ssm2" target="_blank" rel="external">点击这里前往我的github</a></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[手把手带你实现Spring、Spring MVC与Mybatis整合工程的搭建]]></title>
      <url>http://codingxiaxw.cn/2016/11/15/44-ssm%E7%9A%84%E6%95%B4%E5%90%88/</url>
      <content type="html"><![CDATA[<p>系统的学完了Spring、Spring MVC以及Mybatis之后我们就可以进行这三者的整合工作了，其实不难，就是将这三个框架的配置文件提取出来放在一个项目中，然后便可以进行开发(就是这么简单)。此篇文章我们将在前篇文章<a href="http://codingxiaxw.cn/2016/11/12/40-mybatis%E4%B8%8Espring%E7%9A%84%E6%95%B4%E5%90%88/">Mybatis3.x与Spring3.x整合</a>的基础上将Spring MVC的配置引入进来即可(超级简单)。  </p>
<a id="more"></a>  
<p>源码<a href="https://github.com/codingXiaxw/ssm" target="_blank" rel="external">请点击这里</a>前往我的Github。</p>
<h2 id="1-整合的思路"><a href="#1-整合的思路" class="headerlink" title="1.整合的思路"></a>1.整合的思路</h2><p>1.在<a href="http://codingxiaxw.cn/2016/11/12/40-mybatis%E4%B8%8Espring%E7%9A%84%E6%95%B4%E5%90%88/">Mybatis3.x与Spring3.x整合</a>的基础上再进行Spring MVC框架的整合。  </p>
<p>2.Spring要管理Spring MVC编写的Handler(controller)、Mybatis的SqlSessionFactory、mapper、数据源。  </p>
<p>其实整合思路就是下面这三步:  </p>
<ol>
<li>第一步:整合dao(即mapper)，完成Spring与Mybatis的整合。</li>
<li>第二步:整合service，Spring管理service接口，service中可以调用Spring容器中的dao(mapper)。</li>
<li>第三步:整合controller，Spring管理controller接口，在controller调用service。</li>
</ol>
<h2 id="2-导入jar包"><a href="#2-导入jar包" class="headerlink" title="2.导入jar包"></a>2.导入jar包</h2><p>mybatis-3.x.jar、spring3.x.jar(包含springmvc的jar包)、mybatis与spring的整合jar、数据库驱动包、log4j.jar、jstl.jar。如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-15%20%E4%B8%8B%E5%8D%883.13.29.png" width="50%" height="30%">  </p>
<h2 id="3-工程结构"><a href="#3-工程结构" class="headerlink" title="3.工程结构"></a>3.工程结构</h2><h3 id="3-1需要创建的配置文件"><a href="#3-1需要创建的配置文件" class="headerlink" title="3.1需要创建的配置文件"></a>3.1需要创建的配置文件</h3><ol>
<li>applicationContext-dao.xml—配置数据源、SqlSessionFactory、mapper扫描器。</li>
<li>applicationContext-service.xml—配置service接口。</li>
<li>applicationContext-transaction.xml–事务管理。</li>
<li>sprintmvc.xml—springmvc的配置，配置处理器映射器、适配器、视图解析器(这里我们统一采用注解的方式进行开发)。</li>
<li>SqlMapConfig.xml—mybatis的配置文件，配置别名、settings、mapper。</li>
</ol>
<p>工程目录如下:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-15%20%E4%B8%8B%E5%8D%883.27.02.png" width="50%" height="30%"> </p>
<h3 id="3-2各个配置文件的内容"><a href="#3-2各个配置文件的内容" class="headerlink" title="3.2各个配置文件的内容"></a>3.2各个配置文件的内容</h3><p><strong>applicationContext-dao.xml:</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">           <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">           <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">           <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">           <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/mvc</span><br><span class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context</span><br><span class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/aop</span><br><span class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/tx</span><br><span class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:config/db.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span><br><span class="line">		<span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- SqlsessionFactory --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- mybatis配置文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:config/mybatis/SqlMapConfig.xml"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">	<span class="comment">&lt;!--</span><br><span class="line">	MapperScannerConfigurer：mapper的扫描器，将包下边的mapper接口自动创建代理对象，</span><br><span class="line">	自动创建到spring容器中，bean的id是mapper的类名（首字母小写）</span><br><span class="line">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置扫描包的路径</span><br><span class="line">		如果要扫描多个包，中间使用半角逗号分隔</span><br><span class="line">		要求mapper.xml和mapper.java同名且在同一个目录</span><br><span class="line">		 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"mapper"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 使用sqlSessionFactoryBeanName --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>applicationContext-service.xml:</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">           <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">           <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">           <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">           <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/mvc</span><br><span class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context</span><br><span class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/aop</span><br><span class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/tx</span><br><span class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>applicationContext-transaction.xml:配置事务，在配置文件中使用声明式事务配置</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">           <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">           <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">           <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">           <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/mvc</span><br><span class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context</span><br><span class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/aop</span><br><span class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/tx</span><br><span class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--使用声明式的控制配置，可以有效的规范代码--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--事务管理器的配置--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"sava"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"insert*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"update*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"delete*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"select*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"get*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!--配置aop--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut</span>=<span class="string">"execution(* service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>sprintmvc.xml:</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/mvc</span><br><span class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context</span><br><span class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/aop</span><br><span class="line">		http://www.springframework.org/schema/tx</span><br><span class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--使用spring组件扫描</span><br><span class="line">    一次性配置此包下所有的Handler--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"controller"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--注解处理器映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--注解的适配器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器</span><br><span class="line">    要求将jstl的包加到classpath</span><br><span class="line">    prefix:代表请求url的前缀</span><br><span class="line">    suffix:代表请求url的后缀</span><br><span class="line">    设置了这两个属性值后我们在Controller中进行代码开发时返回的modelandview对象设置的页面路径值就不用带前缀名和后缀名了--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>SqlMapConfig.xml:</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span><br><span class="line">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 定义 别名 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 批量别名定义 指定包路径，自动扫描包下边的pojo，定义别名，别名默认为类名（首字母小写或大写） --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"po"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!--由于使用了spring和mybatis整合的mapper扫描器，--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--这里就不用配置了--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--&lt;mappers&gt;--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--&lt;package name="mapper"/&gt;--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--&lt;/mappers&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>在web.xml文件中加入对前端控制器的配置:</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载springmvc配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置文件的地址</span><br><span class="line">        如果不配置contextConfigLocation，默认查找的配置文件名称是classpath下的:servlet名称+"-servlet.xml"即springmvc-servlet.xml--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可以配置/：此工程所有的请求全部由springmvc解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析</span><br><span class="line">    可以配置*.do或者*.action,所有请求的url扩展名为.do或.action由springmvc解析，此中方法常用</span><br><span class="line">    不可以配置/*,如果配置/*,返回jsp也由springmvc解析，这是不对的--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>另外还需要添加数据库的配置文件db.properties:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/mybatis</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=xiaxunwu1996.</span><br></pre></td></tr></table></figure></p>
<p>在src下创建各个包:mapper、po、controller、service，在web包下创建页面包jsp，工程目录如下:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-15%20%E4%B8%8B%E5%8D%883.27.02.png" width="50%" height="30%"> </p>
<p>经过上述步骤，我们便完成了Spring、Spring MVC与Mybatis的整合，是不是很简单?没错就是这么简单。可是整合后又该如何进行web项目的开发呢?接下来我将通过下篇文章<a href="http://codingxiaxw.cn/2016/11/15/45-smm%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">一个案例带你快速入门SSM开发</a>介绍利用Spring、Spring MVC与Mybatis的整合项目进行开发一个案例带你快速学会使用SSM框架开发项目。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC之注解与非注解映射器和适配器]]></title>
      <url>http://codingxiaxw.cn/2016/11/14/43-springmvc%E4%B9%8B%E6%B3%A8%E8%A7%A3%E4%B8%8E%E9%9D%9E%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>在Spring MVC中涉及到的处理器映射器和处理器适配器分为注解处理器映射器和处理器适配器与非注解处理器映射器和处理器适配器，这些远远不止上篇文章中介绍到的那几个，本篇文章的目的就是为了介绍更多的处理器映射器和处理器适配器。毕竟我们是革命者，了解更多的知识才是王道。<br><a id="more"></a></p>
<p><strong>写在前面的话:</strong>本篇文章在前篇文章开发的代码基础上继续进行开发。</p>
<h2 id="1-非注解映射器和非注解适配器"><a href="#1-非注解映射器和非注解适配器" class="headerlink" title="1.非注解映射器和非注解适配器"></a>1.非注解映射器和非注解适配器</h2><h3 id="1-1BeanNameUrlHandlerMapping-映射器"><a href="#1-1BeanNameUrlHandlerMapping-映射器" class="headerlink" title="1.1BeanNameUrlHandlerMapping(映射器)"></a>1.1BeanNameUrlHandlerMapping(映射器)</h3><p>就是上文中我们用到的处理器映射器，根据请求url（XXXX.action）匹配spring容器bean标签的name属性找到对应的Handler(通过class属性找到程序员编写的那个Handler)，详情配置见上篇文章。</p>
<h3 id="1-2SimpleUrlHandlerMapping-映射器"><a href="#1-2SimpleUrlHandlerMapping-映射器" class="headerlink" title="1.2SimpleUrlHandlerMapping(映射器)"></a>1.2SimpleUrlHandlerMapping(映射器)</h3><p>简单url映射器，是BeanNameUrlHandlerMapping的增强版，在springmvc.xml配置文件中这样配置SimpleUrlHandlerMapping:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--简单url映射</span><br><span class="line"> 几种配置bean的id对应的url</span><br><span class="line"> key:用户请求的url</span><br><span class="line"> 标签内容:程序员编写的Handler在此配置文件中的id--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/items1.action"</span>&gt;</span>itemController1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/items2.action"</span>&gt;</span>itemController1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>SimpleUrlHandlerMapping的配置中需要用到Handler在springmvc.xml中的配置id，所以这里我们需要给Handler的配置加上一个标签:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Handler</span><br><span class="line">   由于使用了BeanNameUrlHandlerMapping处理映射器，所以name要配置为url。另外不需要id属性--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemController1"</span> <span class="attr">name</span>=<span class="string">"/itemList.action"</span> <span class="attr">class</span>=<span class="string">"controller.ItemController1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此时两个处理器映射器对应三个不同的url地址，但却指向的是同一个Controller(即Handler)，运行程序，发现输入<code>http://localhost:8080/SpringMvc/itemList.action</code>或<code>http://localhost:8080/SpringMvc/items1.action</code>或<code>http://localhost:8080/SpringMvc/items2.action</code>访问的都是同一个页面，说明:若在springmvc.xml配置文件中配置了多个处理器映射器，多个映射器可以共存。  </p>
<h3 id="1-3SimpleControllerHandlerAdapter-适配器"><a href="#1-3SimpleControllerHandlerAdapter-适配器" class="headerlink" title="1.3SimpleControllerHandlerAdapter(适配器)"></a>1.3SimpleControllerHandlerAdapter(适配器)</h3><p>就是上文中我们用到的处理器适配器，要求前端控制器通过这个适配器找到的Handler(Controller)需要实现 Controller接口。  </p>
<h3 id="1-4HttpRequestHandlerAdapter（适配器）"><a href="#1-4HttpRequestHandlerAdapter（适配器）" class="headerlink" title="1.4HttpRequestHandlerAdapter（适配器）"></a>1.4HttpRequestHandlerAdapter（适配器）</h3><p>HttpRequestHandlerAdapter在配置文件中这样配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>要求前端控制器使用这个适配器找到的Handler需要实现HttpRequestHandler接口</strong>。  </p>
<p>使用这个适配器开发的Handler代码为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController2</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用静态的数据将商品信息显示在jsp页面</span></span><br><span class="line">        List&lt;Items&gt; itemsList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Items items_1 = <span class="keyword">new</span> Items();</span><br><span class="line">        items_1.setName(<span class="string">"联想笔记本"</span>);</span><br><span class="line">        items_1.setPrice(<span class="number">6000f</span>);</span><br><span class="line">        items_1.setCreatetime(<span class="keyword">new</span> Date());</span><br><span class="line">        items_1.setDetail(<span class="string">"ThinkPad T430 联想笔记本电脑！"</span>);</span><br><span class="line"></span><br><span class="line">        Items items_2 = <span class="keyword">new</span> Items();</span><br><span class="line">        items_2.setName(<span class="string">"苹果手机"</span>);</span><br><span class="line">        items_2.setPrice(<span class="number">5000f</span>);</span><br><span class="line">        items_2.setDetail(<span class="string">"iphone6苹果手机！"</span>);</span><br><span class="line"></span><br><span class="line">        itemsList.add(items_1);</span><br><span class="line">        itemsList.add(items_2);</span><br><span class="line"></span><br><span class="line">        httpServletRequest.setAttribute(<span class="string">"itemsList"</span>,itemsList);</span><br><span class="line">        httpServletRequest.getRequestDispatcher(<span class="string">"/WEB-INF/jsp/itemsList.jsp"</span>).forward(httpServletRequest,httpServletResponse);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现HttpRequestHandler需要实现的方法返回值为void，不能给处理器适配器返回ModelAndView对象，所以代码中我们要使用request域进行注入值。  </p>
<p>然后是Handler在springmvc.xml中的配置,这里我们让该Handler使用SimpleUrlHandlerMapping处理器映射器，所以不需要给该Handler设置id:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itemController2"</span> <span class="attr">class</span>=<span class="string">"controller.ItemController2"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后修改SimpleUrlHandlerMapping在配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappings"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/items2.action"</span>&gt;</span>itemController2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>运行服务器，然后便可以通过<code>http://localhost:8080/SpringMvc/items2.action</code>进行访问。</p>
<h2 id="2-注解映射器和注解适配器"><a href="#2-注解映射器和注解适配器" class="headerlink" title="2.注解映射器和注解适配器"></a>2.注解映射器和注解适配器</h2><h3 id="2-1注解映射器"><a href="#2-1注解映射器" class="headerlink" title="2.1注解映射器"></a>2.1注解映射器</h3><p>在spring3.1版本之前，系统默认加载DispatcherServlet.properoties文件中的<code>org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</code>注解映射器，3.1版本之后要使用<code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</code>这个注解映射器。在springmvc.xml中进行RequestMappingHandlerMapping的配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解处理器映射器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用RequestMappingHandlerMapping需要在Handler 中使用@controller标识此类是一个控制器，使用@requestMapping指定Handler方法所对应的url。</p>
<h3 id="2-2注解适配器"><a href="#2-2注解适配器" class="headerlink" title="2.2注解适配器"></a>2.2注解适配器</h3><p>pring3.1之前默认加载DispatcherServlet.properoties中的注解适配器是<br><code>org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</code>，3.1版本之后要使用：<br><code>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</code>这个注解适配器。在springmvc.xml中进行如下配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解的适配器--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>RequestMappingHandlerAdapter，不要求Handler实现任何接口，它需要和RequestMappingHandlerMapping注解映射器配对使用，主要解析Handler方法中的形参。</p>
<h3 id="2-3利用注解开发Handler"><a href="#2-3利用注解开发Handler" class="headerlink" title="2.3利用注解开发Handler"></a>2.3利用注解开发Handler</h3><p>利用注解开发的Handler不需要实现任何接口，java代码为如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.stereotype.Controller</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController3</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">//商品列表:@RequestMapping中url建议和方法名一样，方便开发维护</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/queryItems"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">queryItems</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//使用静态的数据将商品信息显示在jsp页面</span></span><br><span class="line">        List&lt;Items&gt; itemsList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Items items_1 = <span class="keyword">new</span> Items();</span><br><span class="line">        items_1.setName(<span class="string">"联想笔记本"</span>);</span><br><span class="line">        items_1.setPrice(<span class="number">6000f</span>);</span><br><span class="line">        items_1.setCreatetime(<span class="keyword">new</span> Date());</span><br><span class="line">        items_1.setDetail(<span class="string">"ThinkPad T430 联想笔记本电脑！"</span>);</span><br><span class="line"></span><br><span class="line">        Items items_2 = <span class="keyword">new</span> Items();</span><br><span class="line">        items_2.setName(<span class="string">"苹果手机"</span>);</span><br><span class="line">        items_2.setPrice(<span class="number">5000f</span>);</span><br><span class="line">        items_2.setCreatetime(<span class="keyword">new</span> Date());</span><br><span class="line">        items_2.setDetail(<span class="string">"iphone6苹果手机！"</span>);</span><br><span class="line"></span><br><span class="line">        itemsList.add(items_1);</span><br><span class="line">        itemsList.add(items_2);</span><br><span class="line"></span><br><span class="line">        ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"itemsList"</span>,itemsList);</span><br><span class="line">        modelAndView.setViewName(<span class="string">"/WEB-INF/jsp/itemsList.jsp"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后在springmvc.xml中对该Handler进行配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注解的Handler</span><br><span class="line">不用id，url在@RequestMapping注解中已经声明--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"controller.ItemController3"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面我们通过对单个注解Handler的配置，也可以使用组件扫描<code>&lt;context:component-scan base-package=&quot;包名&quot;/&gt;</code>对整个包下的Handler进行配置。<br>然后运行服务器输入网址<code>http://localhost:8080/SpringMvc/queryItems.action</code>,正常访问，这里的url为@RequestMapping中的参数。组件扫描还可以可以扫描@Controller、@Service、@component、@Repsitory。</p>
<h2 id="3-Spring-MVC处理流程的源码分析"><a href="#3-Spring-MVC处理流程的源码分析" class="headerlink" title="3.Spring MVC处理流程的源码分析"></a>3.Spring MVC处理流程的源码分析</h2><ol>
<li>用户发送请求到DispatherServlet前端控制器。  </li>
<li>DispatherServlet调用HandlerMapping（处理器映射器）根据url查找Handler。<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%889.18.01.png" alt=""></li>
<li>DispatherServlet调用HandlerAdapter(处理器适配器)对HandlerMapping找到Handler进行包装、执行。HandlerAdapter执行Handler完成后，返回了一个ModleAndView(springmvc封装对象)。DispatherServlet 找一个合适的适配器:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%889.19.49.png" alt=""><br>然后适配器执行Handler:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%889.21.19.png" alt=""></li>
<li>DispatherServlet拿着ModelAndView调用ViewResolver（视图解析器）进行视图解析，解析完成后返回一个View（很多不同视图类型的View）:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%889.24.37.png" alt="">视图解析:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%889.25.32.png" alt=""></li>
<li>进行视图渲染,将Model中的数据 填充到request域:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%889.26.09.png" alt="">  </li>
</ol>
<p>至此，Spring MVC的工作流程我便通过源码的解析为你们阐释清楚了，当然看不懂源码也无所谓，我这里只是为了让你们对底层知识有更深的了解。通过这两篇文章便可以入门Spring MVC了，下篇文章我将为你们讲解Spring、Spring MVC与Mybatis的整合了，不用怕，很简单的！</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring MVC快速入门]]></title>
      <url>http://codingxiaxw.cn/2016/11/13/42-springmvc%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-Spring-MVC框架"><a href="#1-Spring-MVC框架" class="headerlink" title="1.Spring MVC框架"></a>1.Spring MVC框架</h2><h3 id="1-1Spring-MVC介绍"><a href="#1-1Spring-MVC介绍" class="headerlink" title="1.1Spring MVC介绍"></a>1.1Spring MVC介绍</h3><p>SpringMVC和Struts2都属于表现层的框架，它是Spring框架的一个模块，提供web层解决方案，我们可以从Spring的整体结构中看得出来:<br><a id="more"></a><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%887.56.09.png" alt="">  </p>
<h3 id="1-2MVC在b-s系统的应用"><a href="#1-2MVC在b-s系统的应用" class="headerlink" title="1.2MVC在b/s系统的应用"></a>1.2MVC在b/s系统的应用</h3><p>mvc是一个设计模式，在b/s系统的应用如图:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%887.58.00.png" alt="">  </p>
<p>解释如下:  </p>
<ul>
<li>1.用户发起request请求至控制器(Controller),控制接收用户请求的数据，委托给模型进行处理。</li>
<li>2.控制器通过模型(Model)处理数据并得到处理结果，模型通常是指业务逻辑(jsp、dao、service)。</li>
<li>3.模型处理结果返回给控制器。</li>
<li>4.控制器将模型数据在视图(View)中展示，web中模型无法将数据直接在视图上显示，需要通过控制器完成。如果在C/S应用中模型是可以将数据在视图中展示的。</li>
<li>5.控制器将视图response响应给用户，通过视图展示给用户要的数据或处理结果。</li>
</ul>
<h3 id="1-3Spring-mvc架构"><a href="#1-3Spring-mvc架构" class="headerlink" title="1.3Spring mvc架构"></a>1.3Spring mvc架构</h3><h4 id="1-3-1架构图"><a href="#1-3-1架构图" class="headerlink" title="1.3.1架构图"></a>1.3.1架构图</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%888.04.54.png" alt="">  </p>
<h4 id="1-3-2架构流程"><a href="#1-3-2架构流程" class="headerlink" title="1.3.2架构流程"></a>1.3.2架构流程</h4><ul>
<li>1.用户发送请求至前端控制器DispatcherServlet</li>
<li>2.DispatcherServlet收到请求调用HandlerMapping处理器映射器。</li>
<li>3.处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。</li>
<li>4.DispatcherServlet通过HandlerAdapter处理器适配器调用处理器</li>
<li>5.执行处理器(Controller，也叫后端控制器)。</li>
<li>6.Controller执行完成返回ModelAndView</li>
<li>7.HandlerAdapter将controller执行结果ModelAndView返回</li>
<li>8.DispatcherServlet<br>DispatcherServlet将ModelAndView传给ViewReslover视图解析器</li>
<li>9.ViewReslover解析后返回具体View</li>
<li>10.DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。</li>
<li>11.DispatcherServlet响应用户</li>
</ul>
<h4 id="1-3-3架构中涉及的组件说明"><a href="#1-3-3架构中涉及的组件说明" class="headerlink" title="1.3.3架构中涉及的组件说明"></a>1.3.3架构中涉及的组件说明</h4><ul>
<li>1.DispatcherServlet：前端控制器。用户请求到达前端控制器，它就相当于mvc模式中的c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet的存在降低了组件之间的耦合性。由框架实现</li>
<li>2.HandlerMapping：处理器映射器。HandlerMapping负责根据用户请求找到Handler即处理器，springmvc提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。由框架实现</li>
<li>3.Handler：处理器。Handler 是继DispatcherServlet前端控制器的后端控制器，在DispatcherServlet的控制下Handler对具体的用户请求进行处理。由于Handler涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发Handler。</li>
<li>4.HandlAdapter：处理器适配器。通过HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。由框架实现。</li>
<li>5.ViewResolver：视图解析器。ViewResolver负责将处理结果生成View视图，ViewResolver首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 springmvc框架提供了很多的View视图类型，包括：jstlView、freemarkerView、pdfView等。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务需求开发具体的页面。  </li>
</ul>
<h2 id="2-入门程序"><a href="#2-入门程序" class="headerlink" title="2.入门程序"></a>2.入门程序</h2><h3 id="2-1需求"><a href="#2-1需求" class="headerlink" title="2.1需求"></a>2.1需求</h3><p>实现商品列表的查询并在页面中显示。这里由于Spring mvc不涉及对数据库的操作，所以我们在程序中的数据就用静态数据生成。  </p>
<p>工程结构为下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%888.49.46.png" alt="">  </p>
<h3 id="2-2需要的jar包"><a href="#2-2需要的jar包" class="headerlink" title="2.2需要的jar包"></a>2.2需要的jar包</h3><p>这里我使用的是spring3.x(带spring webmvc的模块)。<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%888.15.28.png" alt=""></p>
<h3 id="2-3第一步-前端控制器的配置"><a href="#2-3第一步-前端控制器的配置" class="headerlink" title="2.3第一步:前端控制器的配置"></a>2.3第一步:前端控制器的配置</h3><p>在WEB-INF/web.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span><br><span class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span><br><span class="line">         <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--加载springmvc配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--配置文件的地址</span><br><span class="line">            如果不配置contextConfigLocation，默认查找的配置文件名称是classpath下的:servlet名称+"-servlet.xml"</span><br><span class="line">            即springmvc-servlet.xml--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--可以配置/：此工程所有的请求全部由springmvc解析，此种方式可以实现RESTful方式，需要特殊处理对静态文件的解析不能由springmvc解析</span><br><span class="line">        可以配置*.do或者*.action,所有请求的url扩展名为.do或.action由springmvc解析，此中方法常用</span><br><span class="line">        不可以配置/*,如果配置/*,返回jsp也由springmvc解析，这是不对的--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-4第二步-Spring-MVC配置文件"><a href="#2-4第二步-Spring-MVC配置文件" class="headerlink" title="2.4第二步:Spring MVC配置文件"></a>2.4第二步:Spring MVC配置文件</h3><p>在web目录下创建Spring MVC的配置文件springmvc.xml，以后需要在里面配置Spring MVC架构三大组件(处理器映射器、适配器、视图解析器)，里面根标签的内容同Spring的配置文件:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/mvc</span><br><span class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context</span><br><span class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/aop</span><br><span class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/tx</span><br><span class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="2-5第三步-配置处理器映射器"><a href="#2-5第三步-配置处理器映射器" class="headerlink" title="2.5第三步:配置处理器映射器"></a>2.5第三步:配置处理器映射器</h3><p>因为对于用户发起的request请求，前端控制器首先会请求HandlerMapping处理器映射器来查找Handler，所以我们首先配置它，在springmvc.xml中加入如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置处理器映射器</span><br><span class="line">    springmvc框架根据HandlerMapping接口判断是否是处理器映射器--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--根据bean的name进行查找Handler,将action的url配置在bean的name中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span></span><br><span class="line">        <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>BeanNameUrlHandlerMapping</code>:表示将定义的Bean名字作为请求的url，需要将编写的controller在spring容器中进行配置，且指定bean的name为请求的url，且必须以.action结尾。  </p>
<h3 id="2-6第四步-配置处理器适配器"><a href="#2-6第四步-配置处理器适配器" class="headerlink" title="2.6第四步:配置处理器适配器"></a>2.6第四步:配置处理器适配器</h3><p>处理器映射器将查找到的Handler返回给DispatcherServlet后，DispatcherServlet会调用适配器执行Handler，通过适配器去扩展对不同Handler的执行。所以我们再配置它,在springmvc.xml中添加如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置处理器适配器</span><br><span class="line">    springmvc框架根据HandlerAdapter接口判断是否是处理器适配器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>SimpleControllerHandlerAdapter</code>:即简单控制器处理适配器，所有实现了<code>org.springframework.web.servlet.mvc.Controller</code> 接口的Bean作为Springmvc的后端控制器。  </p>
<h3 id="2-7第五步-后端控制器的编写"><a href="#2-7第五步-后端控制器的编写" class="headerlink" title="2.7第五步:后端控制器的编写"></a>2.7第五步:后端控制器的编写</h3><p>DispatcherServlet通过处理器适配器找到后端控制器Handler，所以我们需要进行Handler的编写,在src包下新建ItemController.java，内容如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.mvc.Controller;</span><br><span class="line"><span class="keyword">import</span> po.Items;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by codingBoy on 16/11/13.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemController1</span> <span class="keyword">implements</span> <span class="title">Controller</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest httpServletRequest,</span><br><span class="line">                                      HttpServletResponse httpServletResponse)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//使用静态的数据将商品信息显示在jsp页面</span></span><br><span class="line">        List&lt;Items&gt; itemsList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Items items_1 = <span class="keyword">new</span> Items();</span><br><span class="line">        items_1.setName(<span class="string">"联想笔记本"</span>);</span><br><span class="line">        items_1.setPrice(<span class="number">6000f</span>);</span><br><span class="line">        items_1.setCreatetime(<span class="keyword">new</span> Date());</span><br><span class="line">        items_1.setDetail(<span class="string">"ThinkPad T430 联想笔记本电脑！"</span>);</span><br><span class="line"></span><br><span class="line">        Items items_2 = <span class="keyword">new</span> Items();</span><br><span class="line">        items_2.setName(<span class="string">"苹果手机"</span>);</span><br><span class="line">        items_2.setPrice(<span class="number">5000f</span>);</span><br><span class="line">        items_2.setDetail(<span class="string">"iphone6苹果手机！"</span>);</span><br><span class="line"></span><br><span class="line">        itemsList.add(items_1);</span><br><span class="line">        itemsList.add(items_2);</span><br><span class="line"></span><br><span class="line">        ModelAndView modelAndView=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"itemsList"</span>,itemsList);</span><br><span class="line">        modelAndView.setViewName(<span class="string">"/WEB-INF/jsp/itemsList.jsp"</span>);<span class="comment">//指定用户访问的jsp页面地址</span></span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据我们采用静态数据的输入，当然我们还需要创建Items.java这个pojo对象，就是上一篇文章中我们用到的.java文件。  </p>
<h3 id="2-8第六步-后端控制器的配置"><a href="#2-8第六步-后端控制器的配置" class="headerlink" title="2.8第六步:后端控制器的配置"></a>2.8第六步:后端控制器的配置</h3><p>在springmvc.xml中配置Handler由spring来管理Handler,在springmvc.xml文件中添加如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置Handler</span><br><span class="line">由于使用了BeanNameUrlHandlerMapping处理映射器，所以name要配置为url--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"/itemList.action"</span> <span class="attr">class</span>=<span class="string">"controller.ItemController1"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>name=&quot;/itemsList.action&quot;</code>:前边配置的处理器映射器为<code>BeanNameUrlHandlerMapping</code>，如果请求的URL为“上下文/itemsList.action”将会成功映射到ItemController1控制器。</p>
<h3 id="2-9配置视图解析器"><a href="#2-9配置视图解析器" class="headerlink" title="2.9配置视图解析器"></a>2.9配置视图解析器</h3><p>Handler执行完成后给处理器适配器返回一个ModelAndView对象，它是Spring MVC的一个对象，用于对Model和View进行封装。然后处理器适配器又将这个对象返回给DispatcherServlet,DispatcherServlet调用视图解析器进行视图解析，所以这里我们要配置视图解析器，在springmvc.xml中添加如下内容:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置视图解析器</span><br><span class="line">    要求将jstl的包加到classpath--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后部署服务器，在浏览器中输入<code>http://localhost:8080/SpringMvc/itemList.action</code>后便可以看到如下页面:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%888.47.32.png" alt=""></p>
<p>通过上面的讲解我们便完成了对Spring MVC开发框架的入门,更多的处理器映射器和处理器适配器的介绍见我的spring mvc第二篇文章<a href="http://codingxiaxw.cn/2016/11/14/43-springmvc%E4%B9%8B%E6%B3%A8%E8%A7%A3%E4%B8%8E%E9%9D%9E%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8/">Spring MVC之注解与非注解映射器和适配器</a>。  </p>
<p><strong>扩展:</strong>对于前端控制器DispatcherServlet,我有必要多说几句，在spring-webmvc.jar包中有一个DispatcherServlet.properties文件，内容如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%886.51.45.png" alt="">  </p>
<p>里面包含一些默认的组件例如处理器映射器、处理器适配器等，当程序启动时，DispatcherServlet会自动加载DispatcherServlet.properties配置文件，从而默认加载各个组件，所以如果我们在springmvc.xml中配置了处理器映射器和处理器适配器，那程序就以springmvc.xml中的配置信息为主。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用IDEA开发MyBatis逆向工程]]></title>
      <url>http://codingxiaxw.cn/2016/11/13/41-mybatis9%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>以往我们在开发时都需要通过数据库中的表然后自己在po包下建立相对应的pojo类，并要创建相应的mapper.xml写出对表的所有操作，而使用mybatis逆向工程就不用我们自己再编写pojo类与相应的mapper.java和mapper.xml文件，它可以自动对单表生成sql，包括:mapper.xml、mapper.java、表名.java(po类)。是不是很方便？接下来我将为你们介绍如何使用mybatis的逆向工程，只需三步便可以简单做到。  </p>
<a id="more"></a>   
<p><a href="https://github.com/codingXiaxw/generator" target="_blank" rel="external">源码请点击这里前往我的github</a>  </p>
<p>首先我们需要在官网下载:<a href="http://www.mybatis.org/generator/" target="_blank" rel="external">逆向工程开发文档</a>以及jar包:mybatis-generator-core-bundle。为什么我的标题要注明使用的开发工具是IDEA呢?用IDEA的好处就是可以使用Maven依赖，但是此篇文章中我们就新建一个普通工程，所以此篇文章讲解的配置在其他开发工具中能实现同样的效果。  </p>
<h2 id="1-逆向工程使用配置"><a href="#1-逆向工程使用配置" class="headerlink" title="1.逆向工程使用配置"></a>1.逆向工程使用配置</h2><h3 id="1-1jar包的导入"><a href="#1-1jar包的导入" class="headerlink" title="1.1jar包的导入"></a>1.1jar包的导入</h3><p>这里我们需要导入四个包，1.mybatis3.xjar包。2.逆向工程核心包。3.数据库连接包。4.log4j.jar，用于输出日志。目录如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-15%20%E4%B8%8B%E5%8D%885.46.07.png" width="50%" height="50%">  </p>
<h3 id="1-2配置逆向工程的配置文件"><a href="#1-2配置逆向工程的配置文件" class="headerlink" title="1.2配置逆向工程的配置文件"></a>1.2配置逆向工程的配置文件</h3><p>在src包下创建逆向工程配置文件generatorConfig.xml,内容如下，直接拷贝官网介绍的内容即可:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span><br><span class="line">  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span><br><span class="line">  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"testTables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--数据库连接的信息：驱动类、连接地址、用户名、密码 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.jdbc.Driver"</span></span><br><span class="line">			<span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span> <span class="attr">userId</span>=<span class="string">"root"</span></span><br><span class="line">			<span class="attr">password</span>=<span class="string">"xiaxunwu1996."</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;jdbcConnection driverClass="oracle.jdbc.OracleDriver"</span><br><span class="line">			connectionURL="jdbc:oracle:thin:@127.0.0.1:1521:yycg"</span><br><span class="line">			userId="yycg"</span><br><span class="line">			password="yycg"&gt;</span><br><span class="line">		&lt;/jdbcConnection&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和</span><br><span class="line">			NUMERIC 类型解析为java.math.BigDecimal --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- targetProject:生成PO类的位置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"po"</span></span><br><span class="line">			<span class="attr">targetProject</span>=<span class="string">".\src"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- targetProject:mapper映射文件生成的位置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span></span><br><span class="line">			<span class="attr">targetProject</span>=<span class="string">".\src"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- targetPackage：mapper接口生成的位置 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span></span><br><span class="line">			<span class="attr">targetPackage</span>=<span class="string">"mapper"</span></span><br><span class="line">			<span class="attr">targetProject</span>=<span class="string">".\src"</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 指定数据库表 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"items"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"orders"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"orderdetail"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;table schema="" tableName="sys_user"&gt;&lt;/table&gt;</span><br><span class="line">		&lt;table schema="" tableName="sys_role"&gt;&lt;/table&gt;</span><br><span class="line">		&lt;table schema="" tableName="sys_permission"&gt;&lt;/table&gt;</span><br><span class="line">		&lt;table schema="" tableName="sys_user_role"&gt;&lt;/table&gt;</span><br><span class="line">		&lt;table schema="" tableName="sys_role_permission"&gt;&lt;/table&gt; --&gt;</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">&lt;!-- 有些表的字段需要指定java类型</span><br><span class="line">		 &lt;table schema="" tableName=""&gt;</span><br><span class="line">			&lt;columnOverride column="" javaType="" /&gt;</span><br><span class="line">		&lt;/table&gt; --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>需要修改的地方:  </p>
<ul>
<li>javaModelGenerator,生成PO类的位置</li>
<li>sqlMapGenerator,mapper映射文件生成的位置</li>
<li>javaClientGenerator,mapper接口生成的位置</li>
<li>table,其tableName属性对应数据库中相应表</li>
</ul>
<h3 id="1-3执行生成代码"><a href="#1-3执行生成代码" class="headerlink" title="1.3执行生成代码"></a>1.3执行生成代码</h3><p>在src包下新建一个Generator.java文件，内容如下，也是拷贝的官网中介绍的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.api.MyBatisGenerator;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.config.xml.ConfigurationParser;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.generator.internal.DefaultShellCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GeneratorSqlmap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generator</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//指定 逆向工程配置文件</span></span><br><span class="line">        File configFile = <span class="keyword">new</span> File(<span class="string">"src/generatorConfig.xml"</span>);</span><br><span class="line">        ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">        DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">        MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config,</span><br><span class="line">                callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            GeneratorSqlmap generatorSqlmap = <span class="keyword">new</span> GeneratorSqlmap();</span><br><span class="line">            generatorSqlmap.generator();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这里new File中传入的参数只能是<code>src/generatorConfig.xml</code>而不能为<code>generatorConfig.xml</code>，否则会出现<code>java.io.FileNotFoundException: generatorConfig.xml (No such file or directory)</code>的报错信息，运行程序，在打印台看到输出日志信息为:<img src="http://od2xrf8gr.bkt.clouddn.com/111.png" alt="">  </p>
<p>然后再点击文件目录上的刷新图标刷新文件目录，文件目录下出现我们通过单表映射出来的po类包以及mapper包下的mapper.xml和mapper.java，刚开始的工程目录如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-15%20%E4%B8%8B%E5%8D%885.55.50.png" width="50%" height="20%"><br>运行程序后最后的工程目录结构如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-15%20%E4%B8%8B%E5%8D%885.53.21.png" width="50%" height="20%">  </p>
<p>这样我们便通过mybatis的逆向工程完成了通过单表直接创建出对应的mapper.java和mapper.xml的工作。</p>
<h2 id="2-逆向工程的应用"><a href="#2-逆向工程的应用" class="headerlink" title="2.逆向工程的应用"></a>2.逆向工程的应用</h2><p>逆向工程往往是单独的建立一个普通工程如A，通过运行逆向工程生成相应的mapper和po后然后再将这两个包拷贝到我们使用到ssm框架创建的web项目，而不是直接在web项目中使用逆向工程。  </p>
<p>通过运行上述的程序，我们便通过数据库中的表快速的生成了相应的po类和mapper，而不用我们程序员自己再编写相应的po类和mapper，为我们带来了很大的方便，所以这个一定要学会，在后续开发中只要使用到mybatis的地方我们都会通过mybatis的逆向工程自动为我们生成mapper和po类。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis3.x和Spring3.x的整合]]></title>
      <url>http://codingxiaxw.cn/2016/11/12/40-mybatis%E4%B8%8Espring%E7%9A%84%E6%95%B4%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="1-mybatis和spring整合的思路"><a href="#1-mybatis和spring整合的思路" class="headerlink" title="1.mybatis和spring整合的思路"></a>1.mybatis和spring整合的思路</h2><p>1.让spring管理SqlSessionFactory<br>2.让spring管理mapper对象和dao  </p>
<blockquote>
<p>使用spring和mybatis整合开发mapper代理及原始dao接口。<br>自动开启事务，自动管理sqlsession</p>
</blockquote>
<a id="more"></a>
<p>3.让spring管理数据源(即数据库连接池)  </p>
<h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h2><h3 id="2-1创建整合工程"><a href="#2-1创建整合工程" class="headerlink" title="2.1创建整合工程"></a>2.1创建整合工程</h3><p>新建项目，拷贝前一天所建mybatis的项目，现在的项目结构为:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%886.15.47.png" width="50%" height="30%"> </p>
<h3 id="2-2-导入jar包"><a href="#2-2-导入jar包" class="headerlink" title="2.2.导入jar包"></a>2.2.导入jar包</h3><p>1.mybatis3.x本身的jar包<br>2.数据库驱动包<br>3.spring3.xjar包<br>4.spring和mybatis的整合包:从mybatis官方下载mybatis-spring-1.2.2.jar  </p>
<h3 id="2-3-SqlMapConfig-xml"><a href="#2-3-SqlMapConfig-xml" class="headerlink" title="2.3.SqlMapConfig.xml"></a>2.3.SqlMapConfig.xml</h3><p>mybatis的配置文件:设置别名、mappers。如下<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%886.18.44.png" alt=""></p>
<p>mybatis和spring整合后，mybatis配置文件中的<code>&lt;mappers&gt;</code>标签便可以去掉，因为我们在spring配置文件中进行对mapper的配置;别名配置标签<code>&lt;typeAliases&gt;</code>也可以去掉，因为我们也可以在spring配置文件中对pojo全限定性类名的别名进行配置。  </p>
<h3 id="2-4-applicationContext-xml"><a href="#2-4-applicationContext-xml" class="headerlink" title="2.4.applicationContext.xml"></a>2.4.applicationContext.xml</h3><p>spring配置文件中需要配置的内容有:1.数据源(用的是dbcp连接池，数据库的连接配置写在src路径下的db.properties文件中)。2.SqlSessionFactory。3.mapper或dao。如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">           <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span><br><span class="line">           <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">           <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">           <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/mvc</span><br><span class="line">		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/context</span><br><span class="line">		http://www.springframework.org/schema/context/spring-context-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/aop</span><br><span class="line">		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd</span><br><span class="line">		http://www.springframework.org/schema/tx</span><br><span class="line">		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd "</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 1.加载数据库的配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 2.配置数据库连接池 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span></span><br><span class="line">		<span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdle"</span> <span class="attr">value</span>=<span class="string">"5"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 3.配置SqlsessionFactory，引入的是mybatis和sqlsession整合包下的SqlSessionFactoryBean类 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 下面才是mybatis和spring整合最重要的步骤:a.注入数据源 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- b.mybati全局s配置文件 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:SqlMapConfig.xml"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!-- 4.配置mapper</span><br><span class="line">	MapperFactoryBean：用于生成mapper代理对象</span><br><span class="line">	 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--&lt;bean id="userMapper" class="org.mybatis.spring.mapper.MapperFactoryBean"&gt;--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--&lt;property name="mapperInterface" value="mapper.UserMapper"/&gt;--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--&lt;property name="sqlSessionFactory" ref="sqlSessionFactory"/&gt;--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--&lt;/bean&gt;--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--</span><br><span class="line">	MapperScannerConfigurer：mapper的扫描器，将包下边的mapper接口自动创建代理对象，</span><br><span class="line">	自动创建到spring容器中，bean的id是mapper的类名（首字母小写）</span><br><span class="line">	 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置扫描包的路径</span><br><span class="line">		如果要扫描多个包，中间使用半角逗号分隔</span><br><span class="line">		要求:Mapper.java与Mapper.xml文件在同一个目录下</span><br><span class="line">		 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"mapper"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 使用sqlSessionFactoryBeanName --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>到此处，我们便完成了mybatis与spring的整合，接下来便可以进行测试了。从整合后的mybatis配置文件和spring的配置文件来来，整合后的mybatis配置文件中的内容基本都被移到了spring的配置文件中。</p>
<h2 id="3-整合开发原始dao接口"><a href="#3-整合开发原始dao接口" class="headerlink" title="3.整合开发原始dao接口"></a>3.整合开发原始dao接口</h2><h3 id="3-1配置SqlSessionFactory"><a href="#3-1配置SqlSessionFactory" class="headerlink" title="3.1配置SqlSessionFactory"></a>3.1配置SqlSessionFactory</h3><p>在applicationContext.xml中配置SqlSessionFactory，为上图的:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%886.22.55.png" alt="">  </p>
<h3 id="3-2开发原始dao"><a href="#3-2开发原始dao" class="headerlink" title="3.2开发原始dao"></a>3.2开发原始dao</h3><p>将dao接口的实现类UserDaoImpl.java继承SqlSessionDaoSupport.java，该父类中有属性的set方法并已经声明SqlSessionFactory对象，所以我们在UserDaoImpl.java中只需要写如下代码:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%886.25.45.png" alt="">  </p>
<p>然后需要在spring配置文件中配置dao:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%886.26.42.png" alt="">  </p>
<p>测试:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%886.27.16.png" alt="">  </p>
<p>控制台中成功打印出结果:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%886.27.34.png" alt="">  </p>
<h2 id="4-整合开发mapper代理方法"><a href="#4-整合开发mapper代理方法" class="headerlink" title="4.整合开发mapper代理方法"></a>4.整合开发mapper代理方法</h2><p>首先在mapper包下创建UserMapper.java和UserMapper.xml文件，利用mybatis和spring整合开发mapper的方式有两种。  </p>
<h3 id="4-1使用MapperFactoryBean"><a href="#4-1使用MapperFactoryBean" class="headerlink" title="4.1使用MapperFactoryBean"></a>4.1使用MapperFactoryBean</h3><p>该类是整合jar包下的一个类，它的内部已经继承SqlSessionDaoSupport类，首先我们需要在spring配置文件中进行Mapper对象的配置:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%887.43.40.png" alt="">  </p>
<p>然后便可以进行测试:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%887.44.57.png" alt="">  </p>
<p>这样就完成了对mapper的开发，使用这种方式的缺点就是对于项目中的每个mapper我们都需要配置上述内容，比较繁琐。接下来看看下面这种开发mapper代理的方式。  </p>
<h3 id="4-2使用MapperScannerConfigurer-扫描mapper"><a href="#4-2使用MapperScannerConfigurer-扫描mapper" class="headerlink" title="4.2使用MapperScannerConfigurer(扫描mapper)"></a>4.2使用MapperScannerConfigurer(扫描mapper)</h3><p>该类同样是整合jar包中的一个类。在spring配置文件中加入如下配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%888.08.48.png" alt="">  </p>
<p>然后进行测试:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%887.44.57.png" alt="">同样正常运行。  </p>
<p>使用这种方式的优点:使用扫描器自动扫描mapper，生成代理对象比较方便。</p>
<h2 id="5-出现异常总结"><a href="#5-出现异常总结" class="headerlink" title="5.出现异常总结"></a>5.出现异常总结</h2><p>使用MapperFactoryBean的方式不会报错，但是使用这样扫描包的方式，上述代码我完全是照搬的教程代码，可是运行时会出现<code>org.springframework.beans.factory.BeanDefinitionStoreException</code>的报错。  </p>
<p>出现这个异常的原因你不用多想，绝对是因为你的spring 版本与开发工具的jdk版本不兼容！之前在单独开发spring框架中使用到<code>&lt;content:component-scan base-package=&quot;包名&quot;</code>注解扫描声明整个pojo包下的类时也出现了这个错误，那时候我将spring3.x.jar包换成spring4.x.jar包后成功解决，因为我的开发工具IDEA默认jdk版本是1.8，所以我要升级jar包版本才能实现兼容。  </p>
<p>整合spring和mybatis时又出现了这个错误！所以这里我决定像之前那样将spring3.x换成sring4.x，可是我已经导入的jar包太多太多实在分不清了，经过很多的轮回换jar包后又出现了更多的异常。我为这个异常真是头疼了几天几夜，经过几天的不断研究找资料才发现原因是因为我用的spring 3.x的jar包，与IDEA的jdk1.8不兼容，解决方法有两种:  </p>
<ul>
<li>1.将jdk版本调为1.7，我用的开发工具为IDEA，它默认下的JDK使用1.8版本，所以我需要在三个地方将jdk的版本改过来(前提是你已经下载了jdk1.7版本)，修改IDEA配置中Project的jdk版本、Modules的jdk版本、SDKs的版本，如果你用到leTomcat还需要修改Tomcat配置的jdk版本。这样jdk1.7与spring3.x才兼容。</li>
<li>2.将spring3.x.jar换成spring4.x.jar包。这种方式比较繁琐，建议大家使用第一种方式。spring4.x与jdk1.8才兼容。</li>
</ul>
<p>写到这里，我们便成功的完成了spring3.x与mybatis3.x的整合。整合完后我们便可以从mybatis的配置文件中删掉对mapper的配置了，因为我们已经在spring配置文件中用mapper扫描器对mapper进行了配置。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring————程序员的春天]]></title>
      <url>http://codingxiaxw.cn/2016/11/11/39-Spring/</url>
      <content type="html"><![CDATA[<p>当客户端向服务器发出请求时，服务器把得到的请求发送给控制器Servlet，而在Servlet中需要创建Service对象来调用业务层相关功能(故说控制器层Servlet依赖于业务层Service),而在Service中又需要创建数据库层DAO对象来对数据库进行操作(故说业务层Service依赖于数据库层DAO)。<br><a id="more"></a><br><strong>思考:</strong>针对上述过程，我们需要考虑这样几个问题。1.Servlet、Service以及Dao对象的创建时间、创建数量。2.Servlet、Service以及Dao之间的依赖关系。如何处理这些问题呢？Spring就是用来处理对象的创建、以及对象之间依赖关系的一个开发框架。它打破了我们传统开发的观念，我们不再需要像以前那样在具体的类中创建具体的对象，而是将对象的创建交给它去完成。它是我们所要学习的框架中最重要的框架，请务必好好学习。  </p>
<h2 id="1-Spring框架中的专业术语"><a href="#1-Spring框架中的专业术语" class="headerlink" title="1.Spring框架中的专业术语"></a>1.Spring框架中的专业术语</h2><h3 id="1-1组件／框架设计"><a href="#1-1组件／框架设计" class="headerlink" title="1.1组件／框架设计"></a>1.1组件／框架设计</h3><ul>
<li>侵入式设计:对现有类的结构有影响，即需要实现或继承某些特定类。 如Struts框架。 </li>
<li>非侵入式设计:引入了框架，对现有的类结构没有影响。如Spring框架／Hibernate框架。</li>
</ul>
<h3 id="1-2控制反转"><a href="#1-2控制反转" class="headerlink" title="1.2控制反转"></a>1.2控制反转</h3><p>Inversion On Control，简称IOC。对象的创建交给外部容器自动完成，这个就叫做控制反转。(有控制反转就有控制正转，控制正转:对象的创建由我们自己创建)  </p>
<p>依赖注入dependency injection,简称DI，用于处理对象间的依赖关系。  </p>
<p><strong>二者区别:</strong>控制反转(IOC):解决对象创建的问题，(对象的创建交给别人)。依赖注入(DI):在创建完对象后，对象关系的处理就是依赖注入，(通过set方法依赖注入。)</p>
<h3 id="1-3AOP"><a href="#1-3AOP" class="headerlink" title="1.3AOP"></a>1.3AOP</h3><p>面向切面编程。切面，简单来说可以理解为一个类，由很多重复代码形成的类。切面举例:事务、日志、权限。 关于AOP的详细讲解我推荐你们看这篇博客:<a href="http://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="external">Spring AOP实现原理与应用</a> ，往后我会单独写篇博客为你们详细介绍AOP。 </p>
<h2 id="2-Spring框架概述"><a href="#2-Spring框架概述" class="headerlink" title="2.Spring框架概述"></a>2.Spring框架概述</h2><p>Spring框架，可以解决对象创建以及对象之间依赖关系的一种框架。且可以和其它框架一起使用，例如spring与struts、spring和hibernate。(起到整合／粘合作用的一个框架)。  </p>
<p>spring提供了一站式解决方案:<br>1）SpringCore:是Spring的核心功能：IOC容器，解决对象创建及依赖关系。<br>2）SpringWeb:Spring对web模块的支持。</p>
<blockquote>
<p>可以与struts整合，让struts的action创建交给spring。<br>Spring mvc模式，用springmvc整合了就不用struts了。  </p>
</blockquote>
<p>3）Spring DAO:是Spring对Jdbc操作的支持。(Jdbc Template模块工具类)  </p>
<p>4)Spring ORM:是Spring对ORM的支持。</p>
<blockquote>
<p>既可以与hibernate整合(使用原始的session)<br>也可以使用Spring对Hibernate操作的封装(对上面的session又进行了一层封装)  </p>
</blockquote>
<p>5）Spring AOP:关于AOP的详细讲解我推荐你们看这篇博客:<a href="http://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/" target="_blank" rel="external">Spring AOP实现原理与应用</a> ，往后我会单独写篇博客为你们详细介绍AOP。 </p>
<p>6）SpringEE:Spring对javaEE其它模块的支持</p>
<h2 id="3-Spring开发步骤"><a href="#3-Spring开发步骤" class="headerlink" title="3.Spring开发步骤"></a>3.Spring开发步骤</h2><p><strong>1)导入jar包:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-13%20%E4%B8%8B%E5%8D%882.01.02.png" alt="">  </p>
<p><strong>写在前面的话:</strong>当你运行程序出现<code>org.springframework.beans.factory.BeanDefinitionStoreException</code>的报错信息时，不要想了，出现这种报错的信息原因绝对是因为jdk版本和你导入的spring jar包不兼容的问题。由于spring3.x与jdk1.7兼容，而spring4.x与jdk1.8兼容，所以这里提供两种解决方案:  </p>
<ul>
<li>1.将jdk版本调为1.7，我用的开发工具为IDEA，它默认下的JDK使用1.8版本，所以我需要在三个地方将jdk的版本改过来(前提是你已经下载了jdk1.7版本)，修改IDEA配置中Project的jdk版本、Modules的jdk版本、SDKs的版本，如果你用到leTomcat还需要修改Tomcat配置的jdk版本。这样jdk1.7与spring3.x才兼容。</li>
<li>2.将spring3.x.jar换成spring4.x.jar包。这种方式比较繁琐，建议大家使用第一种方式。spring4.x与jdk1.8才兼容。</li>
</ul>
<p><strong>2)配置核心文件applicationContext.xml(文件名称随意):</strong></p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.32.28.png" alt="">  </p>
<p>代码如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span><br><span class="line">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span><br><span class="line">        http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>3)使用:</strong>  </p>
<p>首先我们创建一个pojo对象User.java:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.48.12.png" alt="">  </p>
<p>然后创建测试类使用这个User对象，以前我们要使用User对象时直接像这样<code>User user=new User();</code>new一个对象即可:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.50.26.png" alt="">  </p>
<p>而当我们使用Spring后就应该这样使用User对象，首先在applicationContext.xml中添加<code>&lt;bean&gt;</code>标签，一个<code>&lt;bean&gt;</code>标签代表一个pojo对象:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.53.52.png" alt="">  </p>
<p>其中各个属性的说明见注释。然后我们通过如下步骤获取该pojo对象:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.59.37.png" alt="">  </p>
<p>运行测试类:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%885.59.42.png" alt="">  </p>
<p>说明成功获取到User对象。上述是通过工厂类获取的IOC容器创建的User对象，下面我们看看使用Spring框架获取pojo对象的第二种方式直接得到IOC容器的对象:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.05.52.png" alt="">  </p>
<p>运行程序，成功打印出user信息，说明我们通过IOC容器成功获取到user对象。  </p>
<h2 id="4-lt-bean-gt-创建的细节"><a href="#4-lt-bean-gt-创建的细节" class="headerlink" title="4.&lt;bean&gt;创建的细节"></a>4.<code>&lt;bean&gt;</code>创建的细节</h2><p>对上述代码进行改进，对于IOC容器对象，我们只需创建一次即可，所以将创建IOC对象的代码改为成员变量。  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.14.51.png" alt="">  </p>
<p>代码中我们通过IOC对象创建了两个User对象，运行测试类得到打印结果:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.15.44.png" alt="">  </p>
<p>发现答应的这两个User对象id都一样，说明我们获取到的是同一个对象，也说明通过<code>&lt;bean&gt;</code>标签设置的pojo对象是单例的。为什么呢？其实<code>&lt;bean&gt;</code>标签默认有一个<code>scope=&quot;singleton&quot;</code>的属性，代表该<code>&lt;bean</code>标签对象的pojo对象是单例的。我们可以将该属性值改为<code>scope=&quot;prototype&quot;</code>，如下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.18.48.png" alt="">  </p>
<p>然后再运行测试类,输出如下内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.19.43.png" alt="">  </p>
<p>说明此时获取的两个User不再是同一个对象。  </p>
<p>那么由IOC容器管理的pojo对象应该在何时创建呢？我们来看看，首先在User.java中添加一个无参构造器:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.31.57.png" alt="">  </p>
<p>然后修改测试类:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.32.37.png" alt="">  </p>
<p>运行测试类:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.33.24.png" alt="">  </p>
<p>从控制台中输出内容我们可以得知:当程序运行时，IOC容器首先创建，然后当我们需要得到IOC容器中的pojo对象时我们通过语句<code>ac.getBean(&quot;user&quot;);</code>得到，此时就会在IOC中创建由它管理的pojo对象。当我们删除<code>ac.getBean(&quot;user&quot;);</code>语句时，再次运行程序，得到如下内容:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.36.49.png" alt="">  </p>
<p>这说明什么呢?说明IOC容器中没有创建pojo对象(因为一旦创建就会有”—User对象创建—“的语句输出)。综上情况，即只有当我们用到pojo对象时，IOC容器才会在自己内部创建它。此种情况为<code>&lt;bean&gt;</code>标签的属性为<code>scope=&quot;prototype&quot;</code>的结果，那么我们再来看看当属性为<code>scope=&quot;singleton&quot;</code>时的输出结果为:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.40.53.png" alt="">  </p>
<p>打印台的内容说明该User对象在程序启动时就创建在IOC容器中了，不信我们把通过IOC容器得到User对象的代码注释掉再看输出结果:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%886.42.48.png" alt="">  </p>
<p>发现此时即使我们不通过<code>ac.getBean(&quot;user&quot;);</code>语句得到User对象，它也在程序启动时就创建了。</p>
<p>总结:在<code>&lt;bean&gt;</code>标签中设置bean对象为单例时，该对象在系统启动时就会创建；设置为多例时，该对象在我们需要使用时才创建。</p>
<h3 id="4-1-lt-bean-gt-标签中的其它属性说明"><a href="#4-1-lt-bean-gt-标签中的其它属性说明" class="headerlink" title="4.1&lt;bean&gt;标签中的其它属性说明"></a>4.1<code>&lt;bean&gt;</code>标签中的其它属性说明</h3><ul>
<li>1.<code>lazy-init:</code>延迟初始化bean对象，默认值为false，即不延迟创建bean对象，在程序启动时就在IOC中创建bean对象；若其值为true则延迟创建bean对象，即在我们需要对象时才在IOC容器中创建该对象。此属性只对单例bean对象有效。</li>
<li>2.<code>init-method:</code>可以给该属性传递一个在pojo对象中创建的方法例如A方法的方法名A作为init-method的属性值，表示当该pojo对象在IOC容器中被创建后就立刻执行这个A方法。</li>
<li>3.<code>destoy-method:</code>同上，给该属性传递一个在pojo对象中创建的方法例如B方法的方法名B作为destoy-method的属性值，表示当IOC容器被销毁时(该pojo对象也会在IOC中销毁)会立刻调用这个B方法。当然我们通过<code>ApplicationContext ac=new  ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code>创建的IOC对象ac是没有destoy()方法的，我们需要这个创建IOC对象<code>ClassPathXmlApplicationContext ac=new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);</code>这样创建出来的IOC对象才有destoy()方法。</li>
</ul>
<h2 id="5-Spring-IOC容器"><a href="#5-Spring-IOC容器" class="headerlink" title="5.Spring IOC容器"></a>5.Spring IOC容器</h2><p>Spring IOC容器，是Spring的核心内容，用于创建对象和处理对象间的依赖关系。</p>
<h3 id="5-1对象的创建"><a href="#5-1对象的创建" class="headerlink" title="5.1对象的创建"></a>5.1对象的创建</h3><p>利用IOC容器创建对象的方式有如下几种:1.调用无参数构造器。2.调用带参数构造器。3.工厂创建对象。包括工厂类的静态方法创建对象和工厂类的非静态方法创建对象4.反射。(IOC的原理就是通过反射来创建对象)</p>
<h4 id="5-1-1调用无参数构造器"><a href="#5-1-1调用无参数构造器" class="headerlink" title="5.1.1调用无参数构造器"></a>5.1.1调用无参数构造器</h4><p>在配置文件中加入如下内容:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.43.png" alt=""></p>
<h4 id="5-1-2调用带参数构造器"><a href="#5-1-2调用带参数构造器" class="headerlink" title="5.1.2调用带参数构造器"></a>5.1.2调用带参数构造器</h4><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.50.png" alt="">  </p>
<p><code>&lt;constructor-arg&gt;</code>标签中还有一个ref的属性，属性值代表引用配置文件(即IOC容器)中的相应对象。  </p>
<p>故还可以采用这种方法调用带参数构造器创建对象:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.31.58.png" alt="">  </p>
<h4 id="5-1-3工厂创建对象"><a href="#5-1-3工厂创建对象" class="headerlink" title="5.1.3工厂创建对象"></a>5.1.3工厂创建对象</h4><p>首先创建一个工厂类: <img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.34.32.png" alt="">  </p>
<p>调用工厂的实例方法创建对象:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.32.02.png" alt="">  </p>
<p>调用工厂静态方法创建对象:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-14%20%E4%B8%8B%E5%8D%881.32.05.png" alt="">  </p>
<h3 id="5-2处理对象的依赖关系"><a href="#5-2处理对象的依赖关系" class="headerlink" title="5.2处理对象的依赖关系"></a>5.2处理对象的依赖关系</h3><p>在IOC容器的配置文件中我们有如下给对象注入属性的方法:1.通过构造方法。2.通过set方法给属性注入值。3.p名称空间。4.自动装配。5.注解。  </p>
<h4 id="5-2-1通过构造方法"><a href="#5-2-1通过构造方法" class="headerlink" title="5.2.1通过构造方法"></a>5.2.1通过构造方法</h4><p>首先我们来看看如何通过构造方法来给对象的属性赋值,在配置文件中添加如下标签即可通过构造器给该User对象的属性赋值:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.21.03.png" alt="">  </p>
<h4 id="5-2-2通过set方法"><a href="#5-2-2通过set方法" class="headerlink" title="5.2.2通过set方法"></a>5.2.2通过set方法</h4><p>通过set方法给属性赋值,前提是在User对象中给它的属性添加了set方法:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.26.29.png" alt="">  </p>
<p>接下来我们看个案例，以前我们开发时根据MVC模式都会像下面这样建立相应的Service.java、Servlet.java和dao.java:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.38.05.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.38.10.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.38.30.png" alt="">  </p>
<p>都需要我们自己在.java文件中添加<code>A a=new A();</code>来创建其所需要的依赖对象，而现在我们就将对象的创建交给IOC了，选择set给属性赋值的方式来给它们注入其所需依赖对象，修改它们的代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.44.48.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.44.53.png" alt="">  </p>
<p>然后我们需要在application.xml中进行配置:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%884.48.51.png" alt="">  </p>
<p>ref的属性值代表给该对象注入它所依赖的对象，即我们上述讲到的依赖注入(dependency injection),通过上述步骤我们便完成了将对象的创建交给IOC的操作。  </p>
<p>上述三个对象的创建我们需要写三个<code>&lt;bean&gt;</code>标签才能完成，接下来我将介绍第二种方法通过内部bean的操作一次性完成它们的创建以及它们之间的依赖关系，修改配置文件中的内容:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%885.04.23.png" alt="">  </p>
<p>通过上述内部<code>&lt;bean&gt;</code>标签的方式我们便可实现和set注入依赖相同的效果。我们来看看它们两者的相同和区别:  </p>
<ul>
<li>相同:都可以创建Service对象，并处理了之间的依赖关系。</li>
<li>区别:set注入创建的Service对象可以给另一个Servlet对象调用，而内部bean将Service对象写在Servlet内部导致该Service对象只能被该Servlet使用，所以内部bean标签的使用场景在只需要一个Servlet对象的项目中。  </li>
</ul>
<h4 id="5-2-3通过p名称空间给对象的属性注入值"><a href="#5-2-3通过p名称空间给对象的属性注入值" class="headerlink" title="5.2.3通过p名称空间给对象的属性注入值"></a>5.2.3通过p名称空间给对象的属性注入值</h4><p>此中方法只有在Spring3.0版本及以上版本才能用。首先在配置文件的<code>&lt;beans&gt;</code>根标签中加入属性:<code>xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</code>。然后我们便可以在配置文件中这样给对象的属性赋值:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-11%20%E4%B8%8B%E5%8D%885.18.05.png" alt="">  </p>
<p>当我们在配置文件中输入<code>p:</code>时，会出现两个属性<code>1.p:userDao 和p:userDao-ref</code>,这里有必要说明一下二者区别:  </p>
<ul>
<li>p:userDao:代表直接给UserService对象的userDao属性赋值</li>
<li>p:userDao-ref:代表引用的userDao对象</li>
</ul>
<p>例如使用p名称空间给传统的对象属性赋值时我们这样写:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span> <span class="attr">p:id</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"pojo.User"</span> <span class="attr">p:name</span>=<span class="string">"xxx"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-2-4-自动装配"><a href="#5-2-4-自动装配" class="headerlink" title="5.2.4.自动装配"></a>5.2.4.自动装配</h4><p>当我们在配置文件中用<code>&lt;bean&gt;</code>标签指明相应对象的同时就将这个对象放入到了IOC容器中(其中标签中的id属性唯一指示一个对象)，当我们给该bean标签添加了<code>autowrite=&quot;byName&quot;</code>的属性后，对于该标签对应的对象注入的属性，会去IOC容器中自动查找与属性同名的对象。  </p>
<p>例如如下代码:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.12.14.png" alt="">  </p>
<p>通过上述三个<code>&lt;bean&gt;</code>标签我们就将userDao、userService、userServlet三个对象添加到了IOC容器中。我们在UserService对象的bean标签中加上了<code>autowrite=&quot;byName&quot;</code>的属性，这样我们查看UserService.java的代码，它有一个UserDao对象名为userDao的属性，此时就会自动去IOC容器中寻找与<code>userDao</code>同名的对象(即在bean标签中寻找id为userDao的对象)，然后进行注入，此时我们若将<code>&lt;bean id=&quot;userDao&quot; class=&quot;pojo.UserDao&quot;&gt;</code>的<code>id=&quot;userDao&quot;</code>属性值改为userDao1或者其它名字，则运行系统会出现空指针异常，道理上述已分析。UserServlet注入userService的属性道理同此。  </p>
<p>我们也可以将该属性定义到全局<code>&lt;beans&gt;</code>标签中，设置<code>default-autowrite=&quot;byName&quot;</code>的属性,这样就不用每个bean标签中都写上<code>autowrite=&quot;byName&quot;</code>属性了。  </p>
<p>上述是根据名称自动装配，其实autowrite的属性值还可以为byType即根据类型自动装配。对于<code>&lt;bean id=&quot;userService&quot; class=&quot;pojo.UserService&quot;&gt;</code>，当添加了<code>autowrity=&quot;byType&quot;</code>的属性后，此时寻找它依赖的属性userDao的过程如下:查看UserService.java代码，它需要注入的属性类型为UserDao类型，所以就会自动去IOC容器中查找UserDao类型的对象并自动为UserService对象注入该属性，此时各bean标签的id属性值便可以随便写了如果根据类型自动装配，则要保证保证该类型的对象只有一个，否则会报错。该属性同样可以在全局beans标签中进行配置。  </p>
<p>利用自动装配的优缺点:简化了配置，但不利用系统维护。所以一般不推荐此中用法，下面我们再来介绍第5中非常简单的配置。  </p>
<h4 id="5-2-5注解"><a href="#5-2-5注解" class="headerlink" title="5.2.5注解"></a>5.2.5注解</h4><p>注解方式可以简化Spring的IOC容器的配置。  </p>
<p>使用步骤:  </p>
<ul>
<li>1.先引入context名称空间</li>
<li>2.开启注解扫描</li>
<li>3.使用注解:通过注解的方式，把对象加入到IOC容器中。</li>
</ul>
<p>首先在IOC配置文件中引入context名称空间,即在<code>&lt;beans&gt;</code>全局标签中添加<code>xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</code>属性。  </p>
<p>然后在配置文件中添加如下标签<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.53.31.png" alt="">   </p>
<p>base-package:表示该扫描器只扫描此包下所有类。 </p>
<p>最后我们便可以使用注解了，在pojo对象的.java文件中分别加入如下注解:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.31.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.43.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%8812.54.52.png" alt="">  </p>
<p>@Componet注解:代表将该对象放入到IOC容器中，括号里面的名字代表该对象在IOC容器中的唯一标识名字，名字任意取。该注解写在代码第一行。  </p>
<p>@Resource注解:用于将该对象依赖的属性从IOC容器中找到并注入，括号里面的name属性值必须跟@Compenent注解里填入的名字相同。  </p>
<p>通过注解方法便可去掉各.java文件中为属性创建设置的set方法。  </p>
<p>继续对上述注解方式进行配置优化，去掉括号中的内容:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.06.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.10.png" alt="">  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-12%20%E4%B8%8B%E5%8D%881.21.15.png" alt=""></p>
<p>在测试类中运行依然可以正常运行。  </p>
<p>说明:利用@Compenent注解的方式是通用的将对象加入到IOC容器中的方式，而有时候我们需要区别各层对象添加的方式，所以这里我们将Dao层对象添加到IOC容器的注解方式改为:@Repository表示持久层的组件;修改Service层对象添加到IOC容器的注解方式:@Service表示业务逻辑层的组件;修改Servlet层对象添加到IOC容器的注解方式为:@Controller表示控制层的组件。  </p>
<p>另外需要说明的是使用注解的方式将对象添加到IOC容器中和在xml文件中添加配置的方式是可以共存的。但通过@Resource不带括号的注解，必须要保证该类型只有一个变量，所以一般情况下我们还是优先使用@Resource(name=””)注解。</p>
<p>到此，Spring框架的学习我们已完成。  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。秋春招时节在群内发布大量的互联网内推方式，话不多说，快上车吧！</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis之查询缓存]]></title>
      <url>http://codingxiaxw.cn/2016/11/10/38-mybatis%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/</url>
      <content type="html"><![CDATA[<p>正如大多数持久层框架一样，MyBatis同样也提供了对查询数据的缓存支持。今后我们要学习的SpringMVC框架属于系统控制层，它也有它的缓存区域，对响应的jsp页面进行缓存；Spring属于系统业务层，它的缓存区域对业务数据进行缓存。而它们三者的缓存区域都存在于用户要访问数据库的中间，当用户向数据库中发送查询请求时，系统会先在它们三者的缓存区域看是否有满足用户要求的查询数据，若有则直接从缓存区域返回信息；若没有则从数据库中进行查询。  </p>
<a id="more"></a>  
<h2 id="1-缓存的意义"><a href="#1-缓存的意义" class="headerlink" title="1.缓存的意义"></a>1.缓存的意义</h2><p>将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上(关系型数据库数据文件)查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。  </p>
<h2 id="2-MyBatis持久层缓存"><a href="#2-MyBatis持久层缓存" class="headerlink" title="2.MyBatis持久层缓存"></a>2.MyBatis持久层缓存</h2><p>MyBatis提供了一级缓存和二级缓存，概念图如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.15.43.png" alt="">  </p>
<p>如图中所示，MyBatis一级缓存是一个SqlSession级别，SqlSession只能访问自己的一级缓存的数据，二级缓存是跨SqlSession，是mapper级别的缓存，对于mapper级别的缓存不同的Sqlsession是可以共享的。</p>
<h2 id="3-MyBatis一级缓存"><a href="#3-MyBatis一级缓存" class="headerlink" title="3.MyBatis一级缓存"></a>3.MyBatis一级缓存</h2><h3 id="3-1原理"><a href="#3-1原理" class="headerlink" title="3.1原理"></a>3.1原理</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.19.30.png" alt="">  </p>
<p>对于图的解释:第一次发出一个查询sql，sql查询结果写入sqlsession的一级缓存中，缓存使用的数据结构是一个<code>map&lt;key,value&gt;</code>。  </p>
<p>key：hashcode+sql+sql输入参数+输出参数（sql的唯一标识）<br>value：用户信息</p>
<p>同一个sqlsession再次发出相同的sql，就从缓存中取,而不走数据库。如果两次中间出现commit操作（修改、添加、删除），本sqlsession中的一级缓存区域全部清空，下次再去缓存中查询不到所以要从数据库查询，从数据库查询到再写入缓存。即对于查询操作，每次查询都先从缓存中查询，如果缓存中查询到数据则将缓存数据直接返回，如果缓存中查询不到就从数据库查询。  </p>
<h3 id="3-2一级缓存配置"><a href="#3-2一级缓存配置" class="headerlink" title="3.2一级缓存配置"></a>3.2一级缓存配置</h3><p>mybatis默认支持一级缓存不需要配置。  </p>
<p><strong>注意:</strong>mybatis和spring整合后进行mapper代理开发，不支持一级缓存，mybatis和spring整合，spring按照mapper的模板去生成mapper代理对象，模板中在最后统一关闭sqlsession。  </p>
<h3 id="3-3一级缓存的测试"><a href="#3-3一级缓存的测试" class="headerlink" title="3.3一级缓存的测试"></a>3.3一级缓存的测试</h3><p>测试代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.25.22.png" alt="">  </p>
<p>运行，在控制台看到输出:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.26.38.png" alt="">  </p>
<p>发现打印两次结果只有第一次向数据库中发送了查询请求，第二次是直接从缓存中返回的数据。接下来我们在中间加入更新数据的操作:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.29.29.png" alt="">  </p>
<p>然后在控制台中看到打印过程:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.30.31.png" alt="">   </p>
<p>可以发现向数据库发送了三次请求。  </p>
<h2 id="4-MyBatis二级缓存"><a href="#4-MyBatis二级缓存" class="headerlink" title="4.MyBatis二级缓存"></a>4.MyBatis二级缓存</h2><h3 id="4-1二级缓存原理"><a href="#4-1二级缓存原理" class="headerlink" title="4.1二级缓存原理"></a>4.1二级缓存原理</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.31.30.png" alt="">  </p>
<p>二级缓存的范围是mapper级别（mapper同一个命名空间），mapper以命名空间为单位创建缓存数据结构，结构是<code>map&lt;key、value&gt;</code>。  </p>
<p>过程:每次查询先看是否开启二级缓存，如果开启从二级缓存的数据结构中取缓存数据，如果从二级缓存没有取到，再从一级缓存中找，如果一级缓存也没有，从数据库查询。  </p>
<h3 id="4-2二级缓存的配置"><a href="#4-2二级缓存的配置" class="headerlink" title="4.2二级缓存的配置"></a>4.2二级缓存的配置</h3><p>不像一级缓存那样mybatis自动开启一级缓存，mybatis是默认关闭二级缓存的，所以我们需要需要进行两个操作才能开启二级缓存:  </p>
<p>1.在核心配置文件SqlMapperConfig.xml中加入<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.34.12.png" alt="">  </p>
<p>属性值cacheEnabled表示对在此配置文件下的所有cache 进行全局性开/关设置，它的可选值为true｜false,默认值为true.   </p>
<p>2.在你的Mapper映射文件中添加一行:<code>&lt;cache /&gt;</code> ，表示此mapper开启二级缓存。 </p>
<h3 id="4-3查询结果映射的pojo序列化"><a href="#4-3查询结果映射的pojo序列化" class="headerlink" title="4.3查询结果映射的pojo序列化"></a>4.3查询结果映射的pojo序列化</h3><p>mybatis二级缓存需要将查询结果映射的pojo实现 java.io.serializable接口，如果不实现则抛出异常：<br><code>org.apache.ibatis.cache.CacheException: Error serializing object.  Cause: java.io.NotSerializableException: cn.itcast.mybatis.po.User</code>  </p>
<p>二级缓存可以将内存的数据写到磁盘，存在对象的序列化和反序列化，所以要实现java.io.serializable接口。  </p>
<p>如果结果映射的pojo中还包括了pojo，都要实现java.io.serializable接口。  </p>
<h3 id="4-4二级缓存的禁用"><a href="#4-4二级缓存的禁用" class="headerlink" title="4.4二级缓存的禁用"></a>4.4二级缓存的禁用</h3><p>对于变化频率较高的sql，需要禁用二级缓存：在statement中设置<code>useCache=false</code>可以禁用当前select语句的二级缓存，即每次查询都会发出sql去查询，默认情况是true，即该sql使用二级缓存。<br><code>&lt;select id=&quot;findOrderListResultMap&quot; resultMap=&quot;ordersUserMap&quot; useCache=&quot;false&quot;&gt;</code>  </p>
<h3 id="4-5刷新缓存"><a href="#4-5刷新缓存" class="headerlink" title="4.5刷新缓存"></a>4.5刷新缓存</h3><p>将二级缓存进行刷新操作有两种方式:  </p>
<ul>
<li>如果sqlsession操作commit操作，对二级缓存进行刷新（全局清空）。</li>
<li>设置statement的flushCache是否刷新缓存，默认值是true。</li>
</ul>
<h3 id="4-6测试代码"><a href="#4-6测试代码" class="headerlink" title="4.6测试代码"></a>4.6测试代码</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.41.06.png" alt="">  </p>
<p>分别将中间更新用户信息的代码注释:发现两次打印用户信息的操作只向数据库中发送一次查询请求;去掉注释:三次操作向数据库中发送三次请求。  </p>
<h3 id="4-7mybatis的cache参数（了解）"><a href="#4-7mybatis的cache参数（了解）" class="headerlink" title="4.7mybatis的cache参数（了解）"></a>4.7mybatis的cache参数（了解）</h3><p>mybatis的cache参数只适用于mybatis维护缓存。</p>
<ul>
<li>flushInterval（刷新间隔）:可以被设置为任意的正整数，而且它们代表一个合理的毫秒形式的时间段。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句时刷新。</li>
<li>size（引用数目）:可以被设置为任意正整数，要记住你缓存的对象数目和你运行环境的可用内存资源数目。默认值是1024。</li>
<li>readOnly（只读）:属性可以被设置为true或false。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这提供了很重要的性能优势。可读写的缓存会返回缓存对象的拷贝（通过序列化）。这会慢一些，但是安全，因此默认是false。</li>
</ul>
<p>如下例子:  </p>
<p><code>&lt;cache  eviction=&quot;FIFO&quot;  flushInterval=&quot;60000&quot;  size=&quot;512&quot;  readOnly=&quot;true&quot;/&gt;</code></p>
<p>这个更高级的配置创建了一个 FIFO 缓存,并每隔 60 秒刷新,存数结果对象或列表的 512 个引用,而且返回的对象被认为是只读的,因此在不同线程中的调用者之间修改它们会导致冲突。可用的收回策略有, 默认的是 LRU:</p>
<ul>
<li>LRU – 最近最少使用的:移除最长时间不被使用的对象。</li>
<li>FIFO – 先进先出:按对象进入缓存的顺序来移除它们。</li>
<li>SOFT – 软引用:移除基于垃圾回收器状态和软引用规则的对象。</li>
<li>WEAK – 弱引用:更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li>
</ul>
<h3 id="4-8二级缓存的应用场景"><a href="#4-8二级缓存的应用场景" class="headerlink" title="4.8二级缓存的应用场景"></a>4.8二级缓存的应用场景</h3><p>对查询频率高，变化频率低的数据建议使用二级缓存。  </p>
<p>对于访问多的查询请求且用户对查询结果实时性要求不高，此时可采用mybatis二级缓存技术降低数据库访问量，提高访问速度，业务场景比如：耗时较高的统计分析sql、电话账单查询sql等。  </p>
<p>实现方法如下：通过设置刷新间隔时间，由mybatis每隔一段时间自动清空缓存，根据数据变化频率设置缓存刷新间隔flushInterval，比如设置为30分钟、60分钟、24小时等，根据需求而定。  </p>
<h3 id="4-9二级缓存的局限性"><a href="#4-9二级缓存的局限性" class="headerlink" title="4.9二级缓存的局限性"></a>4.9二级缓存的局限性</h3><p>mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求：对商品信息进行缓存，由于商品信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类问题需要在业务层根据需求对数据有针对性缓存。  </p>
<h2 id="5-MyBatis和ehcache缓存框架整合"><a href="#5-MyBatis和ehcache缓存框架整合" class="headerlink" title="5.MyBatis和ehcache缓存框架整合"></a>5.MyBatis和ehcache缓存框架整合</h2><h3 id="5-1分布缓存"><a href="#5-1分布缓存" class="headerlink" title="5.1分布缓存"></a>5.1分布缓存</h3><p>将缓存数据进行分布式管理，这个概念我们以后会学。  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.45.41.png" alt="">  </p>
<h3 id="5-3MyBatis和ehcache整合思路"><a href="#5-3MyBatis和ehcache整合思路" class="headerlink" title="5.3MyBatis和ehcache整合思路"></a>5.3MyBatis和ehcache整合思路</h3><p>通过MyBatis和ehcache框架进行整合，就可以把缓存数据的管理托管给ehcache。  </p>
<p>首先我们看看MyBatis自己的二级缓存，它在自己内部提供了一个cache接口，我们只要实现了cache接口就可以把缓存数据灵活的管理起来。  </p>
<p>要将MyBatis和ehcache整合，我们首先需要下载ehcache的jar包:  </p>
<ul>
<li>ehcache-core.jar</li>
<li>mybatis-ehcache.jar</li>
</ul>
<p>然后需要添加一个ehcache的配置文件ehcache.xml:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8A%E5%8D%8811.59.32.png" alt="">  </p>
<p>然后在mapper.xml中添加ehcache的配置:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-10%20%E4%B8%8B%E5%8D%8812.00.18.png" alt="">  </p>
<p>然后便可以进行测试。  </p>
<p>学完以上7篇文章，你就可以使用MyBatis去搭建一个项目了。后面的博客中，我还会写几篇MyBatis与Spring和Spring MVC整合的文章供大家学习。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis之使用resultMap实现高级映射]]></title>
      <url>http://codingxiaxw.cn/2016/11/09/37-mybatis%E5%AE%9E%E7%8E%B0%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84/</url>
      <content type="html"><![CDATA[<p>对于数据库中对表的增删改查操作，我们知道增删改都涉及的是单表，而只有查询操作既可以设计到单表操作又可以涉及到多表操作，所以对于输入映射parameterType而言是没有所谓的高级映射的，也就是说高级映射只针对于输出映射(因为高级映射设计到多张表)。<br><a id="more"></a></p>
<p>前五篇文章我们都只实现了单表中的字段与pojo的映射，而本篇文章我们将来讲解如何实现多表与pojo之间的高级映射,分别有一对一映射、一对多映射和多对多映射。首先我们来看看如何使用resultType完成一对一映射。  </p>
<h2 id="1-多表间的一对一查询"><a href="#1-多表间的一对一查询" class="headerlink" title="1.多表间的一对一查询"></a>1.多表间的一对一查询</h2><h3 id="1-1需求"><a href="#1-1需求" class="headerlink" title="1.1需求"></a>1.1需求</h3><p>查询订单信息关联查询用户信息。这里我们知道一个用户可以有多张订单，而一张订单只能属于一个用户，所以用户与订单间的关系是一对多而订单与用户间的关系是一对一。所以这里我们将订单表作为主查询表来关联用户表，从而实现一对一映射。  </p>
<h3 id="1-2创建表和数据"><a href="#1-2创建表和数据" class="headerlink" title="1.2创建表和数据"></a>1.2创建表和数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">orders</span><span class="params">( id <span class="keyword">int</span> primary key auto_increment, </span><br><span class="line">	user_id <span class="keyword">int</span> ,</span><br><span class="line">	 number <span class="keyword">int</span>, </span><br><span class="line">	 createtime datetime, note varchar(<span class="number">50</span>)</span>)</span>;</span><br><span class="line"></span><br><span class="line">用户表在第一篇文章中我们已经创建。</span><br></pre></td></tr></table></figure>
<p>建立oders表和user表对应的pojo对象Orders.java和User.java。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orders</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Integer userId;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String number;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> Date createtime;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> String note;</span><br><span class="line">    	</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p> 并建立相关的get和set方法，User.java我们之前已建立。</p>
<h3 id="1-3sql查询语句"><a href="#1-3sql查询语句" class="headerlink" title="1.3sql查询语句"></a>1.3sql查询语句</h3><p>对于查询语句，我们需要知道:1.先确定主查询表:订单表。2.再确定关联查询表:用户信息表。通过orders关联查询用户使用user_id一个外键，只能关联查询出一条用户记录，我们使用内连接。查询语句为:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT orders.*,user.username,user.sex </span><br><span class="line">FROM orders,user </span><br><span class="line">WHERE orders.user_id = user.id</span><br></pre></td></tr></table></figure>
<h3 id="1-4使用resultType实现"><a href="#1-4使用resultType实现" class="headerlink" title="1.4使用resultType实现"></a>1.4使用resultType实现</h3><p>通过查询语句，查询到的结果同时包括user表和orders表两张表的列，那么我们将结果映射到哪个pojo对象中呢？若映射到User.java，那查询结果中对应的orders表的字段一定会遗失；若映射到Orders.java，那查询结果中对应的user表的字段同样也会遗失。所以这里需要我们针对查询的结果重新创建一个映射的pojo对象OrderCustom.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%883.44.21.png" alt="">  </p>
<p>这里我们让OrderCustom.java继承自Order.java，这样我们就只需在OrderCustom.java中添加user表中的字段即可。因为MyBatis主要的重点在sql语句，所以我们完成配置和pojo对象的建立后主要的点就放在了sql语句上，所以接下来要定义写sql语句的mapper.xml和对数据库进行操作的mapper.java接口了.  </p>
<p>OrdersMapperCustom.xml文件内容如下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%884.01.21.png" alt=""><br>因为我们只关心输出映射，所以在xml中写sql查询语句时没有写parameterType属性，而resultType的属性值我之所以没有写全OrderCustom类的全限定性名，是因为我们在SqlMapperConfig.xml中进行了别名的配置。相应的OrdersMapperCustom.java接口内容如下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%884.01.37.png" alt="">  </p>
<p>然后在测试类中测试:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%884.01.48.png" alt="">便可完成这两张表的关联与我们自定义的pojo对象的映射。接下来我们看看如何使用resultMap完成。  </p>
<h3 id="1-5使用resultMap实现一对一映射"><a href="#1-5使用resultMap实现一对一映射" class="headerlink" title="1.5使用resultMap实现一对一映射"></a>1.5使用resultMap实现一对一映射</h3><p>思路:将关联查询的信息映射到pojo中，如下:只需在Orders类中创建一个User属性，将关联查询的信息映射到User属性中。<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%884.09.21.png" alt=""><br>这样我们便可以将查询的结果映射到Orders.java类中，而不用自己再自定义一个pojo了。  </p>
<p>修改OrdersMapperCustom.xml中的内容(添加并使用resultMap标签),:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%884.52.56.png" alt="">  </p>
<p>然后在OrdersMapperCutom.java中添加方法:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%884.53.04.png" alt="">  </p>
<p>最后测试:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%884.53.13.png" alt="">发现查询结果已全部映射到Orders.java类中。  </p>
<h3 id="1-6比较resultType和resultMap完成一对一映射"><a href="#1-6比较resultType和resultMap完成一对一映射" class="headerlink" title="1.6比较resultType和resultMap完成一对一映射"></a>1.6比较resultType和resultMap完成一对一映射</h3><ul>
<li>resultType：要自定义pojo 保证sql查询列和pojo的属性对应，这种方法相对较简单，所以应用广泛。</li>
<li>resultMap：使用association完成一对一映射需要配置一个resultMap标签，过程有点复杂，如果要实现延迟加载(后面会讲)就只能用resultMap实现 ，如果为了方便对关联信息进行解析，也可以用association将关联信息映射到pojo中方便解析。</li>
</ul>
<h2 id="2-多表间的一对多查询"><a href="#2-多表间的一对多查询" class="headerlink" title="2.多表间的一对多查询"></a>2.多表间的一对多查询</h2><h3 id="2-1需求"><a href="#2-1需求" class="headerlink" title="2.1需求"></a>2.1需求</h3><p>查询所有订单信息及订单下的订单明细信息。分析:一个订单可以可以有多个订单明细，而一个订单明细只属于一个订单，所以订单与订单明细间的关系为一对多。</p>
<h3 id="2-2创建表和数据"><a href="#2-2创建表和数据" class="headerlink" title="2.2创建表和数据"></a>2.2创建表和数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">create table <span class="title">orderdetail</span><span class="params">( id <span class="keyword">int</span> primary key auto_increment, orders_id <span class="keyword">int</span>, items_id <span class="keyword">int</span>, items_num <span class="keyword">int</span>)</span></span>;<span class="comment">//创建订单明细表</span></span><br><span class="line"></span><br><span class="line">订单表我们已经创建</span><br></pre></td></tr></table></figure>
<p>创建和订单明细表对应的pojo对象:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Orderdetail</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">private</span> Integer ordersId;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">private</span> Integer itemsId;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">private</span> Integer itemsNum;</span><br><span class="line">   	</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>并创建相关的set和get方法。</p>
<h3 id="2-3sql查询语句"><a href="#2-3sql查询语句" class="headerlink" title="2.3sql查询语句"></a>2.3sql查询语句</h3><p>1.先确定主查询表:订单表。2.再确定关联查询表:用户表加订单明细表。通过orderdetail关联查询订单使用orders_id一个外键，只能关联查询出一条订单记录，我们使用内连接。查询语句为:  </p>
<pre><code class="java">SELECT orders.*,user.username,user.sex ,orderdetail.id orderdetail_id,orderdetail.items_num,orderdetail.items_id

FROM orders,user,orderdetail 
WHERE orders.user_id = user.id AND orders.id=orderdetail.orders_id
</code></pre>
<h3 id="2-4使用resultMap进行一对多映射"><a href="#2-4使用resultMap进行一对多映射" class="headerlink" title="2.4使用resultMap进行一对多映射"></a>2.4使用resultMap进行一对多映射</h3><p>思路:resultMap 提供collection完成关联信息映射到集合对象中。在orders类中创建集合属性：<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.14.55.png" alt="">  </p>
<p>然后修改OrdersMapperCustom.xml中的信息:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.32.43.png" alt=""><br>并在其中添加resultMap的定义:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.32.50.png" alt="">  </p>
<p>然后在OrdersMapperCutom.java中添加方法:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.33.21.png" alt="">  </p>
<p>最后进行测试:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%885.33.31.png" alt="">  </p>
<p>发现查询的结果已全部映射到pojo对象Orders.java的属性中。  </p>
<h2 id="3-多对多查询-以后我会实现的"><a href="#3-多对多查询-以后我会实现的" class="headerlink" title="3.多对多查询(以后我会实现的)"></a>3.多对多查询(以后我会实现的)</h2><p>首先我们应该明确的是:一对多是多对多的特例。  </p>
<p><strong>需求1:查询显示字段：用户账号、用户名称、用户性别、商品名称、商品价格(最常见)</strong><br>企业开发中常见明细列表，用户购买商品明细列表，<br>使用resultType将上边查询列映射到pojo输出。</p>
<p><strong>需求2：查询显示字段：用户账号、用户名称、购买商品数量、商品明细（鼠标移上显示明细）</strong><br>使用resultMap将用户购买的商品明细列表映射到user对象中。</p>
<p>讲完如何使用resultMap完成多表间的查询结果与pojo对象的高级映射，这里我们还需要补充一个<strong>使用resultMap实现延迟加载</strong>的知识点。  </p>
<h2 id="4-延迟加载"><a href="#4-延迟加载" class="headerlink" title="4.延迟加载"></a>4.延迟加载</h2><h3 id="4-1使用延迟加载的意义"><a href="#4-1使用延迟加载的意义" class="headerlink" title="4.1使用延迟加载的意义"></a>4.1使用延迟加载的意义</h3><p>在进行数据查询时，为了提高数据库查询性能，尽量使用单表查询，因为单表查询比多表关联查询速度要快。  </p>
<p>如果查询单表就可以满足需求，一开始先查询单表，当需要关联信息时，再关联查询，当需要关联信息再查询这个叫延迟加载。  </p>
<p>mybatis中resultMap提供延迟加载功能，通过resultMap配置延迟加载,但需要在MyBatis的配置文件中进行相关配置，如下:  </p>
<h3 id="4-2配置mybatis支持延迟加载"><a href="#4-2配置mybatis支持延迟加载" class="headerlink" title="4.2配置mybatis支持延迟加载"></a>4.2配置mybatis支持延迟加载</h3><table>
<thead>
<tr>
<th>设置项</th>
<th style="text-align:center">描述</th>
<th>允许值</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>lazyLoadingEnabled</td>
<td style="text-align:center">全局性设置懒加载。如果设为‘false’，则所有相关联的都会被初始化加载。</td>
<td>true｜false</td>
<td>false</td>
</tr>
<tr>
<td>aggressiveLazyLoading</td>
<td style="text-align:center">当设置为‘true’的时候，懒加载的对象可能被任何懒属性全部加载。否则，每个属性都按需加载。</td>
<td>true ｜  false</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>然后在SqlMapperConfig.xml中添加如下配置信息:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.39.21.png" alt="">  </p>
<h3 id="4-3一对一延迟加载的实现"><a href="#4-3一对一延迟加载的实现" class="headerlink" title="4.3一对一延迟加载的实现"></a>4.3一对一延迟加载的实现</h3><h4 id="4-3-1实现思路"><a href="#4-3-1实现思路" class="headerlink" title="4.3.1实现思路"></a>4.3.1实现思路</h4><p>需求:查询订单及用户的信息，一对一查询。  </p>
<p>刚开始我们只查询订单信息。而当需要用户信息时调用Orders类中的getUser()方法执行延迟加载 ，向数据库发出sql。代码实现如下:  </p>
<p>在OrderMapperCustom.xml文件中添加如下信息:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.41.51.png" alt="">  </p>
<p>并定义resultMap标签:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.42.51.png" alt="">  </p>
<p>然后在OrderMapperCustom.java接口中添加如下方法:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.43.46.png" alt=""></p>
<p>最后是测试代码:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-09%20%E4%B8%8B%E5%8D%887.44.14.png" alt=""></p>
<h3 id="4-4一对多延迟加载的实现"><a href="#4-4一对多延迟加载的实现" class="headerlink" title="4.4一对多延迟加载的实现"></a>4.4一对多延迟加载的实现</h3><p>一对多延迟加载的方法同一对一延迟加载，在collection标签中配置select内容。  </p>
<h2 id="5-resultType、resultMap、延迟加载使用场景总结"><a href="#5-resultType、resultMap、延迟加载使用场景总结" class="headerlink" title="5.resultType、resultMap、延迟加载使用场景总结"></a>5.resultType、resultMap、延迟加载使用场景总结</h2><p><strong>延迟加载:</strong><br>延迟加载实现的方法多种多样，在只查询单表就可以满足需求，为了提高数据库查询性能使用延迟加载，再查询关联信息。</p>
<p>mybatis提供延迟加载的功能用于service层。</p>
<p><strong>resultType:</strong>作用：将查询结果按照sql列名pojo属性名一致性映射到pojo中。  </p>
<p>场合：常见一些明细记录的展示，将关联查询信息全部展示在页面时，此时可直接使用resultType将每一条记录映射到pojo中，在前端页面遍历list（list中是pojo）即可。</p>
<p><strong>resultMap:</strong>使用association和collection完成一对一和一对多高级映射。  </p>
<p><strong>association:</strong>作用:将关联查询信息映射到一个pojo类中。  </p>
<p>场合:为了方便获取关联信息可以使用association将关联订单映射为pojo，比如:查询订单及关联用户信息。</p>
<p><strong>collection:</strong>作用:将关联查询信息映射到一个list集合中。  </p>
<p>场合:为了方便获取关联信息可以使用collection将关联信息映射到list集合中，比如:查询用户权限范围模块和功能，可使用collection将模块和功能列表映射到list中。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis之动态sql]]></title>
      <url>http://codingxiaxw.cn/2016/11/09/36-mybatis%E5%8A%A8%E6%80%81sql/</url>
      <content type="html"><![CDATA[<p>我们需要知道的是，使用mybatis重点是对sql的灵活解析和处理。在原先的UserMappser.xml中，我们这样查询表中满足条件的记录 :</p>
<a id="more"></a> 
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserList"</span> <span class="attr">parameterType</span>=<span class="string">"userQueryVo"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">  	 	select id,username,birthday from user where username like '$&#123;value&#125;'</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上述语句在表中查询满足<code>username</code>条件的记录，这样写查询语句有一个弊端，就是该语句只能通过username查询数据库。当我们在多条件中查询时，如果不需要username条件而是需要其它多个查询条件时，那UserMapper.xml文件中的这个查询条件就没用了。  </p>
<p>需求:将自定义查询条件查询用户列表和查询用户列表总记录数改为动态sql。需要使用if标签和where标签。  </p>
<h2 id="1-if和where"><a href="#1-if和where" class="headerlink" title="1.if和where"></a>1.if和where</h2><p>使用if标签和where标签在UserMapper.xml中添加如下内容:<br>修改自定义查询条件查询用户列表代码:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%888.14.15.png" alt=""></p>
<p>修改自定义查询条件查询用户列表总记录数代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%888.19.54.png" alt="">  </p>
<p>发现<code>&lt;where&gt;</code>和<code>&lt;if&gt;</code>在上述两个查询语句中重复的代码出现了两次，那这里我们是否可以把相同的sql片段拿出来单独写在一个sql片段中然后再在不同的查询语句中应用呢？答案是肯定的,看下面的sql片段。  </p>
<h2 id="2-sql片段"><a href="#2-sql片段" class="headerlink" title="2.sql片段"></a>2.sql片段</h2><p>通过sql片段可以将通用的sql语句抽取出来，单独定义，在其它的statement中可以引用sql片段。其中通用的sql语句，一般用在:where条件、查询列。  </p>
<h2 id="2-1定义sql片段"><a href="#2-1定义sql片段" class="headerlink" title="2.1定义sql片段"></a>2.1定义sql片段</h2><p>在UserMapper.xml中添加<code>&lt;sql&gt;</code>标签代表sql片段:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.25.19.png" alt="">这样就完成了sql片段的定义，然后才能使用sql片段。</p>
<h2 id="2-2使用sql片段"><a href="#2-2使用sql片段" class="headerlink" title="2.2使用sql片段"></a>2.2使用sql片段</h2><p>使用<code>&lt;include&gt;</code>标签对上面定义的sql片段加以引用:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.27.20.png" alt=""><br>和<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.27.28.png" alt="">  </p>
<p>测试类代码不变，这样我们便完成了对sql片段的引用。  </p>
<p>有时候我们希望查询语句是这样<code>select id,username,birthday from user where username like &#39;%codingXiaxw%&#39; and id in (1,2)</code>，那我们又应该在sql片段中如何添加代码呢？这时候需要用到<code>&lt;foreach&gt;</code>标签。</p>
<h2 id="3-foreach标签"><a href="#3-foreach标签" class="headerlink" title="3.foreach标签"></a>3.foreach标签</h2><p>在statement通过foreach遍历parameterType中的集合类型。首先我们需要在UserQueryVo中定义List<integer>ids属性:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.36.44.png" alt=""><br>并添加相应的get和set方法。  </integer></p>
<p>然后我们在UserMapper.xml中使用foreach修改where语句,使用foreache遍历list:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.38.18.png" alt=""><br>各属性说明见代码注释，然后是测试代码:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%889.39.11.png" alt="">  </p>
<p>通过这5篇文章，我们便完成了MyBatis学习的基础知识。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis之输入(parameterType)与输出(resultType、resultMap)映射]]></title>
      <url>http://codingxiaxw.cn/2016/11/08/35-mybatis%E8%BE%93%E5%85%A5%E4%B8%8E%E8%BE%93%E5%87%BA%E6%98%A0%E5%B0%84/</url>
      <content type="html"><![CDATA[<p>在MyBatis中，我们通过parameterType完成输入映射(指将值映射到sql语句的占位符中，值的类型与dao层响应方法的参数类型一致)，通过resultType完成输出映射(从数据库中输出，通过dao层的方法查询到的数据输出到pojo对象中)。<a id="more"></a> 注意输入与输出都是相对于数据库的。接下来我们先谈谈输入映射。工程目录结构如下:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/mulu22.png" width="50%" height="50%">  </p>
<h2 id="1-输入映射parameterType"><a href="#1-输入映射parameterType" class="headerlink" title="1.输入映射parameterType"></a>1.输入映射parameterType</h2><p>通过parameterType传入简单类型或对象，我们之前讲过了，接下来我们要讲的是parameterType传递pojo包装对象。可以定义pojo包装类型扩展mapper接口输入参数的内容。  </p>
<p>看下我们的需求:定义查询条件查询用户信息，需要向statement输入查询条件，查询条件可以有user信息、商品信息等等。  </p>
<p>首先我们在domain包下创建UserCustom类并继承User,<img src="http://od2xrf8gr.bkt.clouddn.com/ssss.png" alt="">  UserCustom类用于对User属性进行扩展(例如User中只有用户信息，而我们可以在UserCustom中加入商品信息)，然后再创建User的包装类UserQueryVo.java:<img src="http://od2xrf8gr.bkt.clouddn.com/ssssss.png" alt="">  </p>
<p>UserMapper.xml中添加如下配置信息:<img src="http://od2xrf8gr.bkt.clouddn.com/sjjj.png" alt="">  </p>
<p>UserMapper.java中添加方法:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.41.10.png" alt="">  </p>
<p>然后便可以进行测试:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.41.34.png" alt=""></p>
<p>可能出现的异常:如果在parameterType中指定了错误的属性名时会出现如下异常:  </p>
<pre><code>org.apache.ibatis.exceptions.PersistenceException: ### Error querying database.  Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;userCusto&apos; in &apos;class cn.itcast.mybatis.po.UserQueryVo&apos;### Cause: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named &apos;userCusto&apos; in &apos;class cn.itcast.mybatis.po.UserQueryVo&apos;
</code></pre><h2 id="2-输出映射"><a href="#2-输出映射" class="headerlink" title="2.输出映射"></a>2.输出映射</h2><p>输出映射有resultType和resultMap,他们都是指定输出结果的类型(pojo、简单类型、hashmap…)，并将sql查询结果映射为java对象 。</p>
<h3 id="2-1resultType"><a href="#2-1resultType" class="headerlink" title="2.1resultType"></a>2.1resultType</h3><p>借用上述parameter传递包装pojo对象的知识(不用parameter传递包装pojo对象的知识也行)，我们来谈谈用resultType输出简单类型。UserMapper.xml文件中添加如下配置:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.51.42.png" alt="">  </p>
<p>然后在UserMapper.java中添加如下方法:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.52.30.png" alt="">  </p>
<p>测试:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.53.12.png" alt="">  </p>
<p>这里因为查询的记录结果集为一条记录且该记录只有1列，所以我们使用的是返回简单类型。</p>
<p>使用resultType时我们应该注意:sql查询的列名要和resultType指定pojo的属性名相同，指定相同属性方可映射成功，如果sql查询的列名要和resultType指定pojo的属性名全部不相同(或是部分不相同)，则映射到pojo对象中的对应属性为null。例如有时候我们不需要查询<code>select * from user where id = ?</code>而是<code>select username,address _address where id = ?</code> 此时我们给查询的address列名给了一个别名_address，这样我们通过查询表中address的数据然后在将它映射到User对象时，该对象的address属性就为null，即没将从表中查询到的address数据映射到user对象的address属性中。  </p>
<p>此时resultMap就出现了。如果sql查询列名和最终要映射的pojo的属性名不一致，使用resultMap就可以将列名和pojo的属性名做一个对应关系 （列名和属性名映射配置）。</p>
<h3 id="2-2resultMap"><a href="#2-2resultMap" class="headerlink" title="2.2resultMap"></a>2.2resultMap</h3><p>使用resultMap需要在UserMapper.xml中进行配置:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.06.02.png" alt="">  </p>
<p>然后在UserMapper.xml中使用它:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.06.23.png" alt="">    </p>
<p>UserMapper.java文件中:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.08.19.png" alt="">  </p>
<p>测试类代码:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%887.08.51.png" alt="">  </p>
<p>运行测试类发现，即使我们查询的列名与User对象的属性不一样，但是我们的确映射成功了。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis之优化MyBatis配置文件中的配置]]></title>
      <url>http://codingxiaxw.cn/2016/11/08/34-mybatis%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<p>MyBatis配置文件很重要，首先我们来看看MyBatis配置文件中的内容和顺序:<br><a id="more"></a><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span>(属性)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span>&gt;</span>(全局配置参数)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span>(类型别名)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span>(类型处理器)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span>&gt;</span>(对象工厂)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span>(插件)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span>&gt;</span>(环境集合属性对象)</span><br><span class="line">	<span class="tag">&lt;<span class="name">environment</span>&gt;</span>(环境子属性对象)</span><br><span class="line">		<span class="tag">&lt;<span class="name">transactionManager</span>&gt;</span>(事务管理)</span><br><span class="line">		dataSource&gt;(数据源)</span><br><span class="line">		</span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>(映射器)</span><br></pre></td></tr></table></figure></p>
<p>文件目录结构如下:<img src="http://od2xrf8gr.bkt.clouddn.com/mulu22.png" alt=""></p>
<h2 id="1-lt-properties-gt-属性定义"><a href="#1-lt-properties-gt-属性定义" class="headerlink" title="1.&lt;properties&gt;属性定义"></a>1.<code>&lt;properties&gt;</code>属性定义</h2><p>可以把一些通用的属性值配置在属性文件中，加载到mybatis运行环境内。例如创建db.properties文件，然后在SqlMapperConfig.xml中进行配置。db.properties文件内容如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/db.pro.png" alt=""></p>
<p>然后在SqlMapperConfig.xml中进行配置:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%885.59.18.png" alt="">  </p>
<p>然后在<code>&lt;environments&gt;</code>标签中用<code>${}</code>符号做如下修改:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/nima.png" alt="">  </p>
<p><strong>注意:Mybatis将按照下面的顺序来加载属性</strong>  </p>
<ul>
<li>1.在properties标签之间定义的属性首先被读取。</li>
<li>2.然后会读取properties标签内部resource或url的属性，它会覆盖已读取的同名属性。</li>
<li>3.最后读取parameterType(即insert标签或是update标签或是…)传递的属性，它会覆盖已读取的同名属性。</li>
</ul>
<p>所以我们建议使用properties标签时，不要在properties标签之间定义属性，只引用在.properties文件中定义的属性，并且.properties文件中定义的key值要有一些特殊的规则。例如我上述定义key值时前面都加了jdbc.的前缀。</p>
<h2 id="2-lt-settings-gt-全局参数配置"><a href="#2-lt-settings-gt-全局参数配置" class="headerlink" title="2.&lt;settings&gt;全局参数配置"></a>2.<code>&lt;settings&gt;</code>全局参数配置</h2><p>mybatis运行时可以调整一些全局参数(相当于软件的运行参数)。根据使用需求进行参数配置。但是要注意:小心配置，配置参数会影响mybatis的执行。  </p>
<p>ibatis的全局配置参数中包括很多的性能参数(最大线程数、最大等待时间…)，通过调整这些性能参数使ibatis达到高性能的运行，而mybatis没有这些性能参数，由mybatis自动调节。</p>
<h2 id="3-lt-typeAliases-gt-属性"><a href="#3-lt-typeAliases-gt-属性" class="headerlink" title="3.&lt;typeAliases&gt;属性"></a>3.<code>&lt;typeAliases&gt;</code>属性</h2><p>可以将parameterType、resultType中指定的类型通过别名引用。MyBatis提供了很多的别名如下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%88%AB%E5%90%8D.png" alt="">  </p>
<p>这里我们采用自定义的别名，在SqlMapperConfig.xml中进行如下配置:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/hahaha.png" alt="">  </p>
<p>里面包括定义单个别名和批量别名定义(即一次性定义一个包下所有.java文件的别名)。  </p>
<p>定义别名后这样我们在parameterType和resultType中使用时就不用再繁琐的指定类的全限定类名了，像下面这样使用即可<img src="http://od2xrf8gr.bkt.clouddn.com/dadada.png" alt=""></p>
<h2 id="4-lt-typeHandlers-gt-属性"><a href="#4-lt-typeHandlers-gt-属性" class="headerlink" title="4.&lt;typeHandlers&gt;属性"></a>4.<code>&lt;typeHandlers&gt;</code>属性</h2><p>类型处理器将java类型和jdbc类型进行映射，mybatis提供了很多类型处理器，一般情况下够用了。</p>
<h2 id="5-lt-mapper-gt-映射器属性"><a href="#5-lt-mapper-gt-映射器属性" class="headerlink" title="5.&lt;mapper&gt;映射器属性"></a>5.<code>&lt;mapper&gt;</code>映射器属性</h2><p>之前我们在配置文件中使用的<code>&lt;mapper&gt;</code>标签内容为:<code>&lt;mapper resource=“mapper/UserMapper.xml”/&gt;</code>，接下来我要讲的是另一种在配置文件中映射mapper动态代理的方法。在配置文件中这样配置<code>&lt;mapper class=“mapper.UserMapper”/&gt;</code>，这样的要求需要保证UserMapper.xml文件和UserMapper.java在同一个包下且.xml文件和.java文件名要同名。  </p>
<p>同上方别名的配置，当包下出现多个Mapper.java和Mapper.xml时我们采用批量配置:<code>&lt;package name=“mapper”/&gt;</code>，代码如下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-08%20%E4%B8%8B%E5%8D%886.12.42.png" alt="">  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis之Mapper动态代理开发]]></title>
      <url>http://codingxiaxw.cn/2016/11/07/33-MyBatis%E4%BD%BF%E7%94%A8mapper%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%BC%80%E5%8F%91/</url>
      <content type="html"><![CDATA[<h2 id="1-SqlSession的使用范围"><a href="#1-SqlSession的使用范围" class="headerlink" title="1.SqlSession的使用范围"></a>1.SqlSession的使用范围</h2><p><strong>1.SqlSessionFactoryBuilder</strong><br>SqlSessionFactoryBuilder是以工具类的方式来使用:需要创建sqlSessionFactory时就new一个 SqlSessionFactoryBuilder  </p>
<a id="more"></a>
<p><strong>2.sqlSessionFactory</strong><br>正常开发时，以单例方式管理sqlSessionFactory，整个系统运行过程中sqlSessionFactory只有一个实例，将来和Spring整合后由Spring以单例方式管理sqlSessionFactory  </p>
<p><strong>3.SqlSession</strong><br>SqlSession是一个面向用户(程序员)的接口，程序员调用 SqlSession接口的方法进行操作数据库。那么我们会思考:SqlSession能否以单例方式使用？？？由于 SqlSession是线程不安全的，所以 SqlSession最佳应用范围在方法体内。也就是说在方法体内定义局部变量 SqlSession的对象来使用。  </p>
<h2 id="2-MyBatis开发DAO的方式"><a href="#2-MyBatis开发DAO的方式" class="headerlink" title="2.MyBatis开发DAO的方式"></a>2.MyBatis开发DAO的方式</h2><p>我们先来看看MyBatis原始开发dao的开发方式，发现原始开发的问题，然后再来看看MyBatis使用mapper动态代理开发dao的方式(也是MyBatis目前使用的开发dao的方式)。  </p>
<h3 id="2-1原始dao的开发方式"><a href="#2-1原始dao的开发方式" class="headerlink" title="2.1原始dao的开发方式"></a>2.1原始dao的开发方式</h3><p>程序员需要编写dao接口:<img src="http://od2xrf8gr.bkt.clouddn.com/dao%E6%8E%A5%E5%8F%A3.png" alt="">和dao接口的实现类:<img src="http://od2xrf8gr.bkt.clouddn.com/dao%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0%E7%B1%BB.png" alt="">  </p>
<p>然后就能在测试类中使用。测试类代码如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E6%B5%8B%E8%AF%95222.png" alt="">  </p>
<p>我们来看看这种方式开发有什么问题?  </p>
<ul>
<li>1.dao的实现类中存在重复代码，整个mybatis操作的过程代码模板重复(都是先创建sqlSession、调用sqlSession的方法、关闭sqlSession)。</li>
<li>2.dao的实现类中存在硬编码，调用sqlSession方法时将statement的id硬编码。</li>
</ul>
<p>下面我们看看mapper动态代理的方式。  </p>
<h3 id="2-2mapper动态代理的方式"><a href="#2-2mapper动态代理的方式" class="headerlink" title="2.2mapper动态代理的方式"></a>2.2mapper动态代理的方式</h3><p>这种方式下程序员只需要写dao接口，dao接口实现对象由mybatis自动生成代理对象。因为本身dao在三层架构中就是一个通用的接口。  </p>
<h4 id="2-2-1mapper开发规范"><a href="#2-2-1mapper开发规范" class="headerlink" title="2.2.1mapper开发规范"></a>2.2.1mapper开发规范</h4><p>要想让mybatis自动创建dao接口实现类的代理对象，必须要遵循一些规则:  </p>
<ul>
<li>1.mapper.xml中 namespace指定为mapper接口的全限定名。此步骤的目的:将mapper.xml和mapper.java关联。</li>
<li>2.mapper.xml中statement的id就是mapper.java中的方法名。</li>
<li>3.mapper.xml中statement的parameterType和mapper.java中方法输入参数一致。</li>
<li>4.mapper.xml中statement的resultType和mapper.java中方法的返回值类型一致。</li>
</ul>
<p>采用这种方式后，我们便可将第一篇文章中提到的User.xml改为UserMapper.xml。文件目录如下:<img src="http://od2xrf8gr.bkt.clouddn.com/mulu22.png" alt="">其中有些类我们会在后面用到。  </p>
<h4 id="2-2-2mapper-xml-映射文件"><a href="#2-2-2mapper-xml-映射文件" class="headerlink" title="2.2.2mapper.xml(映射文件)"></a>2.2.2mapper.xml(映射文件)</h4><p>mapper映射文件的命名方式建议表名加Mapper.xml,namespace指定为mapper接口的全限定名。  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/namespace.png" alt=""></p>
<h4 id="2-2-3mapper-java接口"><a href="#2-2-3mapper-java接口" class="headerlink" title="2.2.3mapper.java接口"></a>2.2.3mapper.java接口</h4><p>mybatis提出了mapper接口,相当于dao接口,mapper接口的命名方式建议为表名加Mapper.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-4将mapper-xml在SqlMapConfing-xml中进行注册"><a href="#2-3-4将mapper-xml在SqlMapConfing-xml中进行注册" class="headerlink" title="2.3.4将mapper.xml在SqlMapConfing.xml中进行注册"></a>2.3.4将mapper.xml在SqlMapConfing.xml中进行注册</h4><pre><code class="xml"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span>
 <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper/UserMapper.xml"</span>/&gt;</span>
<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span>
</code></pre>
<h4 id="2-3-5mapper接口返回单个对象和集合对象"><a href="#2-3-5mapper接口返回单个对象和集合对象" class="headerlink" title="2.3.5mapper接口返回单个对象和集合对象"></a>2.3.5mapper接口返回单个对象和集合对象</h4><p>在UserMapper.java中添加如下两个方法:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/danduo.png" alt="">  </p>
<p>对于UserMapper.xml，不管查询记录是单条还是多条，在statement(即UserMapper.xml)中的resultType都定义一致，都是单条记录映射的pojo类型。  </p>
<p>而对于UserMapper.java接口方法中的返回值，如果返回的是单个对象，返回值类型是pojo，生成的代理对象内部会自动通过selectOne获取记录，如果返回值类型是多条对象，生成的代理对象内部会自动通过selectList获取记录。  </p>
<p>测试代码如下:<img src="http://od2xrf8gr.bkt.clouddn.com/ceshissss.png" alt=""></p>
<p>使用Mapper代理方式进行开发，使程序员只需要关注UserMapper.java接口中的方法，它的实现类由Mapper自动为我们生成，带来了很大的方便。但这种方式也有它的弊端。  </p>
<h4 id="2-3-6mapper代理开发的问题"><a href="#2-3-6mapper代理开发的问题" class="headerlink" title="2.3.6mapper代理开发的问题"></a>2.3.6mapper代理开发的问题</h4><ul>
<li>1.返回值的问题:如果方法(即UserMapper.java接口中的方法)调用的statement中返回是多条记录，而mapper.java方法的返回值为pojo，此时代理对象通过selectOne调用，但由于返回的是多条记录所以会报错:<code>Expected one result (for null ) to be returned by selectOne() but found 4</code>;  </li>
<li>2.输入参数的问题:使用mapper代理的方式开发，mapper接口方法的输入参数只有一个，可扩展性是否很差?答:可扩展性没有问题，因为dao层就是通用的，可以通过扩展pojo(定义pojo包装类型，后面<a href="http://codingxiaxw.cn/2016/11/08/35-mybatis4/">第四篇文章–MyBatis输入输出映射</a>会讲扩展pojo的知识)来将不同的参数(可以是pojo也可以是简单类型)传入进去。</li>
</ul>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis之快速入门]]></title>
      <url>http://codingxiaxw.cn/2016/11/06/31-mybatis%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<p>首先我要明确告诉大家的是MyBatis是一个java持久层框架，以前我们都是用jdbc来将我们的java程序与数据库相连接，而MyBatis是对jdbc的一个封装。<br><a id="more"></a></p>
<h2 id="1-MyBatis框架的引入"><a href="#1-MyBatis框架的引入" class="headerlink" title="1.MyBatis框架的引入"></a>1.MyBatis框架的引入</h2><p>我们来看看传统的编程方式中使用jdbc的问题:  </p>
<ul>
<li>1.数据库连接频繁的创建和关闭，缺点:浪费数据库的资源，影响操作效率。解决方法:使用数据库连接池如c3p0.</li>
<li>2.sql语句是硬编码(不利用系统维护)，如果需求变更需要修改sql，这时候就需要修改java代码，然后需要重新编译，系统不易维护。解决方法:将sql语句统一配置在文件中。这样以后修改sql时就不需要修改java代码了。</li>
<li>3.我们通过preparedStatement对象向占位符设置参数，存在硬编码(参数位置、参数)问题，系统不易维护。解决方法:将sql中的占位符及对应的参数类型配置在配置文件中，能够自动输入的映射。</li>
<li>4.遍历查询结果集存在硬编码(列名)。解决方法:自动进行sql查询结果向java对象的映射(输出映射)。</li>
</ul>
<p>为了解决这些问题，所以出现了MyBatis框架。</p>
<h2 id="2-MyBatis介绍"><a href="#2-MyBatis介绍" class="headerlink" title="2.MyBatis介绍"></a>2.MyBatis介绍</h2><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，实质上Mybatis对ibatis进行一些改进。 目前mybatis在github上托管。  </p>
<p>MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。  </p>
<p>MyBatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。</p>
<h2 id="3-MyBatis架构"><a href="#3-MyBatis架构" class="headerlink" title="3.MyBatis架构"></a>3.MyBatis架构</h2><p>如下图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/mybatis.png" alt="">  </p>
<p>接下来我将通过对一张用户表进行增、删、改、查带你快速入门MyBatis。   </p>
<h2 id="4-MyBatis快速入门"><a href="#4-MyBatis快速入门" class="headerlink" title="4.MyBatis快速入门"></a>4.MyBatis快速入门</h2><h3 id="4-1准备开发环境"><a href="#4-1准备开发环境" class="headerlink" title="4.1准备开发环境"></a>4.1准备开发环境</h3><p>1.创建测试项目，普通java项目或是web项目都可。  </p>
<p>2.导入jar包:mybatis-3.1.1.jar(低于这个版本的jar包需要导入很多依赖包)和mysql-connection-java  </p>
<p>3.创建数据库和相应的表,SQL脚本如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">create database mybatis;</span><br><span class="line"></span><br><span class="line">use mybatis;</span><br><span class="line"></span><br><span class="line"><span class="function">create table <span class="title">user</span><span class="params">(</span><br><span class="line">id <span class="keyword">int</span> primary key auto_increment,</span><br><span class="line">username varchar(<span class="number">50</span>)</span>,</span><br><span class="line">birthday date,</span><br><span class="line">sex <span class="title">varchar</span><span class="params">(<span class="number">20</span>)</span>,</span><br><span class="line">address <span class="title">carchar</span><span class="params">(<span class="number">50</span>)</span></span><br><span class="line">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">insert into user <span class="title">values</span><span class="params">(<span class="keyword">null</span>,<span class="string">'xxw'</span>,<span class="string">'1996-10-17'</span>,<span class="string">'male'</span>,<span class="keyword">null</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">insert into user <span class="title">values</span><span class="params">(<span class="keyword">null</span>,<span class="string">'wyr'</span>,<span class="string">'1997-04-24'</span>,<span class="string">'female'</span>,<span class="keyword">null</span>)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>到此，环境配置就告一段落。</p>
<h3 id="4-2使用MyBatis查询表中数据-通过id查询"><a href="#4-2使用MyBatis查询表中数据-通过id查询" class="headerlink" title="4.2使用MyBatis查询表中数据(通过id查询)"></a>4.2使用MyBatis查询表中数据(通过id查询)</h3><p><strong>1.添加Mybatis的配置文件SqlMapConfig.xml</strong>  </p>
<p>在src目录下创建一个SqlMapConfig.xml文件(文件名称随便起),内容如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/config2.png" alt="">  </p>
<p><strong>2.定义表所需要的实体类User.java</strong>  </p>
<p>代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">   	<span class="keyword">private</span> String username;</span><br><span class="line">   	<span class="keyword">private</span> Date birthday;</span><br><span class="line">   	<span class="keyword">private</span> String sex;</span><br><span class="line">   	<span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">return</span> id;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span></span><br><span class="line">   	</span>&#123;</span><br><span class="line">   		<span class="keyword">this</span>.id = id;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">return</span> username;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">this</span>.username = username;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span></span>&#123;</span><br><span class="line">       	<span class="keyword">return</span> birthday;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> String <span class="title">getSex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">return</span> sex;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(String sex)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">this</span>.sex = sex;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span></span>&#123;</span><br><span class="line">       	<span class="keyword">return</span> address;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">this</span>.address = address;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="meta">@Override</span></span><br><span class="line">   	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       	<span class="keyword">return</span> <span class="string">"domain.User&#123;"</span> +</span><br><span class="line">               <span class="string">"id="</span> + id +</span><br><span class="line">               <span class="string">", username='"</span> + username + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", birthday="</span> + birthday +</span><br><span class="line">               <span class="string">", sex='"</span> + sex + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">", address='"</span> + address + <span class="string">'\''</span> +</span><br><span class="line">               <span class="string">'&#125;'</span>;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>3.定义操作user表的sql映射文件User.xml</strong><br>这里我们没将文件命名为userMapper.xml，后面我们会改。  </p>
<p>User.xml文件内容如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-07%20%E4%B8%8B%E5%8D%886.50.45.png" alt="">  </p>
<p>在User.xml中写SQL语句，在参数处使用占位符<code>#{}</code>，应该注意的是大括号<code>{}</code>中传入的数据应该与User.java中的属性对应，文件中各个属性的解释见图中注释处。  </p>
<p><strong>4.在SqlMapConfig文件中注册User.xml文件</strong><br>在SqlMapConfig.xml中添加一个<code>&lt;mappers&gt;&lt;/mappers&gt;</code>字段，并在里面传入User.xml文件路径。  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/congif.png" alt="">  </p>
<p>整体结构如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/mulu.png" alt="">  </p>
<p><strong>5.接下来我们便可以借助上面MyBatis架构图来编写测试类了</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/select.png" alt="">  </p>
<p>注意，我是借助junit.jar包来编写的测试类。输出结果如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/result...png" alt="">  </p>
<p>上面我们是通过id来对表进行查询，接下来我要讲讲如何通过姓名来模糊查询表。  </p>
<h3 id="4-3使用MyBatis根据用户名模糊查询用户信息"><a href="#4-3使用MyBatis根据用户名模糊查询用户信息" class="headerlink" title="4.3使用MyBatis根据用户名模糊查询用户信息"></a>4.3使用MyBatis根据用户名模糊查询用户信息</h3><p><strong>1.需要在User.xml文件中添加如下字段:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-07%20%E4%B8%8B%E5%8D%887.07.08.png" alt="">  </p>
<p>此时，我们在传入参数的地方不再使用占位符<code>#{}</code>而是使用<code>${}</code>，二者区别如下:  </p>
<ul>
<li><code>#{}</code>:1.表示一个占位符，向占位符输入参数，mybatis自动进行java类型和jdbc类型的转换。2.程序员不需要考虑参数的类型，比如：传入字符串，mybatis最终拼接好的sql就是参数两边加单引号。3.<code>#{}</code>接收pojo(Plain Old Java Object Java数据对象)数据，可以使用OGNL(就是el表达式)解析出pojo的属性值。</li>
<li><code>${}</code>:1.表示sql的拼接，通过<code>${}</code>接收参数，将参数的内容不加任何修饰拼接在sql中。2.<code>${}</code>也可以接收pojo数据，可以使用OGNL解析出pojo的属性值。3.缺点:不能防止sql注入。  </li>
</ul>
<p><strong>2.测试类代码如下:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/byname.png" alt="">  </p>
<p>注意，此时我们通过name查询出来的语句为多条，故此时我们应该选择调用sqlSession对象的selectList()方法返回多条记录，输出我们查询到的第一条记录即可。若使用selectOne()方法，当返回的记录为多条时就会发生异常。</p>
<p>这样我们便完成了查询时将sql结果输出映射到Java对象中。那如何将Java对象输入映射到sql语句中，接下来我们就来讲通过MyBatis实现增、删、改数据库。</p>
<h3 id="4-4使用MyBatis向表中插入一条记录"><a href="#4-4使用MyBatis向表中插入一条记录" class="headerlink" title="4.4使用MyBatis向表中插入一条记录"></a>4.4使用MyBatis向表中插入一条记录</h3><p><strong>1.在User.xml中添加如下字段:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/insertinto.png" alt="">  </p>
<p>貌似关键字为value和values都可以…</p>
<p><strong>2.编写测试类:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/insertintotest.png" alt="">  </p>
<p>此时查看数据库:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/shujuku.png" alt="">  </p>
<p>发现数据已被插入。  </p>
<p><strong>扩展:主键返回:</strong>  </p>
<p>在测试类中，我们没有给User对象的id属性设置值，所以我们在测试类中尝试输出User对象的id时会输出<code>id=0</code>，但是该对象通过输入映射在数据库中是有对应的id值的(因为我们为该字段设置了自增长属性)。那么我们想输出该对象在记录中的id时，又该怎么做呢？只需在User.xml文件中的<code>&lt;insert&gt;&lt;/insert&gt;</code>标签中添加<code>&lt;selectKey&gt;</code>标签即可,属性解释见图:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/insert.png" alt="">  </p>
<p>此时我们在测试类中便可输出该User对象插入在表中的记录id值了。 </p>
<p>这里我们由于在建表时设置了id字段为自增长，采用自增长的形式生成主键，所以我们在传入User对象的id属性时可以将该属性设置为null。那么当我们使用uuid生成主键时又该怎么做呢？  </p>
<p>只需在User.xml中添加如下字段:<br><img src="http://od2xrf8gr.bkt.clouddn.com/abu.png" alt="">  </p>
<p>属性值”before”的意思表示在执行插入操作时，会先调用uuid()函数生成uuid得到主键，然后将主键设置到User对象中，再将User对象插入到数据库。所以此时我们在测试类中也可以不对User的id属性进行设置值。  </p>
<h3 id="4-5使用MyBatis实现删除表中数据"><a href="#4-5使用MyBatis实现删除表中数据" class="headerlink" title="4.5使用MyBatis实现删除表中数据"></a>4.5使用MyBatis实现删除表中数据</h3><p>接下来的操作就很轻松了，因为跟上述操作差不多。  </p>
<p><strong>1.在User.xml文件中添加如下字段:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/delete.png" alt="">  </p>
<p><strong>2.编写测试类:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/delete%E6%B5%8B%E8%AF%95%E7%B1%BB.png" alt="">  </p>
<p>运行程序后便可发现数据库中的该数据已被删除。  </p>
<h3 id="4-6使用MyBatis实现更新表中数据"><a href="#4-6使用MyBatis实现更新表中数据" class="headerlink" title="4.6使用MyBatis实现更新表中数据"></a>4.6使用MyBatis实现更新表中数据</h3><p><strong>1.在User.xml文件中添加如下字段:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/updatexml.png" alt="">  </p>
<p><strong>2.编写测试类:</strong>  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/update%E6%B5%8B%E8%AF%95%E7%B1%BB.png" alt="">  </p>
<p>运行程序后便可发现数据库中的该数据已被更新。  </p>
<h2 id="5-MyBatis开发流程小结"><a href="#5-MyBatis开发流程小结" class="headerlink" title="5.MyBatis开发流程小结"></a>5.MyBatis开发流程小结</h2><p>写过上述代码，我们便可以对MyBatis的开发流程进行一下总结了，流程如下:  </p>
<ul>
<li>1.编写SqlMapConfig.xml</li>
<li>2.编写mapper.xml(每个字段定义一个statement)</li>
<li>3.编程通过配置文件创建SqlSessionFactory</li>
<li>4.通过SqlSessionFactory获取SqlSession对象。</li>
<li>5.通过SqlSession操作数据库。(如果执行添加、更新、删除需要调用SqlSession.commit())</li>
<li>6.SqlSesion使用完成要关闭。</li>
</ul>
<p>关于MyBatis配置的一些优化及高级知识请见我后面的文章。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb之上传下载与JavaMail]]></title>
      <url>http://codingxiaxw.cn/2016/11/02/31-%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%E4%B8%8EJavaMail/</url>
      <content type="html"><![CDATA[<p>对于JavaWeb中的上传与下载，别说你从没遇到过。  </p>
<p>当我们要向网站中上传文件或者需要从网站上下载文件时,其实我们就已经玩了一遍上传与下载了。那么我们上传的文件会保存在服务器的哪里呢？下载的文件又是从服务器的哪里传过来的？这些又是怎么实现的呢？  </p>
<a id="more"></a>
<p>另外很多时候我们注册某个公司的账号时，注册成功后该公司会给你填入的邮箱发送一封邮件，要求你点击邮件中的链接来给该账号激活。这个功能又是怎么实现的呢？  </p>
<p>下面我将告诉你如何用代码实现这些功能。</p>
<h2 id="1-对于多部件表单的体的理解"><a href="#1-对于多部件表单的体的理解" class="headerlink" title="1.对于多部件表单的体的理解"></a>1.对于多部件表单的体的理解</h2><p>通过抓包的方式可以看到服务器发送过来的响应,理解如下:  </p>
<ul>
<li>1.分隔出多个部件，即一个表单项一个部件。  </li>
<li>2.一个部件中包含请求头和空行，以及请求体。  </li>
<li>3.普通表单项:<blockquote>
<p>1个头:Context-Disposition:包含name=“xxxx”，即表单项名称。<br>体就是表单项的值。</p>
</blockquote>
</li>
<li>4.文件表单项:<blockquote>
<p>有2个头:a.Content-Disposition:包含name=“xxxx”,即表单项名称；还有一个filename=“xxx”,表示上传文件的名称。<br>Content－Type：它是上传文件的MIME类型，例如:image/pjpeg,表示上传的是图片，图片为jpg扩展名的图片。<br>体就是上传文件的内容。  </p>
</blockquote>
</li>
</ul>
<h2 id="2-实现文件的上传"><a href="#2-实现文件的上传" class="headerlink" title="2.实现文件的上传"></a>2.实现文件的上传</h2><p>首先我们需要明确的是要实现上传和下载功能都要借助第三方Jar包 <code>fileupload.jar</code>,依赖jar包为:<code>commons-io.jar</code>。 </p>
<h3 id="2-1上传对表单的限制"><a href="#2-1上传对表单的限制" class="headerlink" title="2.1上传对表单的限制"></a>2.1上传对表单的限制</h3><ul>
<li>1.method必须为”post”.</li>
<li>2.必须对表单form添加<code>enctype=&quot;multipart/form-data&quot;</code>的属性。</li>
<li>3.表单中需要添加文件表单项:<code>&lt;input type=&quot;file&quot; name=&quot;xxx&quot;/&gt;</code>,除了文件表单项叫文件表单项外其他所有的input表单项都叫普通表单项。</li>
</ul>
<h3 id="2-2上传对servlet的限制"><a href="#2-2上传对servlet的限制" class="headerlink" title="2.2上传对servlet的限制"></a>2.2上传对servlet的限制</h3><ul>
<li>1.在servlet中通过方法<code>request.getParameter(&quot;xxx&quot;);</code>得到表单中的参数时得到返回值不再是Object对象，而是返回的null，因为文件表单form添加了<code>enctype=&quot;multipart/form-data</code>的属性。</li>
<li>2.解决方法:在Servlet中通过方法<code>ServletInputStream request.getInputStream();</code>得到表单中的参数，然而得到的内容将是表单的整个请求体。  </li>
</ul>
<h3 id="2-3上传的代码实现"><a href="#2-3上传的代码实现" class="headerlink" title="2.3上传的代码实现"></a>2.3上传的代码实现</h3><p><strong>涉及到的类:</strong>  </p>
<ul>
<li>1.工厂类:FileItemFactory类</li>
<li>2.解析器类:ServletFileUpload类</li>
<li>3.表单项:FileItem</li>
</ul>
<p><strong>代码步骤:</strong>  </p>
<ul>
<li>1.创建工厂:<code>DiskFileItemFactory factory=new DiskFileItemFactory();</code></li>
<li>2.创建解析器:<code>ServletFileUpload sfu=new ServletFileUpload(factory);</code></li>
<li>3.使用解析器来解析request，得到的是FileItem集合:<code>List&lt;FileItem&gt; fileItemList=sfu.parseRequest(request);</code></li>
</ul>
<p><strong>Demo:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/upload3.png" alt=""></p>
<p><strong>FileItem的API</strong></p>
<ul>
<li><code>boolean isFormField()</code>:是否为普通表单项，如果返回true则为普通表单项，如果为false则为文件表单项。</li>
<li><code>String getFieldName()</code>:返回当前表单项的名称。</li>
<li><code>String getString(String charset)</code>:返回表单项的值，参数传入utf-8即可。这个方法不适合文件表单项。</li>
<li><code>String getName()</code>:返回上传的文件名称。</li>
<li><code>long getSize()</code>:返回上传文件的字节数。</li>
<li><code>InputStream getInputStream()</code>:返回上传文件对应的输入流。</li>
<li><code>void write(File file)</code>:把上传的文件内容保存到指定的文件中。</li>
<li><code>String getContextType()</code>;</li>
</ul>
<h3 id="2-4上传的细节"><a href="#2-4上传的细节" class="headerlink" title="2.4上传的细节"></a>2.4上传的细节</h3><ul>
<li>1.文件必须保存到WEB-INF文件下<blockquote>
<p>为了不让浏览器直接访问到。</p>
</blockquote>
</li>
<li>2.文件名称相关问题<ul>
<li>a.有的浏览器上传的文件名是绝对路径，如<code>c:\file\图片.jpg</code>，这时需要对文件名进行切割，切割的代码为:<blockquote>
<pre><code>String fileName=file2.getName();//file2为FileItem对象  
int index=fileName.lastIndex(&quot;\\&quot;);  
if(index!=-1)
{
    fileName=fileName.substring(index+1);
}
</code></pre></blockquote>
</li>
<li>b.文件名乱码或者普通表单项乱码<blockquote>
<p>解决方法:告诉fileupload你的编码方式，在servlet中设置代码<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code>因为fileupload内部会调用<code>request.getCharacterEncoding();</code>得到你的编码方式。<br>解决方法1，在servlet中添加:<code>request.setCharacterEncoding(&quot;utf-8&quot;);//优先级比下面的方式低</code><br>解决方法2，在servlet中添加:<code>servletFileUpload.setHeaderEncoding(&quot;utf-8&quot;);//优先级比上面的方式低。</code>也就是说，当同时出现解决方法1中的代码和解决方法2中的代码时，会优先使用方法2来设置编码方式。</p>
</blockquote>
</li>
<li>c.文件同名问题:我们需要为上传过来的每个文件都添加名称前缀，而且这个前缀要保证不能重复(使用uuid解决).<blockquote>
<p>fileName=CommonUtils.uuid()+”_”+fileName;</p>
</blockquote>
</li>
</ul>
</li>
<li>3.因为不能在一个目录下存放过多文件，所以我们需要对目录进行打散，打散的方法有如下3种:<ul>
<li>a.首字符打散:使用文件的首字母作为目录名称，例如:abc.text，那么我们就把文件保存到a目录下，如果a目录不存在，那么创建之。(缺点:若文件名称为中文咋办？)</li>
<li>b.时间打散:使用当前日期作为目录</li>
<li>哈希打散:(缺点，存在目录下的文件我们不清楚)1.通过文件名称得到int值，即调用hashCode();2.把int值转换成16进制0-9,A-F;3.获取16进制的前2位用来生成目录，目录为二层！例如:1B2C3D4E5F,生成的目录为/1/B，在其下保存文件。</li>
</ul>
</li>
<li>4.上传文件的大小限制<ul>
<li>a.单个文件的大小限制<blockquote>
<p>1.<code>sfu.setFilesizeMax(100*1024);</code>限制单个文件大小为100kb，此方法调用必须在解析开始之前调用。<br>2.如果上传的文件超过限制，则在<code>parseRequest()</code>方法时，会抛出异常。</p>
</blockquote>
</li>
<li>b.整个请求所有文件大小限制<blockquote>
<p><code>sfu.setSizeMax(1024*1024);</code>限制整个表单大小为1M。此方法调用必须在解析开始之前调用。<br>如果上传的文件超过限制，则在parseRequest()方法时，会抛出异常。超出限制大小时显示错误信息代码:需要在jsp文件中增加${msg}。<br>代码如下: <img src="http://od2xrf8gr.bkt.clouddn.com/%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E8%B6%85%E8%BF%87%E9%99%90%E5%88%B6%E6%98%BE%E7%A4%BA%E9%94%99%E8%AF%AF%E4%BF%A1%E6%81%AF.png" alt=""></p>
</blockquote>
</li>
</ul>
</li>
<li>5.缓存大小与临时目录<ul>
<li>缓存大小:超出多大，才向硬盘中保存。默认为10KB。</li>
<li>临时目录:向硬盘的什么目录保存。</li>
</ul>
</li>
</ul>
<p><strong>说明:</strong>设置缓存大小与临时目录，在创建工厂时，调用DiskFileItemFactory的有参构造器:DiskFileItemFactory factory=new DiskFileItemFactory(缓存大小，硬盘临时目录路径)；。当文件正在上传时，会在硬盘的该临时目录下出现这个文件；而当文件上传完毕时，硬盘下该临时目录下的这个文件就会消失。最后保存在web-inf的target目录下。</p>
<h2 id="3-实现文件的下载"><a href="#3-实现文件的下载" class="headerlink" title="3.实现文件的下载"></a>3.实现文件的下载</h2><p>下文文件就是向客户端响应字节数据。当不涉及文件下载时你向服务器发出一个请求时，服务器返回的响应都是html的字符数据；而当涉及到文件下载时，服务器会把一个文件变成字节数组，使用<code>response.getOutputStream();</code>来响应给浏览器。</p>
<h3 id="3-1文件下载的要求"><a href="#3-1文件下载的要求" class="headerlink" title="3.1文件下载的要求"></a>3.1文件下载的要求</h3><p><strong>设置两个头一个流:</strong>  </p>
<ul>
<li>Content-Type:你传递给客户端的文件是什么MIME类型，例如:image/pjpeg。可以通过文件名称调用ServletContext的getMimeType()方法得到MIME类型。</li>
<li>Content-Disposition:它的默认值为inline，表示在浏览器窗口中打开。<code>attachment;fileName=xxx;</code>在fileName后面跟随的是显示在下载框中的文件名称。</li>
<li>流:要下载的文件数据。自己new一个输入流即可。</li>
</ul>
<h3 id="3-2下载Demo"><a href="#3-2下载Demo" class="headerlink" title="3.2下载Demo"></a>3.2下载Demo</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%A0%81.png" alt=""></p>
<h3 id="3-3下载的细节"><a href="#3-3下载的细节" class="headerlink" title="3.3下载的细节"></a>3.3下载的细节</h3><p>1.显示在下载框中的中文名称时，会出现乱码。  </p>
<ul>
<li>FireFox:Base64编码</li>
<li>其它大部分浏览器:url编码</li>
</ul>
<p>通用方案:<code>frameName=new String(filename.getBytes(&quot;GBK&quot;),&quot;ISO-8859-1&quot;);</code>  </p>
<p>代码见下:<img src="http://od2xrf8gr.bkt.clouddn.com/%E4%B8%8B%E8%BD%BD%E6%A1%86%E4%B8%AD%E8%A7%A3%E5%86%B3%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81.png" alt="">  </p>
<p>注意downutil.jar包的使用</p>
<h2 id="4-JavaMail"><a href="#4-JavaMail" class="headerlink" title="4.JavaMail"></a>4.JavaMail</h2><p>JavaMail是Java提供的一组API，用来发送和接收邮件。  </p>
<p>需要导入的jar包为:1.mail.jar2.activation.jar</p>
<h3 id="4-1与邮件相关的协议"><a href="#4-1与邮件相关的协议" class="headerlink" title="4.1与邮件相关的协议"></a>4.1与邮件相关的协议</h3><p>smtp 25–&gt;简单的邮件传输协议。<br>pop3 110–&gt;邮局协议第三版 </p>
<h3 id="4-2核心类"><a href="#4-2核心类" class="headerlink" title="4.2核心类"></a>4.2核心类</h3><p>1.<em>Session</em>(这跟我们Servlet中的HttpSession不同哦).  </p>
<p>如果你得到了它，表示已经与服务器连接上了，与Connectin的作用相似。  </p>
<p>得到Session，需要使用<code>Session.getInstance(Properties,authenticator);</code>方法。  </p>
<p><strong>得到Session对象的Demo如下:</strong>  </p>
<pre><code>Properties props=new Properties();
props.setProperty(“mail.host”,”smtp.163.com”);
props.setProperty(“mail.smtp.auth”,”true”);

Authenticator auth=new Authenticator(){
protected PasswordAuthentication getPasswordAuthentication(){
    return new PasswordAuthentication(“username”,”password”);
    }
};

Session session=Session.getInstance(props,auth);
</code></pre><p>2.<em>MimeMessage</em><br>它表示一个邮件对象，你可以调用它的<code>setFrom()</code>方法进行设置发件人、设置主题、设置正文。</p>
<p>3.TransPort<br>它只有一个发邮件的功能。  </p>
<h3 id="4-3完整Demo如下"><a href="#4-3完整Demo如下" class="headerlink" title="4.3完整Demo如下"></a>4.3完整Demo如下</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E4%BD%BF%E7%94%A8javamail%E5%8F%91%E9%82%AE%E4%BB%B6.png" alt="">  </p>
<h3 id="4-4带有附件的邮件"><a href="#4-4带有附件的邮件" class="headerlink" title="4.4带有附件的邮件"></a>4.4带有附件的邮件</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/demo9.png" alt=""></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="5-联系"><a href="#5-联系" class="headerlink" title="5.联系"></a>5.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb之JSTL标签库]]></title>
      <url>http://codingxiaxw.cn/2016/10/30/29-JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>之前学习EL表达式和JSTL标签库的时候只将EL的知识总结后上传到了blog上，没抽时间将JSTL的知识总结出来，如今做项目时在JSP页面中涉及到太多JSTL标签的语法，于是便抽时间将这篇博客补上。  </p>
<a id="more"></a> 
<p><strong>首先需要说明的是:</strong> 此博客参考<a href="http://www.cnblogs.com/xdp-gacl/p/3943390.html" target="_blank" rel="external">孤傲苍狼</a>这位技术大牛对JSTL标签的理解，写的非常通俗易懂。原文链接:  <a href="http://www.cnblogs.com/xdp-gacl/p/3943390.html" target="_blank" rel="external">http://www.cnblogs.com/xdp-gacl/p/3943390.html</a></p>
<h2 id="1-JSTL标签库介绍"><a href="#1-JSTL标签库介绍" class="headerlink" title="1.JSTL标签库介绍"></a>1.JSTL标签库介绍</h2><p>JSTL标签库的使用是为弥补html标签的不足，规范自定义标签的使用而诞生的。使用JSLT标签的目的就是不希望在jsp页面中出现java逻辑代码。JSTL也是对EL表达式的扩展(也就是说JSTL依赖EL)，是一门标签语言。JSTL标签使用起来非常方便，它与JSP动作标签一样，只不过它不是JSP内置的标签，需要我们自己导包，一定要指定标签库。 </p>
<p>如果你使用MyEclipse开发JavaWeb，那么把项目发布到Tomcat时，你会发现MyEclipse在lib目录下自动存放了JSTL的Jar包。如果你使用其他IDE，那么你需要手动导入这个JSTL的Jar包:jstl-1.2.jar。  </p>
<h2 id="2-JSTL标签库的分类"><a href="#2-JSTL标签库的分类" class="headerlink" title="2.JSTL标签库的分类"></a>2.JSTL标签库的分类</h2><ul>
<li>core:核心标签库(用得最多)</li>
<li>fmt:国际化标签库(只需学习两个，日期和数字)</li>
<li>sql:数据库标签库(过时了，不需要学习)</li>
<li>xml:xml标签库(过时了，不需要学习)</li>
</ul>
<h2 id="3-核心标签库使用说明"><a href="#3-核心标签库使用说明" class="headerlink" title="3.核心标签库使用说明"></a>3.核心标签库使用说明</h2><p>JSTL的核心标签库标签共13个，使用这些标签能够完成JSP页面的基本功能，减少编码工作。  </p>
<p>从功能上可以分为4类:表达式控制标签、流程控制标签、循环标签、URL操作标签。  </p>
<ul>
<li>(1) 表达式控制标签:out标签、set标签、remove标签、catch标签</li>
<li>(2) 流程控制标签:if标签、choose标签、when标签、otherwise标签</li>
<li>(3) 循环标签:forEach标签、forTokens标签</li>
<li>(4) URL操作标签</li>
</ul>
<p>在JSP页面引入核心标签库的代码为:<code>&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</code></p>
<h3 id="3-1表达式控制标签——out标签使用"><a href="#3-1表达式控制标签——out标签使用" class="headerlink" title="3.1表达式控制标签——out标签使用"></a>3.1表达式控制标签——out标签使用</h3><h4 id="3-1-1-lt-c-out-gt-标签的功能"><a href="#3-1-1-lt-c-out-gt-标签的功能" class="headerlink" title="3.1.1&lt;c:out&gt;标签的功能"></a>3.1.1<code>&lt;c:out&gt;</code>标签的功能</h4><p><code>&lt;c:out&gt;</code>标签主要是用来输出数据对象(字符串、表达式)的内容或结果。  </p>
<p>在使用Java脚本输出时常使用的方式为:<code>&lt;% out.println(&quot;字符串&quot;); %&gt;</code>或者<code>&lt;%=表达式 %&gt;</code>，在web开发中，为了避免暴露逻辑代码会尽量减少页面中的Java脚本，使用<code>&lt;c:out&gt;</code>标签就可以实现以上功能。  </p>
<pre><code>&lt;c:out value=&quot;字符串&quot;/&gt;或者&lt;c:out value=&quot;EL表达式&quot;/&gt;  
</code></pre><p>JSTL的使用是和EL表达式分不开的，EL表达式虽然可以直接将结果返回给页面，但有时得到的结果为空，<code>&lt;c:out&gt;</code>有特定的结果处理功能，EL的单独使用会降低程序的易读性，建议把EL的结果输入放入<code>&lt;c:out&gt;</code>标签中。  </p>
<h4 id="3-1-2-lt-c-out-gt-标签的语法"><a href="#3-1-2-lt-c-out-gt-标签的语法" class="headerlink" title="3.1.2&lt;c:out&gt;标签的语法"></a>3.1.2<code>&lt;c:out&gt;</code>标签的语法</h4><p><code>&lt;c:out&gt;</code>标签的使用有两种语法格式:  </p>
<ul>
<li>语法1:<code>&lt;c:out value=&quot;要显示的数据对象&quot; [escapeXml=&quot;true|false&quot;][default=&quot;默认值&quot;]/&gt;</code></li>
<li>语法2:<code>&lt;c:out value=&quot;要显示的数据对象&quot; [escapeXml=&quot;true|false&quot;]&gt;默认值&lt;/c:out&gt;</code></li>
</ul>
<p>这两种方式没有本质的区别，只是格式上的差别。[escapeXml=”true|false”][defult=”默认值”]这些使用[]属性表示是不是必须的。  </p>
<h4 id="3-1-3-lt-c-out-gt-标签的属性"><a href="#3-1-3-lt-c-out-gt-标签的属性" class="headerlink" title="3.1.3&lt;c:out&gt;标签的属性"></a>3.1.3<code>&lt;c:out&gt;</code>标签的属性</h4><table>
<thead>
<tr>
<th>属性名</th>
<th style="text-align:center">是否支持EL</th>
<th>属性类型</th>
<th>属性描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Value</td>
<td style="text-align:center">true</td>
<td>Object</td>
<td>指定要输出的内容</td>
</tr>
<tr>
<td>escapeXml</td>
<td style="text-align:center">true</td>
<td>Boolean</td>
<td>指定是否将&gt;、&lt;、&amp;、’ 、”等特殊字符进行HTML编码转换后再进行输出。默认值为true。</td>
</tr>
<tr>
<td>default</td>
<td style="text-align:center">true</td>
<td>Object</td>
<td>指定如果value属性的值为null时所输出的默认值</td>
</tr>
</tbody>
</table>
<h4 id="3-1-4-lt-c-out-gt-标签的使用范例"><a href="#3-1-4-lt-c-out-gt-标签的使用范例" class="headerlink" title="3.1.4&lt;c:out&gt;标签的使用范例"></a>3.1.4<code>&lt;c:out&gt;</code>标签的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;JSTL: --表达式控制标签“out”标签的使用&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h3&gt;&lt;c:out value=&quot;下面的代码演示了c:out的使用，以及在不同属性值状态下的结果。&quot;/&gt;&lt;/h3&gt;
&lt;hr/&gt;
&lt;ul&gt;
    &lt;%--（1）直接输出了一个字符串。 --%&gt;
    &lt;li&gt;（1）&lt;c:out value=&quot;JSTL的out标签的使用&quot; /&gt;&lt;/li&gt;

    &lt;li&gt;（2）&lt;c:out value=&quot;&lt;a href=&apos;http://www.cnblogs.com/&apos;&gt;点击链接到博客园&lt;/a&gt;&quot; /&gt;&lt;/li&gt;
    &lt;%--escapeXml=&quot;false&quot;表示value值中的html标签不进行转义，而是直接输出 --%&gt;
    &lt;li&gt;（3）&lt;c:out value=&quot;&lt;a href=&apos;http://www.cnblogs.com/&apos;&gt;点击链接到博客园&lt;/a&gt;&quot; escapeXml=&quot;false&quot;/&gt;&lt;/li&gt;

    &lt;%--(4）字符串中有转义字符，但在默认情况下没有转换。 --%&gt;
    &lt;li&gt;（4）&lt;c:out value=&quot;&amp;lt未使用字符转义&amp;gt&quot; /&gt;&lt;/li&gt;
    &lt;%--（5）使用了转义字符&amp;lt和&amp;gt分别转换成&lt;和&gt;符号。 --%&gt;
    &lt;li&gt;（5）&lt;c:out value=&quot;&amp;lt使用字符转义&amp;gt&quot; escapeXml=&quot;false&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;

    &lt;%--（6）设定了默认值，从EL表达式${null}得到空值，所以直接输出设定的默认值。 --%&gt;
    &lt;li&gt;（6）&lt;c:out value=&quot;${null}&quot;&gt;使用了默认值&lt;/c:out&gt;&lt;/li&gt;
    &lt;%--（7）未设定默认值，输出结果为空。 --%&gt;
    &lt;li&gt;（7）&lt;c:out value=&quot;${null}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;

    &lt;%--（8）设定了默认值，从EL表达式${null}得到空值，所以直接输出设定的默认值。 --%&gt;
    &lt;li&gt;（8）&lt;c:out value=&quot;${null}&quot; default=&quot;默认值&quot;/&gt;&lt;/li&gt;
    &lt;%--（9）未设定默认值，输出结果为空。 --%&gt;
    &lt;li&gt;（9）&lt;c:out value=&quot;${null}&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>运行结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/1.png" alt=""></p>
<h3 id="3-2表达式控制标签——set标签的使用"><a href="#3-2表达式控制标签——set标签的使用" class="headerlink" title="3.2表达式控制标签——set标签的使用"></a>3.2表达式控制标签——set标签的使用</h3><h4 id="3-2-1-lt-c-set-gt-标签的功能"><a href="#3-2-1-lt-c-set-gt-标签的功能" class="headerlink" title="3.2.1&lt;c:set&gt;标签的功能"></a>3.2.1<code>&lt;c:set&gt;</code>标签的功能</h4><p><code>&lt;c:set&gt;</code>标签用于把某一个对象存在指定的域范围内，或者将某一个对象存储到Map或者JavaBean对象中。  </p>
<h4 id="3-2-2-lt-c-set-gt-标签的语法"><a href="#3-2-2-lt-c-set-gt-标签的语法" class="headerlink" title="3.2.2&lt;c:set&gt;标签的语法"></a>3.2.2<code>&lt;c:set&gt;</code>标签的语法</h4><p><code>&lt;c:set&gt;</code>标签的编写共有4种语法格式。  </p>
<ul>
<li>语法1:存值，把一个值放在指定的域范围内.<code>&lt;c:set value=”值1” var=”name1” [scope=”page|request|session|application”]/&gt;</code>  <blockquote>
<p>含义:把一个变量名为name1值为“值1”的变量存储在指定的scope范围内。</p>
</blockquote>
</li>
<li>语法2:<code>&lt;c:set var=”name2” [scope=”page|request|session|application”]&gt;值2&lt;/c:set&gt;</code>  <blockquote>
<p>含义：把一个变量名为name2，值为值2的变量存储在指定的scope范围内。</p>
</blockquote>
</li>
<li>语法3: <code>&lt;c:set value=”值3” target=”JavaBean对象” property=”属性名”/&gt;</code> <blockquote>
<p>含义:把一个值为“值3”赋值给指定的JavaBean的属性名。相当与setter()方法。</p>
</blockquote>
</li>
<li>语法4: <code>&lt;c:set target=”JavaBean对象” property=”属性名”&gt;值4&lt;/c:set&gt;</code>  <blockquote>
<p>含义：把一个值4赋值给指定的JavaBean的属性名。  </p>
</blockquote>
</li>
</ul>
<p>从功能上分语法1和语法2、语法3和语法4的效果是一样的，只是把value值放置的位置不同，至于使用那个根据个人的喜爱，语法1和语法2是向scope范围内存储一个值，语法3和语法4是给指定的JavaBean赋值。</p>
<h4 id="3-2-3-lt-c-set-gt-标签的属性"><a href="#3-2-3-lt-c-set-gt-标签的属性" class="headerlink" title="3.2.3&lt;c:set&gt;标签的属性"></a>3.2.3<code>&lt;c:set&gt;</code>标签的属性</h4><table>
<thead>
<tr>
<th>属性名</th>
<th style="text-align:center">是否支持EL</th>
<th>属性类型</th>
<th>属性描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Value</td>
<td style="text-align:center">true</td>
<td>Object</td>
<td>用于指定属性值</td>
</tr>
<tr>
<td>var</td>
<td style="text-align:center">false</td>
<td>String</td>
<td>用于指定要设置的Web域属性的名称</td>
</tr>
<tr>
<td>scope</td>
<td style="text-align:center">false</td>
<td>String</td>
<td>用于指定属性所在的Web域</td>
</tr>
<tr>
<td>target</td>
<td style="text-align:center">true</td>
<td>Object</td>
<td>用于指定要设置属性的对象，这个对象必须是JavaBean对象或java.util.Map对象</td>
</tr>
<tr>
<td>property</td>
<td style="text-align:center">true</td>
<td>string</td>
<td>用于指定当前要为对象设置的属性名称</td>
</tr>
</tbody>
</table>
<h4 id="3-2-4-lt-c-set-gt-标签的使用范例"><a href="#3-2-4-lt-c-set-gt-标签的使用范例" class="headerlink" title="3.2.4&lt;c:set&gt;标签的使用范例"></a>3.2.4<code>&lt;c:set&gt;</code>标签的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;%--使用JSP的指令元素指定要使用的JavaBean --%&gt;
&lt;jsp:useBean id=&quot;person&quot; class=&quot;javabean.Person&quot;/&gt;
&lt;%--负责实例化Bean，id指定实例化后的对象名，可以通过${person}得到person在内存中的值（或者使用person.toString()方法）。 --%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;

&lt;title&gt;JSTL: --表达式控制标签“set”标签的使用&lt;/title&gt;

&lt;/head&gt;

&lt;body&gt;
&lt;h3&gt;代码给出了给指定scope范围赋值的示例。&lt;/h3&gt;
&lt;ul&gt;
    &lt;%--通过&lt;c:set&gt;标签将data1的值放入page范围中。--%&gt;
    &lt;li&gt;把一个值放入page域中:&lt;c:set var=&quot;data1&quot; value=&quot;xdp&quot; scope=&quot;page&quot;/&gt;&lt;/li&gt;
    &lt;%--使用EL表达式从pageScope得到data1的值。--%&gt;
    &lt;li&gt;从page域中得到值：${pageScope.data1}&lt;/li&gt;

    &lt;%--通过&lt;c:set&gt;标签将data2的值放入request范围中。--%&gt;
    &lt;li&gt;把一个值放入request域中:&lt;c:set var=&quot;data2&quot; value=&quot;gacl&quot; scope=&quot;request&quot;/&gt;&lt;/li&gt;
    &lt;%--使用EL表达式从requestScope得到data2的值。--%&gt;
    &lt;li&gt;从request域中得到值：${requestScope.data2}&lt;/li&gt;

    &lt;%--通过&lt;c:set&gt;标签将值name1的值放入session范围中。--%&gt;
    &lt;li&gt;把一个值放入session域中。&lt;c:set value=&quot;孤傲苍狼&quot; var=&quot;name1&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt;&lt;/li&gt;
    &lt;%--使用EL表达式从sessionScope得到name1的值。--%&gt;
    &lt;li&gt;从session域中得到值:${sessionScope.name1} &lt;/li&gt;

    &lt;%--把name2放入application范围中。 --%&gt;
    &lt;li&gt;把一个值放入application域中。&lt;c:set var=&quot;name2&quot; scope=&quot;application&quot;&gt;白虎神皇&lt;/c:set&gt;&lt;/li&gt;
    &lt;%--使用EL表达式从application范围中取值，用&lt;c:out&gt;标签输出使得页面规范化。 --%&gt;
    &lt;li&gt;使用out标签和EL表达式嵌套从application域中得到值： 
         &lt;c:out value=&quot;${applicationScope.name2}&quot;&gt;未得到name的值&lt;/c:out&gt;
    &lt;/li&gt;

    &lt;%--不指定范围使用EL自动查找得到值 --%&gt; 
    &lt;li&gt;未指定scope的范围，会从不同的范围内查找得到相应的值：${data1}、${data2}、${name1}、${name2}&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;h3&gt;使用Java脚本实现以上功能&lt;/h3&gt;
&lt;ul&gt;

    &lt;li&gt;把一个值放入page域中。&lt;%pageContext.setAttribute(&quot;data1&quot;,&quot;xdp&quot;);%&gt;&lt;/li&gt;
    &lt;li&gt;从page域中得到值:&lt;%out.println(pageContext.getAttribute(&quot;data1&quot;));%&gt;&lt;/li&gt;

    &lt;li&gt;把一个值放入request域中。&lt;%request.setAttribute(&quot;data2&quot;,&quot;gacl&quot;);%&gt;&lt;/li&gt;
    &lt;li&gt;从request域中得到值:&lt;%out.println(request.getAttribute(&quot;data2&quot;));%&gt;&lt;/li&gt;

    &lt;li&gt;把一个值放入session域中。&lt;%session.setAttribute(&quot;name1&quot;,&quot;孤傲苍狼&quot;);%&gt;&lt;/li&gt;
    &lt;li&gt;从session中域得到值:&lt;%out.println(session.getAttribute(&quot;name1&quot;));%&gt;&lt;/li&gt;
    &lt;%--out.println()方法与&lt;%=%&gt;表达式输出功能一样 
    但使用表达式输出（&lt;%=%&gt;）明显要比使用out.println()输出更好。
    --%&gt;
    &lt;li&gt;&lt;%=session.getAttribute(&quot;name1&quot;) %&gt;&lt;/li&gt;
    &lt;li&gt;把另一个值放入application域中。&lt;%application.setAttribute(&quot;name2&quot;,&quot;白虎神皇&quot;);%&gt;&lt;/li&gt;
    &lt;li&gt; 从application域中得到值：&lt;%out.println(application.getAttribute(&quot;name2&quot;));%&gt;&lt;/li&gt;
    &lt;li&gt;&lt;%=application.getAttribute(&quot;name2&quot;)%&gt;&lt;/li&gt;

    &lt;li&gt;未指定scope的范围，会从不同的范围内查找得到相应的值：
        &lt;%=pageContext.findAttribute(&quot;data1&quot;)%&gt;、
        &lt;%=pageContext.findAttribute(&quot;data2&quot;)%&gt;、
        &lt;%=pageContext.findAttribute(&quot;name1&quot;)%&gt;、
        &lt;%=pageContext.findAttribute(&quot;name2&quot;)%&gt;
    &lt;/li&gt;

&lt;/ul&gt;
&lt;hr/&gt;
&lt;h3&gt;操作JavaBean，设置JavaBean的属性值&lt;/h3&gt;
&lt;%--设置JavaBean的属性值，等同与setter方法，Target指向实例化后的对象，property指向要插入值的参数名。
注意：使用target时一定要指向实例化后的JavaBean对象，也就是要跟&lt;jsp:useBean&gt;配套使用，
也可以java脚本实例化，但这就失去了是用标签的本质意义。
使用Java脚本实例化：
&lt;%@page import=&quot;javabean.Person&quot;%
&lt;% Person person=new Person(); %&gt;
 --%&gt;
&lt;c:set target=&quot;${person}&quot; property=&quot;name&quot;&gt;孤傲苍狼&lt;/c:set&gt;
&lt;c:set target=&quot;${person}&quot; property=&quot;age&quot;&gt;25&lt;/c:set&gt;
&lt;c:set target=&quot;${person}&quot; property=&quot;sex&quot;&gt;男&lt;/c:set&gt;
&lt;c:set target=&quot;${person}&quot; property=&quot;home&quot;&gt;中国&lt;/c:set&gt;
&lt;ul&gt;
    &lt;li&gt;使用的目标对象为：${person}&lt;/li&gt;
    &lt;li&gt;从Bean中获得的name值为：&lt;c:out value=&quot;${person.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;
    &lt;li&gt;从Bean中获得的age值为：&lt;c:out value=&quot;${person.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;
    &lt;li&gt;从Bean中获得的sex值为：&lt;c:out value=&quot;${person.sex}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;
    &lt;li&gt;从Bean中获得的home值为：&lt;c:out value=&quot;${person.home}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr/&gt;
&lt;h3&gt;操作Map&lt;/h3&gt;
 &lt;% 
    Map map = new HashMap();
    request.setAttribute(&quot;map&quot;,map);
 %&gt;
 &lt;%--将data对象的值存储到map集合中 --%&gt;
&lt;c:set property=&quot;data&quot; value=&quot;gacl&quot; target=&quot;${map}&quot;/&gt;
    ${map.data}
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>jsp页面中使用到的javabean.Person类的代码如下:</strong>  </p>
<pre><code>package javabean;

/**
* 项目名称：JSTLStudy 
* 类名称：Person 
* 类描述：一个只有getter和setter方法的JavaBean或者说一个pojo(简单的Java对象(Plain Old Java Objects))类，
* 作为一个vo（数据传输对象）。定义了四个变量age、name、sex和home。 
*/
public class Person {

    private String age;

    private String home;

    private String name;

    private String sex;

    public String getAge() {
        return age;
    }

    public String getHome() {
        return home;
    }

    public String getName() {
        return name;
    }

    public String getSex() {
        return sex;
   }

    public void setAge(String age) {
        this.age = age;
    }

    public void setHome(String home) {
        this.home = home;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
</code></pre><p>运行结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/2.png" alt=""></p>
<h3 id="3-3表达式控制标签——remove标签的使用"><a href="#3-3表达式控制标签——remove标签的使用" class="headerlink" title="3.3表达式控制标签——remove标签的使用"></a>3.3表达式控制标签——remove标签的使用</h3><h4 id="3-3-1-lt-c-remove-gt-标签的功能"><a href="#3-3-1-lt-c-remove-gt-标签的功能" class="headerlink" title="3.3.1&lt;c:remove&gt;标签的功能"></a>3.3.1<code>&lt;c:remove&gt;</code>标签的功能</h4><p><code>&lt;c:remove&gt;</code>标签主要用来从指定的JSP范围内移除指定的变量。  </p>
<h4 id="3-3-2-lt-c-remove-gt-标签的语法"><a href="#3-3-2-lt-c-remove-gt-标签的语法" class="headerlink" title="3.3.2&lt;c:remove&gt;标签的语法"></a>3.3.2<code>&lt;c:remove&gt;</code>标签的语法</h4><p><code>&lt;c:remove var=&quot;变量名&quot; [scope=”page|request|session|application”]/&gt;</code>其中var属性是必须的，scope可以以省略。  </p>
<h4 id="3-3-3-lt-c-remove-gt-标签的使用范例"><a href="#3-3-3-lt-c-remove-gt-标签的使用范例" class="headerlink" title="3.3.3&lt;c:remove&gt;标签的使用范例"></a>3.3.3<code>&lt;c:remove&gt;</code>标签的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;JSTL: --表达式控制标签“remove”标签的使用&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;ul&gt;
        &lt;c:set var=&quot;name&quot; scope=&quot;session&quot;&gt;孤傲苍狼&lt;/c:set&gt;
        &lt;c:set var=&quot;age&quot; scope=&quot;session&quot;&gt;25&lt;/c:set&gt;
        &lt;li&gt;&lt;c:out value=&quot;${sessionScope.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;
        &lt;li&gt;&lt;c:out value=&quot;${sessionScope.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;
        &lt;%--使用remove标签移除age变量 --%&gt;
        &lt;c:remove var=&quot;age&quot; /&gt;
        &lt;li&gt;&lt;c:out value=&quot;${sessionScope.name}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;
        &lt;li&gt;&lt;c:out value=&quot;${sessionScope.age}&quot;&gt;&lt;/c:out&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>运行结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/3.png" alt="">  </p>
<h3 id="3-4表达式控制标签——catch标签的使用"><a href="#3-4表达式控制标签——catch标签的使用" class="headerlink" title="3.4表达式控制标签——catch标签的使用"></a>3.4表达式控制标签——catch标签的使用</h3><h4 id="3-4-1-lt-c-catch-gt-标签的功能"><a href="#3-4-1-lt-c-catch-gt-标签的功能" class="headerlink" title="3.4.1&lt;c:catch&gt;标签的功能"></a>3.4.1<code>&lt;c:catch&gt;</code>标签的功能</h4><p><code>&lt;c:catch&gt;</code>标签用于捕获嵌套在标签体中的内容抛出的异常。  </p>
<h4 id="3-4-2-lt-c-catch-gt-标签的语法"><a href="#3-4-2-lt-c-catch-gt-标签的语法" class="headerlink" title="3.4.2&lt;c:catch&gt;标签的语法"></a>3.4.2<code>&lt;c:catch&gt;</code>标签的语法</h4><p>其语法格式如下：<code>&lt;c:catch [var=&quot;varName&quot;]&gt;容易产生异常的代码&lt;/c:catch&gt;</code> </p>
<p>var属性用于标识<code>&lt;c:catch&gt;</code>标签捕获的异常对象，它将保存在page这个Web域中。</p>
<h4 id="3-4-3-lt-c-catch-gt-标签的使用范例"><a href="#3-4-3-lt-c-catch-gt-标签的使用范例" class="headerlink" title="3.4.3&lt;c:catch&gt;标签的使用范例"></a>3.4.3<code>&lt;c:catch&gt;</code>标签的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;JSTL: --表达式控制标签“catch”标签实例&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h4&gt;catch标签实例&lt;/h4&gt;
    &lt;hr&gt;

    &lt;%--把容易产生异常的代码放在&lt;c:catch&gt;&lt;/c:catch&gt;中，自定义一个变量errorInfo用于存储异常信息 --%&gt;
    &lt;c:catch var=&quot;errorInfo&quot;&gt;
       &lt;%--实现了一段异常代码，向一个不存在的JavaBean中插入一个值--%&gt;
       &lt;c:set target=&quot;person&quot; property=&quot;hao&quot;&gt;&lt;/c:set&gt;
    &lt;/c:catch&gt;

    &lt;%--用EL表达式得到errorInfo的值，并使用&lt;c:out&gt;标签输出 --%&gt;
    异常：&lt;c:out value=&quot;${errorInfo}&quot; /&gt;&lt;br /&gt;
    异常 errorInfo.getMessage：&lt;c:out value=&quot;${errorInfo.message}&quot; /&gt;&lt;br /&gt;
    异常 errorInfo.getCause：&lt;c:out value=&quot;${errorInfo.cause}&quot; /&gt;&lt;br /&gt;
    异常 errorInfo.getStackTrace：&lt;c:out value=&quot;${errorInfo.stackTrace}&quot; /&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>运行结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/4.png" alt=""></p>
<h3 id="3-5流程控制标签——if标签使用总结"><a href="#3-5流程控制标签——if标签使用总结" class="headerlink" title="3.5流程控制标签——if标签使用总结"></a>3.5流程控制标签——if标签使用总结</h3><h4 id="3-5-1-lt-c-if-gt-标签的功能"><a href="#3-5-1-lt-c-if-gt-标签的功能" class="headerlink" title="3.5.1&lt;c:if&gt;标签的功能"></a>3.5.1<code>&lt;c:if&gt;</code>标签的功能</h4><p><code>&lt;c:if&gt;</code> 标签和程序中的if语句作用相同，用来实现条件控制。  </p>
<h4 id="3-5-2-lt-c-if-gt-标签的语法"><a href="#3-5-2-lt-c-if-gt-标签的语法" class="headerlink" title="3.5.2&lt;c:if&gt;标签的语法"></a>3.5.2<code>&lt;c:if&gt;</code>标签的语法</h4><ul>
<li>语法1:没有标签体内容:<code>&lt;c:if test=&quot;testCondition&quot; var=&quot;varName&quot; [scope=&quot;{page|request|session|application}&quot;]/&gt;</code></li>
<li>语法2: 有标签体内容。<code>&lt;c:if test=&quot;testCondition&quot; [var=&quot;varName&quot;] [scope=&quot;{page|request|session|application}&quot;]&gt;标签体内容。&lt;/c:if&gt;</code></li>
</ul>
<p>参数说明:  </p>
<ul>
<li>1）test属性用于存放判断的条件，一般使用EL表达式来编写。</li>
<li>2）var属性用来存放判断的结果，类型为true或false。</li>
<li>3）scopes属性用来指定var属性存放的范围。</li>
</ul>
<h4 id="3-5-3-lt-c-if-gt-标签的属性"><a href="#3-5-3-lt-c-if-gt-标签的属性" class="headerlink" title="3.5.3&lt;c:if&gt;标签的属性"></a>3.5.3<code>&lt;c:if&gt;</code>标签的属性</h4><table>
<thead>
<tr>
<th>属性名</th>
<th style="text-align:center">是否支持EL</th>
<th>属性类型</th>
<th>属性描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>test</td>
<td style="text-align:center">true</td>
<td>boolean</td>
<td>决定是否处理标签体中的内容的条件表达式</td>
</tr>
<tr>
<td>var</td>
<td style="text-align:center">false</td>
<td>String</td>
<td>用于指定将test属性的执行结果保存到某个Web域中的某个属性的名称</td>
</tr>
<tr>
<td>scope</td>
<td style="text-align:center">false</td>
<td>String</td>
<td>指定将test属性的执行结果保存到哪个Web域中</td>
</tr>
</tbody>
</table>
<h4 id="3-5-4-lt-c-if-gt-标签的使用范例"><a href="#3-5-4-lt-c-if-gt-标签的使用范例" class="headerlink" title="3.5.4&lt;c:if&gt;标签的使用范例"></a>3.5.4<code>&lt;c:if&gt;</code>标签的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;JSTL: --流程控制标签 if标签示例&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h4&gt;if标签示例&lt;/h4&gt;
    &lt;hr&gt;
    &lt;form action=&quot;JSTL_if_tag.jsp&quot; method=&quot;post&quot;&gt;
        &lt;input type=&quot;text&quot; name=&quot;uname&quot; value=&quot;${param.uname}&quot;&gt; 
        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
    &lt;/form&gt;

    &lt;%--使用if标签进行判断并把检验后的结果赋给adminchock，存储在默认的page范围中。 --%&gt;
    &lt;c:if test=&quot;${param.uname==&apos;admin&apos;}&quot; var=&quot;adminchock&quot;&gt;
    &lt;%--可以把adminchock的属性范围设置为session，这样就可以在其他的页面中得到adminchock的值，
使用&lt;c:if text=”${adminchock}”&gt;&lt;c:if&gt;判断，实现不同的权限。 --%&gt;
        &lt;c:out value=&quot;管理员欢迎您！&quot;/&gt;
    &lt;/c:if&gt;
    &lt;%--使用EL表达式得到adminchock的值，如果输入的用户名为admin将显示true。 --%&gt;
    ${adminchock}
&lt;/body&gt;
&lt;/html&gt;  
</code></pre><h3 id="3-6流程控制标签——choose标签、when标签、otherwise标签配合使用讲解"><a href="#3-6流程控制标签——choose标签、when标签、otherwise标签配合使用讲解" class="headerlink" title="3.6流程控制标签——choose标签、when标签、otherwise标签配合使用讲解"></a>3.6流程控制标签——choose标签、when标签、otherwise标签配合使用讲解</h3><h4 id="3-6-1-lt-c-choose-gt-、-lt-c-when-gt-和-lt-c-otherwise-gt-标签的功能"><a href="#3-6-1-lt-c-choose-gt-、-lt-c-when-gt-和-lt-c-otherwise-gt-标签的功能" class="headerlink" title="3.6.1&lt;c:choose&gt;、&lt;c:when&gt;和&lt;c:otherwise&gt;标签的功能"></a>3.6.1<code>&lt;c:choose&gt;</code>、<code>&lt;c:when&gt;</code>和<code>&lt;c:otherwise&gt;</code>标签的功能</h4><p><code>&lt;c:choose&gt;</code>、<code>&lt;c:when&gt;</code>和<code>&lt;c:otherwise&gt;</code>这3个标签通常情况下是一起使用的，<code>&lt;c:choose&gt;</code>标签作为<code>&lt;c:when&gt;</code>和<code>&lt;c:otherwise&gt;</code>标签的父标签来使用。  </p>
<p>使用<code>&lt;c:choose&gt;</code>，<code>&lt;c:when&gt;</code>和<code>&lt;c:otherwise&gt;</code>三个标签，可以构造类似 “if-else if-else” 的复杂条件判断结构。  </p>
<h4 id="3-6-2语法"><a href="#3-6-2语法" class="headerlink" title="3.6.2语法"></a>3.6.2语法</h4><pre><code>&lt;c:choose&gt;
     &lt;c:when test=&quot;条件1&quot;&gt;
             //业务逻辑1
     &lt;/c:when&gt;
     &lt;c:when test=&quot;条件2&quot;&gt;
             //业务逻辑2
     &lt;/c:when&gt;
     &lt;c:when test=&quot;条件n&quot;&gt;
             //业务逻辑n
     &lt;/c:when&gt;
     &lt;c:otherwise&gt;
             //业务逻辑
     &lt;/c:otherwise&gt;
&lt;/c:choose&gt;
</code></pre><h4 id="3-6-3使用范例"><a href="#3-6-3使用范例" class="headerlink" title="3.6.3使用范例"></a>3.6.3使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;JSTL: -- choose及其嵌套标签标签示例&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h4&gt;choose及其嵌套标签示例&lt;/h4&gt;
    &lt;hr/&gt;
    &lt;%--通过set标签设定score的值为85 --%&gt;
    &lt;c:set var=&quot;score&quot; value=&quot;85&quot;/&gt;

    &lt;c:choose&gt;

    &lt;%--使用&lt;c:when&gt;进行条件判断。
    如果大于等于90，输出“您的成绩为优秀”；
    如果大于等于70小于90，输出“您的成绩为良好”；
    大于等于60小于70，输出“您的成绩为及格”；
    其他（otherwise）输出“对不起，您没能通过考试”。
 --%&gt;

        &lt;c:when test=&quot;${score&gt;=90}&quot;&gt;
        你的成绩为优秀！
        &lt;/c:when&gt;

        &lt;c:when test=&quot;${score&gt;70 &amp;&amp; score&lt;90}&quot;&gt;
        您的成绩为良好!
        &lt;/c:when&gt;

        &lt;c:when test=&quot;${score&gt;60 &amp;&amp; score&lt;70}&quot;&gt;
        您的成绩为及格
        &lt;/c:when&gt;

        &lt;c:otherwise&gt;
        对不起，您没有通过考试！

        &lt;/c:otherwise&gt;
    &lt;/c:choose&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h3 id="3-7循环标签——forEach标签的使用"><a href="#3-7循环标签——forEach标签的使用" class="headerlink" title="3.7循环标签——forEach标签的使用"></a>3.7循环标签——forEach标签的使用</h3><h4 id="3-7-1-lt-c-forEach-gt-标签的功能"><a href="#3-7-1-lt-c-forEach-gt-标签的功能" class="headerlink" title="3.7.1&lt;c:forEach&gt;标签的功能"></a>3.7.1<code>&lt;c:forEach&gt;</code>标签的功能</h4><p>该标签根据循环条件遍历集合（Collection）中的元素。</p>
<h4 id="3-7-2-lt-c-forEach-gt-标签的语法"><a href="#3-7-2-lt-c-forEach-gt-标签的语法" class="headerlink" title="3.7.2&lt;c:forEach&gt;标签的语法"></a>3.7.2<code>&lt;c:forEach&gt;</code>标签的语法</h4><pre><code>&lt;c:forEach var=”name” items=”Collection” 
　　varStatus=”StatusName” begin=”begin” 
　　end=”end” step=”step”&gt;

    本体内容

&lt;/c:forEach&gt;
</code></pre><p>参数说明:  </p>
<ul>
<li>1）var设定变量名用于存储从集合中取出元素。</li>
<li>2）items指定要遍历的集合。</li>
<li>3）varStatus设定变量名，该变量用于存放集合中元素的信息。</li>
<li>4）begin、end用于指定遍历的起始位置和终止位置（可选）。</li>
<li>5）step指定循环的步长。</li>
</ul>
<h4 id="3-7-3-lt-c-forEach-gt-标签的属性"><a href="#3-7-3-lt-c-forEach-gt-标签的属性" class="headerlink" title="3.7.3&lt;c:forEach&gt;标签的属性"></a>3.7.3<code>&lt;c:forEach&gt;</code>标签的属性</h4><table>
<thead>
<tr>
<th>属性名</th>
<th style="text-align:center">是否支持EL</th>
<th>属性类型</th>
<th>是否必须</th>
<th>默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td>var</td>
<td style="text-align:center">false</td>
<td>String</td>
<td>yes</td>
<td>无</td>
</tr>
<tr>
<td>items</td>
<td style="text-align:center">true</td>
<td>Arrays Collection Iterator Enumeration Map String[]args</td>
<td>无</td>
</tr>
<tr>
<td>begin</td>
<td style="text-align:center">true</td>
<td>int</td>
<td>no</td>
<td>0</td>
</tr>
<tr>
<td>end</td>
<td style="text-align:center">true</td>
<td>int</td>
<td>no</td>
<td>集合中最后一个元素</td>
</tr>
<tr>
<td>step</td>
<td style="text-align:center">true</td>
<td>int</td>
<td>no</td>
<td>1</td>
</tr>
<tr>
<td>varStatus</td>
<td style="text-align:center">false</td>
<td>String</td>
<td>no</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>其中varStatus有4个状态属性，如下表所示:  </p>
<table>
<thead>
<tr>
<th>属性名</th>
<th style="text-align:center">类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>index</td>
<td style="text-align:center">int</td>
<td>当前循环的索引值</td>
</tr>
<tr>
<td>count</td>
<td style="text-align:center">int</td>
<td>循环的次数</td>
</tr>
<tr>
<td>first</td>
<td style="text-align:center">boolean</td>
<td>是否为第一个位置</td>
</tr>
<tr>
<td>last</td>
<td style="text-align:center">boolean</td>
<td>是否为最后一个位置</td>
</tr>
</tbody>
</table>
<h4 id="3-7-4-lt-c-forEach-gt-的使用范例"><a href="#3-7-4-lt-c-forEach-gt-的使用范例" class="headerlink" title="3.7.4&lt;c:forEach&gt;的使用范例"></a>3.7.4<code>&lt;c:forEach&gt;</code>的使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;JSTL: -- forEach标签实例&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;h4&gt;&lt;c:out value=&quot;forEach实例&quot;/&gt;&lt;/h4&gt;
    &lt;% 
       List&lt;String&gt;list = new ArrayList&lt;String&gt;(); 
       list.add(0, &quot;贝贝&quot;); 
       list.add(1, &quot;晶晶&quot;); 
       list.add(2, &quot;欢欢&quot;); 
       list.add(3, &quot;莹莹&quot;); 
       list.add(4, &quot;妮妮&quot;); 
       request.setAttribute(&quot;list&quot;, list); 
    %&gt;
    &lt;B&gt;&lt;c:out value=&quot;不指定begin和end的迭代：&quot; /&gt;&lt;/B&gt;&lt;br&gt;
    &lt;%--不使用begin和end的迭代，从集合的第一个元素开始，遍历到最后一个元素。 --%&gt;

    &lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot;&gt;
        &amp;nbsp;&lt;c:out value=&quot;${fuwa}&quot;/&gt;&lt;br/&gt;
    &lt;/c:forEach&gt;

    &lt;B&gt;&lt;c:out value=&quot;指定begin和end的迭代：&quot; /&gt;&lt;/B&gt;&lt;br&gt;
    &lt;%--指定begin的值为1、end的值为3、step的值为2，
    从第二个开始首先得到晶晶，每两个遍历一次，
    则下一个显示的结果为莹莹，end为3则遍历结束。 --%&gt;
    &lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot; begin=&quot;1&quot; end=&quot;3&quot; step=&quot;2&quot;&gt;
       &lt;c:out value=&quot;${fuwa}&quot;/&gt;&lt;br/&gt;
   &lt;/c:forEach&gt;

    &lt;B&gt;&lt;c:out value=&quot;输出整个迭代的信息：&quot; /&gt;&lt;/B&gt;&lt;br&gt;
        &lt;%--指定varStatus的属性名为s，并取出存储的状态信息 --%&gt;
        &lt;c:forEach var=&quot;fuwa&quot; items=&quot;${list}&quot; begin=&quot;3&quot; end=&quot;4&quot; varStatus=&quot;s&quot; step=&quot;1&quot;&gt;
             &lt;c:out value=&quot;${fuwa}&quot; /&gt;的四种属性：&lt;br&gt;

           所在位置，即索引：&lt;c:out value=&quot;${s.index}&quot; /&gt;&lt;br&gt;

             总共已迭代的次数：&lt;c:out value=&quot;${s.count}&quot; /&gt;&lt;br&gt;

             是否为第一个位置：&lt;c:out value=&quot;${s.first}&quot; /&gt;&lt;br&gt;

             是否为最后一个位置：&lt;c:out value=&quot;${s.last}&quot; /&gt;&lt;br&gt;  
        &lt;/c:forEach&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>运行结果如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/7.png" alt=""></p>
<h3 id="3-8URL操作标签——import标签的使用"><a href="#3-8URL操作标签——import标签的使用" class="headerlink" title="3.8URL操作标签——import标签的使用"></a>3.8URL操作标签——import标签的使用</h3><h4 id="3-8-1-lt-c-import-gt-标签的功能"><a href="#3-8-1-lt-c-import-gt-标签的功能" class="headerlink" title="3.8.1&lt;c:import&gt;标签的功能"></a>3.8.1<code>&lt;c:import&gt;</code>标签的功能</h4><p>该标签可以把其他静态或动态文件包含到本JSP页面，与<code>&lt;jsp:include&gt;</code>的区别为：<code>&lt;jsp:include&gt;</code>只能包含同一个web应用中的文件。而<code>&lt;c:import&gt;</code>可以包含其他web应用中的文件，甚至是网络上的资源。</p>
<h4 id="3-8-2-lt-c-import-gt-标签的语法"><a href="#3-8-2-lt-c-import-gt-标签的语法" class="headerlink" title="3.8.2&lt;c:import&gt;标签的语法"></a>3.8.2<code>&lt;c:import&gt;</code>标签的语法</h4><ul>
<li>语法1:<code>&lt;c:import url=”url” [context=”context”][value=”value”] [scope=”page|request|session|application”] [charEncoding=”encoding”]/&gt;</code></li>
<li>语法2:<code>&lt;c:import url=”url” varReader=”name” [context=”context”] [charEncoding=”encoding”]/&gt;</code></li>
</ul>
<p>参数说明:  </p>
<ul>
<li>1）URL为资源的路径，当引用的资源不存在时系统会抛出异常，因此该语句应该放在<code>&lt;c:catch&gt;&lt;/c:catch&gt;</code>语句块中捕获。</li>
<li>2）引用资源有两种方式：绝对路径和相对路径。  <blockquote>
<p>使用绝对路径的示例如下：<code>&lt;c:import url=”http://www.baidu.com”&gt;</code><br>使用相对路径的示例如下：<code>&lt;c:import url=”aa.txt”&gt;</code>，aa.txt放在同一文件目录。</p>
</blockquote>
</li>
<li>3）如果以“/”开头表示应用的根目录下。例如：tomcat应用程序的根目录文件夹为webapps。导入webapps下的文件bb.txt的编写方式为：<code>&lt;c:import url=”/bb.txt”&gt;</code></li>
<li>4）context属性用于在访问其他web应用的文件时，指定根目录。例如，访问root下的index.jsp的实现代码为：<code>&lt;c:import url=”/index.jsp” context=”/root”&gt;</code>。等同于webapps/root/index.jsp</li>
<li>5）var、scope、charEncoding、varReader是可选属性。</li>
</ul>
<h4 id="3-8-3-lt-c-import-gt-标签使用范例"><a href="#3-8-3-lt-c-import-gt-标签使用范例" class="headerlink" title="3.8.3&lt;c:import&gt;标签使用范例"></a>3.8.3<code>&lt;c:import&gt;</code>标签使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;
&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;JSTL: -- import标签实例&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;h4&gt;&lt;c:out value=&quot;import实例&quot;/&gt;&lt;/h4&gt;
    &lt;hr/&gt;
    &lt;h4&gt;&lt;c:out value=&quot;绝对路径引用的实例&quot; /&gt;&lt;/h4&gt;
    &lt;%--使用绝对路径导入百度首页,导入时使用&lt;c:catch&gt;&lt;/c:catch&gt;捕获异常。--%&gt;
        &lt;c:catch var=&quot;error1&quot;&gt;
            &lt;c:import url=&quot;http://wwww.baidu.com&quot; charEncoding=&quot;utf-8&quot;/&gt;
        &lt;/c:catch&gt;
            ${error1}
        &lt;hr/&gt;

     &lt;h4&gt;&lt;c:out value=&quot;相对路径引用本应用中的文件&quot; /&gt;&lt;/h4&gt;
     &lt;%--使用相对路径导入同一文件夹下的“JSTL的import标签使用说明”文件，接收的字符编码格式使用charEncoding设置为utf-8。 --%&gt;
         &lt;c:catch var=&quot;error2&quot;&gt;
             &lt;c:import url=&quot;JSTL的import标签使用说明&quot; charEncoding=&quot;utf-8&quot;/&gt;
         &lt;/c:catch&gt;
              ${error2}
         &lt;hr/&gt;

      &lt;h4&gt;&lt;c:out value=&quot;使用字符串输出相对路径引用的实例，并保存在session范围内&quot; /&gt;&lt;/h4&gt;
      &lt;%--导入“JSTL的import标签使用说明.txt”，使用var定义的变量接收要导入的文件，并存储在session中，
      如果在其他页面同样也要导入该文件，只须使用&lt;c:out&gt;输出“JSTL的import标签使用说明.txt”的值即可。--%&gt;
          &lt;c:catch var=&quot;error3&quot;&gt;
           &lt;c:import var=&quot;myurl&quot; url=&quot;JSTL的import标签使用说明&quot; scope=&quot;session&quot; charEncoding=&quot;utf-8&quot;/&gt;
               &lt;c:out value=&quot;${myurl}&quot;&gt;&lt;/c:out&gt;
           &lt;hr/&gt;
            &lt;c:out value=&quot;${myurl}&quot; /&gt;
          &lt;/c:catch&gt;
               ${error3}
       &lt;/body&gt;
    &lt;/html&gt;
</code></pre><h3 id="3-9URL操作符——url标签的使用"><a href="#3-9URL操作符——url标签的使用" class="headerlink" title="3.9URL操作符——url标签的使用"></a>3.9URL操作符——url标签的使用</h3><h4 id="3-9-1-lt-c-url-gt-标签的功能"><a href="#3-9-1-lt-c-url-gt-标签的功能" class="headerlink" title="3.9.1&lt;c:url&gt;标签的功能"></a>3.9.1<code>&lt;c:url&gt;</code>标签的功能</h4><p><c:url>标签用于在JSP页面中构造一个URL地址，其主要目的是实现URL重写。</c:url></p>
<h4 id="3-9-2-lt-c-url-gt-标签的语法"><a href="#3-9-2-lt-c-url-gt-标签的语法" class="headerlink" title="3.9.2&lt;c:url&gt;标签的语法"></a>3.9.2<code>&lt;c:url&gt;</code>标签的语法</h4><ul>
<li>语法1:指定一个url不做修改，可以选择把该url存储在JSP不同的范围中。<code>&lt;c:url value=”value” [var=”name”][scope=”page|request|session|application”] [context=”context”]/&gt;</code></li>
<li><p>语法2:配合 <code>&lt;c:param&gt;</code>标签给url加上指定参数及参数值，可以选择以name存储该url。</p>
<pre><code>&lt;c:url value=”value” [var=”name”] [scope=”page|request|session|application”] [context=”context”] 
    &lt;c:param name=”参数名” value=”值”&gt;
&lt;/c:url&gt;`
</code></pre></li>
</ul>
<h4 id="3-9-3-lt-c-url-gt-标签的主要属性"><a href="#3-9-3-lt-c-url-gt-标签的主要属性" class="headerlink" title="3.9.3&lt;c:url&gt;标签的主要属性"></a>3.9.3<code>&lt;c:url&gt;</code>标签的主要属性</h4><table>
<thead>
<tr>
<th>属性名</th>
<th style="text-align:center">是否支持EL</th>
<th>属性类型</th>
<th>属性描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td style="text-align:center">true</td>
<td>String</td>
<td>指定要构造的URL</td>
</tr>
<tr>
<td>var</td>
<td style="text-align:center">false</td>
<td>String</td>
<td>指定将构造出的URL结果保存到Web域中的属性名称</td>
</tr>
<tr>
<td>scope</td>
<td style="text-align:center">false</td>
<td>String</td>
<td>指定将构造出的URL结果保存到哪个Web域中</td>
</tr>
</tbody>
</table>
<h4 id="3-9-4-lt-c-url-gt-标签使用范例"><a href="#3-9-4-lt-c-url-gt-标签使用范例" class="headerlink" title="3.9.4&lt;c:url&gt;标签使用范例"></a>3.9.4<code>&lt;c:url&gt;</code>标签使用范例</h4><pre><code>&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;
&lt;%--引入JSTL核心标签库 --%&gt;
&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot;%&gt;

&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;JSTL: -- url标签实例&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;c:out value=&quot;url标签使用&quot;&gt;&lt;/c:out&gt;
    &lt;h4&gt;使用url标签生成一个动态的url，并把值存入session中.&lt;/h4&gt;
    &lt;hr/&gt;
    &lt;c:url value=&quot;http://www.baidu.com&quot; var=&quot;url&quot; scope=&quot;session&quot;&gt;
    &lt;/c:url&gt;
    &lt;a href=&quot;${url}&quot;&gt;百度首页(不带参数)&lt;/a&gt;
    &lt;hr/&gt;
    &lt;h4&gt;
    配合 &amp;lt;c:param&amp;gt;标签给url加上指定参数及参数值，生成一个动态的url然后存储到paramUrl变量中
    &lt;/h4&gt;
    &lt;c:url value=&quot;http://www.baidu.com&quot; var=&quot;paramUrl&quot;&gt;
        &lt;c:param name=&quot;userName&quot; value=&quot;codingxiaxw&quot;/&gt;
        &lt;c:param name=&quot;pwd&quot;&gt;123456&lt;/c:param&gt;
    &lt;/c:url&gt;
    &lt;a href=&quot;${paramUrl}&quot;&gt;百度首页(带参数)&lt;/a&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p><strong>说明:</strong> 此博客参考大神博客<a href="http://www.cnblogs.com/xdp-gacl/p/3943390.html" target="_blank" rel="external">孤傲苍狼</a></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[玩转AJAX]]></title>
      <url>http://codingxiaxw.cn/2016/10/28/28-AJAX%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>客户端向服务器发送请求，若服务器每次响应过来的结果都要重新加载整个界面的话这样会给服务器带来很大的压力。所以ajax出现了，它是在不重新加载整个页面的情况下与服务器交换数据并更新部分网页的技术，是一种使用现有标准的新方法。  </p>
<a id="more"></a>
<h2 id="AJAX是什么"><a href="#AJAX是什么" class="headerlink" title="AJAX是什么"></a>AJAX是什么</h2><p>1.asynchronous javascript and xml，翻译过来就是异步的js和xml。2.它能使用js语言访问服务器，而且是异步访问。3.服务器给客户端的响应一般是整个页面，一个html完整页面但在ajax中因为是局部刷新，那么服务器就不用再响应整个页面而只是响应局部。  </p>
<h2 id="服务器向客户端返回的数据类型"><a href="#服务器向客户端返回的数据类型" class="headerlink" title="服务器向客户端返回的数据类型"></a>服务器向客户端返回的数据类型</h2><p>一般客户端向服务器发送请求，服务器返回的数据类型有三种:  </p>
<ul>
<li>1.text类型:返回的数据是纯文本。</li>
<li>2.xml类型:返回的数据是xml格式，它是提供js和java交互的数据格式</li>
<li>3.json类型:它也是提供js和java交互的数据格式，在ajax中最受欢迎。</li>
</ul>
<h2 id="理解同步交互和异步交互"><a href="#理解同步交互和异步交互" class="headerlink" title="理解同步交互和异步交互"></a>理解同步交互和异步交互</h2><ul>
<li>同步交互:<ul>
<li>1.发一个请求，就要等待服务器的响应结束，然后才能发送第二个请求。</li>
<li>2刷新的是整个页面。</li>
</ul>
</li>
<li>异步交互:<ul>
<li>1.发一个请求，无需等待服务器的响应，然后就可以发第二个请求。</li>
<li>2.可以使用js来接受服务器的响应，然后使用js来局部刷新界面。</li>
</ul>
</li>
</ul>
<p>附上uml图解释这两者的区别:<br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax.png" alt=""></p>
<h2 id="ajax常见应用情景"><a href="#ajax常见应用情景" class="headerlink" title="ajax常见应用情景"></a>ajax常见应用情景</h2><ul>
<li>1.搜索引擎:在搜索引擎中输入关键字，会出现一个下拉框，列出网络上与关键字相关的字眼。</li>
<li>2.注册:注册页面上填写完用户名后移开光标，会显示该用户名是否已被注册。</li>
<li>3.淘宝某个店铺下方的评论框:翻页时的异步操作。</li>
</ul>
<h2 id="ajax的优缺点"><a href="#ajax的优缺点" class="headerlink" title="ajax的优缺点"></a>ajax的优缺点</h2><ul>
<li>优点:<ul>
<li>异步交互，增强了用户的体验。</li>
<li>性能:因为服务器无需再响应整个页面，只需要响应部分内容，所以服务器的压力减轻了。</li>
</ul>
</li>
<li>缺点:<ul>
<li>ajax不能应用在所有场景</li>
<li>ajax无端的增多了对服务器的访问次数，给服务器带来了压力(比较上述优点，在减少了服务器压力的同时又给服务器带来了压力，不知你理不理解哈哈)</li>
</ul>
</li>
</ul>
<h2 id="如何使用ajax来发送异步请求"><a href="#如何使用ajax来发送异步请求" class="headerlink" title="如何使用ajax来发送异步请求"></a>如何使用ajax来发送异步请求</h2><h3 id="第一步-首先要得到XMLHttpRequest"><a href="#第一步-首先要得到XMLHttpRequest" class="headerlink" title="第一步(首先要得到XMLHttpRequest)"></a>第一步(首先要得到XMLHttpRequest)</h3><p>大多数浏览器都只是得到该对象的方法为:<code>var xmlHttp=new XMLHttpRequest();</code>  </p>
<p>IE6.0得到的方法为:<code>var xmlHttp = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);</code>  </p>
<p>IE5.0以及更早版本的IE:<code>var xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);</code></p>
<p>在<code>&lt;script&gt;</code>中编写创建XMLHttpRequest对象的函数:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createXMLHttpRequest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(“Msxml2.XMLHTTP”);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">				<span class="keyword">try</span>&#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(“Microsoft.XMLHTTP”);</span><br><span class="line">				&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">					alert(“哥们，你用的是什么浏览器啊”);</span><br><span class="line">					<span class="keyword">throw</span> e;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="第二步-打开与服务器的连接"><a href="#第二步-打开与服务器的连接" class="headerlink" title="第二步(打开与服务器的连接)"></a>第二步(打开与服务器的连接)</h3><p><code>xmlHttp.open(&quot;&quot;,&quot;&quot;,boolean):</code>用来打开与服务器的连接，它需要三个参数。1.请求参数，可以是get可以是post。2.请求的url:指定服务器端资源。3.请求是否异步，如果为true表示发送异步请求，否则发送同步请求。例如xmlHttp.open(“GET”,”项目名称/AServlet”,true);</p>
<h3 id="第三步-发送请求"><a href="#第三步-发送请求" class="headerlink" title="第三步(发送请求)"></a>第三步(发送请求)</h3><p>xmlHttp.send(参数):参数为请求体内容。如果请求方式是get，则参数为null(不可以省略null)，因为get请求方式的请求体为空;如果请求方式为post，则参数为请求体，另外还需要在此方法前面增加一个<code>mlHttp.setRequestHeader(“Content-Type”,”application/x-www-form-urlencoded”);</code>设置请求头的方法。</p>
<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>给xmlHttp对象注册onreadystatechange监听器，这个方法用于接收从服务器发送过来的响应数据。 在该方法中需要做以下步骤: </p>
<p>1.获取xmlHttp对象的状态，xmlHttp对象一共有5个状态:  </p>
<ul>
<li>0状态:表示xmlHttp对象刚创建，还没有调用open()方法。</li>
<li>1状态：请求开始，调用了open方法，但还没有调用send方法</li>
<li>2状态：调用完了send方法</li>
<li>3状态：服务器已经开始响应，但不表示响应结束了。</li>
<li>4状态：服务器响应结束(通常我们只关心这个状态)</li>
</ul>
<p>该状态通过调用xmlHttp.readyState得到。  </p>
<p>2.得到服务器响应的状态码:通过调用xmlHttp.status得到，例如200，404，500。  </p>
<p>3.得到服务器响应的内容，由于服务器返回的类型不同，所以得到的内容类型也不同，以下3种类型采用3种方法得到: </p>
<ul>
<li><code>var content=xmlHttp.responseText;</code>//服务器返回的文本为text。</li>
<li><code>var content=xmlHttp.responseXML;</code>//服务器响应的文本为xml内容。xmlHttp会自动对xml文本进行解析，得到的content为document对象。</li>
<li><code>var content=eval(&quot;(&quot;+xmlHttp.responsetext+&quot;)&quot;);</code>//服务器返回的文本为json数据。  </li>
</ul>
<p>完成第四步我们需要写的完整代码为:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//xmlHttp的5种状态都会调用本方法</span></span><br><span class="line">	<span class="keyword">if</span>(xmlHttp.readState==<span class="number">4</span>&amp;&amp;xmlHttp.status==<span class="number">200</span>)&#123;<span class="comment">//双重判断:判断是否为4状态，而且还要判断是否为200</span></span><br><span class="line">		<span class="comment">//获取服务器的响应内容</span></span><br><span class="line">		<span class="keyword">var</span> content=xmlHttp.responseText;<span class="comment">//或var content= xmlHttp.responseXML;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="案例-省市联动"><a href="#案例-省市联动" class="headerlink" title="案例:省市联动"></a>案例:省市联动</h2><p>说明，该案例就是在网页上显示两个下拉列表，一个列表用于显示中国所有的省份，一个列表用于显示相应省份下的城市，当然这些数据是存在数据库中的，为了方便展示，我只在数据库中列举了两个省份和部分城市。</p>
<p>domain包下的city.java和province.java代码如下:   </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/province.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/city.png" alt=""></p>
<p>servlet包下的CityServlet.java与ProvinceServlet.java，用于向客户端发送响应数据代码如下:   </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/cityservlet.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/provinceservlet.png" alt=""></p>
<p>dao包下的ProvinceDao.java代码如下:用于与数据库连接:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/provincedao.png" alt=""></p>
<p>最终要的界面代码关于ajax的操作,代码如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/ajax1.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax2.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/ajax3.png" alt=""></p>
<p>数据库中的表有两张，一张是省份表province,一张是城市表city,如下:   </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/city2.png" alt=""><br><img src="http://od2xrf8gr.bkt.clouddn.com/province2.png" alt=""></p>
<p>结果如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/jiemian.png" alt=""></p>
<p>当选择了相应的省份时，ajax会立即向服务器发送请求，然后服务器返回该省份下所有的城市，ajax将这些城市动态的显示在”请选择城市”列表中。达到部分刷新界面的效果。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb三大组件之过滤器(Filter)]]></title>
      <url>http://codingxiaxw.cn/2016/10/27/27-JavaWeb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E8%BF%87%E6%BB%A4%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>过滤器可以动态的拦截请求和响应，以变换或使用包含在请求或响应中的信息。  </p>
<p>过滤器是可用于Servlet编程的Java类，可以实现以下目的:  </p>
<ul>
<li>在客户端的请求访问后端资源之前，拦截这些请求。</li>
<li>在服务器的响应发送回客户端之前，处理这些响应。</li>
</ul>
<a id="more"></a>
<p>过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到你的应用程序的部署描述符中的 Servlet 名称或 URL 模式。  </p>
<p>当 Web 容器启动 Web 应用程序时，它会为你在部署描述符中声明的每一个过滤器创建一个实例。  </p>
<p>Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。  </p>
<h2 id="1-编写过滤器"><a href="#1-编写过滤器" class="headerlink" title="1.编写过滤器"></a>1.编写过滤器</h2><p>如何编写过滤器?  </p>
<ol>
<li>创建一个类，必须实现Filter接口</li>
<li>在web.xml中进行配置，一般把Filter配置在所有的Servlet配置之前  </li>
</ol>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/filter.png" alt=""></p>
<p>方法介绍:   </p>
<ul>
<li><strong>void init():</strong>Filter的初始化，Filter在服务器启动时就创建，创建之后马上执行这个方法。用来初始化一些参数</li>
<li><strong>void doFilter(req,resp,chain):</strong>当向服务器请求的Servlet或jsp页面在过滤器的过滤范围内时就会执行这个方法。若方法体中没有chain.doFilter()操作，则表示当向服务器请求该过滤器过滤范围内的资源(如Servlet/JSP页面/html页面等)时，这些资源中的所有方法都不会执行(被过滤掉了);若方法体中有chain.doFilter()操作，表示不对过滤器过滤范围内的资源进行过滤。(即你请求的资源下的方法会执行)</li>
<li><strong>void destroy():</strong>在服务器关闭时对Filter进行销毁，在Filter销毁之前会执行这个方法，用来对非内存资源进行释放。</li>
</ul>
<p>对方法中设计到的类介绍:  </p>
<ul>
<li><strong>FilterConfig:</strong>与ServletConfig相似，该类有如下四个方法:  <ul>
<li><strong>getInitParameter():</strong>获取初始化参数。</li>
<li><strong>getInitParameterNames():</strong>获取所有初始化参数的名称。</li>
<li><strong>getFilterName():</strong>获取过滤器的配置名称。</li>
<li><strong>getServletContext():</strong>获取application。</li>
</ul>
</li>
<li><strong>FilterChain类:</strong>该类中有一个方法:  <ul>
<li><strong>doFilter():</strong>是不是会觉得该方法与Filter接口中的doFilter()方法是一样的呢？没错，二者虽然外观看起来一样，但功能却是千差万别的。该方法被FilterChain对象调用，表示对Filter过滤器过滤范围下的资源进行放行。</li>
</ul>
</li>
</ul>
<h2 id="2-多过滤器的执行顺序"><a href="#2-多过滤器的执行顺序" class="headerlink" title="2.多过滤器的执行顺序"></a>2.多过滤器的执行顺序</h2><p>Web应用程序可以根据特定的目的定义若干个不同的过滤器，那么就需要在web.xml中对多个过滤器进行多个配置。而在web.xml中使用<code>&lt;filter-mapping&gt;</code>来控制多个过滤器的执行顺序，即哪个过滤器的<code>&lt;filter-mapping&gt;</code>配置在web.xml中的顺序排在前面那这个过滤器就先执行。  </p>
<h2 id="3-过滤器的四种拦截方式"><a href="#3-过滤器的四种拦截方式" class="headerlink" title="3.过滤器的四种拦截方式"></a>3.过滤器的四种拦截方式</h2><ul>
<li>1.拦截直接请求方式:REQUEST</li>
<li>2.拦截请求转发方式:FORWARD</li>
<li>3.拦截请求包含方式:INCLUDE</li>
<li>4.拦截错误转发方式:ERROR</li>
</ul>
<p>实现不同的拦截方式需要在<filter-mapping>中进行不同的配置:  </filter-mapping></p>
<ul>
<li><code>&lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;</code></li>
<li><code>&lt;dispatcher&gt;FORWORD&lt;/dispatcher&gt;</code></li>
<li><code>&lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;</code></li>
<li><code>&lt;dispatcher&gt;ERROR&lt;/dispatcher&gt;</code></li>
</ul>
<p>若在web.xml配置文件中没有写出上面四个拦截配置时默认该过滤器只拦截请求。  </p>
<h2 id="4-过滤器的应用场景"><a href="#4-过滤器的应用场景" class="headerlink" title="4.过滤器的应用场景"></a>4.过滤器的应用场景</h2><p>1.执行目标资源之前做”预处理”工作，例如设置编码，这种通常都会放行，只是在目标资源执行之前做一些准备工作。(例如：几乎是所有的Servlet中都需要写<code>request.setCharacteEncoding()</code>,可以把它放入到一个Filter中。）这种过滤器没有拦截功能。  </p>
<p>2.通过条件判断是否放行，例如校验当前用户是否已经登录，或者用户IP是否已经被禁用。(有拦截操作) (粗粒度权限控制，会员有会员的权利、游客有游客的权利) </p>
<p>3.在目标资源执行后，做一些后续的特殊处理工作。例如把目标资源输出的数据进行处理。</p>
<h2 id="5-案例1-分IP统计网站的访问次数"><a href="#5-案例1-分IP统计网站的访问次数" class="headerlink" title="5.案例1:分IP统计网站的访问次数"></a>5.案例1:分IP统计网站的访问次数</h2><p>功能分析:1.统计工作需要在所有资源之前都执行，那么就可以放到Filter中了。2.我们这个过滤器不打算做拦截操作，因为我们只是用来做统计的。3.用什么东西来装载统计的数据。Map<string ,integer="">，整个网站只需要一个Map即可4.Map什么时候创建(使用ServletContextListener，在服务器启动时完成创建，并保存到SevletContext中)，Map保存到哪里:Map需要在Filter中用来保存数据;Map需要在页面使用，打印Map中的数据。  </string></p>
<p>AListener.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/AListener.png" alt="">  </p>
<p>AFilter.java:<br><img src="http://od2xrf8gr.bkt.clouddn.com/AFilter.png" alt="">  </p>
<p>show.jsp:<br><img src="http://od2xrf8gr.bkt.clouddn.com/showjsp.png" alt="">  </p>
<p>效果图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/xiaoguo.png" alt=""></p>
<h2 id="6-案例2-解决全站字符乱码问题"><a href="#6-案例2-解决全站字符乱码问题" class="headerlink" title="6.案例2:解决全站字符乱码问题"></a>6.案例2:解决全站字符乱码问题</h2><p>一般我们通过jsp页面请求转发到servlet时，若请求方式为POST且请求参数包含中文参数时，我们需要在servlet的doPost()方法中设置POST请求编码问题:<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code>、设置响应编码问题:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code>,这样便可以解决post请求即响应编码问题；而对于GET请求，若传递的请求参数包含中文参数时设置请求编码就比较麻烦，需要在servlet的doGet()方法中设置响应编码:<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code>以及请求编码:<code>首先获得传递给servlet的请求参数:String username=request.getParameter(&quot;username&quot;)</code>假设传递的请求参数为<code>username</code>,然后再输入代码<code>username=new String(username.getBytes(&quot;ISO8859-1&quot;),&quot;utf-8&quot;);</code>，这样通过jsp页面转发到servlet的参数便解决了编码问题。即可以通过<code>response.getWrite().prinltn(username)</code>正常显示在网页上。  </p>
<p>试想:以后的开发中往往会用到很多的servlet，那我们岂不是要在每一个servlet的doPost()和doGet方法中都写上上述的解决编码代码？这时候我们就可以通过过滤器来解决了。  </p>
<p>首先附上页面:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%@taglib</span> <span class="attr">prefix</span>=<span class="string">"c"</span> <span class="attr">uri</span>=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">AServlet</span>?<span class="attr">username</span>=<span class="string">张三</span>"/&gt;</span> "&gt;点击这里<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"&lt;c:url value="</span>/<span class="attr">AServlet</span>"/&gt;</span> " method="post"&gt;</span><br><span class="line">    用户名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"李四"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>显示在网页上的界面为:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-11-16%20%E4%B8%8B%E5%8D%885.35.05.png" alt="">  </p>
<p>通过”点击这里”的链接我们便完成了通过jsp页面向servlet发送GET请求参数，通过”提交”按钮我们便完成了通过jsp页面向servlet发送POST请求参数。创建一个servlet,我们在servlet中完成响应参数编码的问题:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        response.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来在过滤器中完成请求参数编码的问题，创建一个过滤器Filter，在web.xml中注册:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>filter.Filter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>Filter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Filter中编码为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Filter</span> <span class="keyword">implements</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于POST请求参数的编码设置我们直接在doFilter()方法体中添加<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code>代码即可(此时运行程序，POST请求参数编码的问题成功解决)，对于GET请求参数的编码，有些同学会觉得直接在doFilter()方法体中添加<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String  username=request.getParameter(<span class="string">"username"</span>);username=<span class="keyword">new</span> String(username.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure></p>
<p>即可。这样的参数是不太靠谱的，因为这里我们知道要传递的请求参数为username所以这里可以明了的指出，以后我们不知道请求参数为什么或者请求参数有很多时那就需要更多的上诉代码，所以这里我们采用装饰者模式对request进行装饰(即将本来的request换成我们自己写的request)，创建一个EncodingRequest.java继承HttpServletRequestWrapper,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpServletRequest req;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EncodingRequest</span><span class="params">(HttpServletRequest request)</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(request);</span><br><span class="line">        <span class="keyword">this</span>.req=request;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        String value=req.getParameter(name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理编码问题</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value=<span class="keyword">new</span> String(value.getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造方法中，我们传入系统的request,然后将这个request赋值给我们自己编写的req,然后在重写的getParameter()方法中通过我们自己写的req获取请求参数并解决编码问题，然后返回解决完编码后的参数value(此时这个中文参数已解决编码),然后在Filer中对我们自己编写的request(即Encodingquest对象)放行即可。现在doFilter()方法的方法体为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//处理post请求编码问题</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        HttpServletRequest req= (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 处理get请求的编码问题</span><br><span class="line">         */</span></span><br><span class="line"><span class="comment">//        String username=request.getParameter("username");</span></span><br><span class="line"><span class="comment">//        username=new String(username.getBytes("ISO-8859-1"),"utf-8");</span></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 调包request</span><br><span class="line">         * 1.写一个request的装饰类</span><br><span class="line">         * 2.在放行时，使用我们自己的request</span><br><span class="line">         */</span></span><br><span class="line"></span><br><span class="line">            EncodingRequest er = <span class="keyword">new</span> EncodingRequest(req);</span><br><span class="line">            chain.doFilter(er, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行程序，成功解决GET请求方式的编码问题，但是POST请求方式的编码又出现了问题，这是为什么呢？因为我们在doFilter方法中已经通过代码<code>request.setCharacterEncoding(&quot;utf-8&quot;);</code>处理了POST请求方式的编码问题，但是此时的请求是系统的request对象而不是我们自己写的req，我们对req进行了放行而没有对request进行方式，所以方法体中应该增加if判断语句，改正后的doFilter()方法体内容为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理post请求编码问题</span></span><br><span class="line">        request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line">        HttpServletRequest req= (HttpServletRequest) request;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 处理get请求的编码问题</span><br><span class="line">         */</span></span><br><span class="line"><span class="comment">//        String username=request.getParameter("username");</span></span><br><span class="line"><span class="comment">//        username=new String(username.getBytes("ISO-8859-1"),"utf-8");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 调包request</span><br><span class="line">         * 1.写一个request的装饰类</span><br><span class="line">         * 2.在放行时，使用我们自己的request</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">if</span> (req.getMethod().equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">            EncodingRequest er = <span class="keyword">new</span> EncodingRequest(req);</span><br><span class="line"></span><br><span class="line">            chain.doFilter(er, response);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (req.getMethod().equals(<span class="string">"POST"</span>))&#123;</span><br><span class="line">            chain.doFilter(request, response);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>此时运行程序，成功解决POST请求方式和GET请求方式的编码问题。在学习框架之前我们都这样通过Filter解决编码问题，而当我们学习了Spring MVC框架后我们处理POST请求参数的编码问题时直接在web.xml中添加如下配置而不用再写一个过滤器:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>解决GET请求方式的编码问题时有两种解决方法:1.修改tomcat配置文件添加编码与工程编码一致，如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">URIEncoding</span>=<span class="string">"utf-8"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>2.对参数进行重新编码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String userName new </span><br><span class="line"><span class="title">String</span><span class="params">(request.getParamter(<span class="string">"userName"</span>)</span>.<span class="title">getBytes</span><span class="params">(<span class="string">"ISO8859-1"</span>)</span>,"utf-8")</span></span><br></pre></td></tr></table></figure></p>
<p>第二种方法需要对每个参数都进行重新编码，比较麻烦。  </p>
<p>回归我们的过滤器讲解，通过如上包装request的方式便可以通过过滤器解决全站编码问题。</p>
<p>源码请<a href="https://github.com/codingXiaxw/filter" target="_blank" rel="external">点击这里前往我的github</a></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="7-联系"><a href="#7-联系" class="headerlink" title="7.联系"></a>7.联系</h2><p>If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb三大组件之监听器(Listener)]]></title>
      <url>http://codingxiaxw.cn/2016/10/26/26-JavaWeb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%B9%8B%E7%9B%91%E5%90%AC%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>监听器是一个专门用于对其他对象身上发生的事件或状态改变进行监听和相应处理的对象，当被监视的对象发生情况时，立即采取相应的行动。监听器其实就是一个实现特定接口的普通java程序，这个程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法立即被执行。<br><a id="more"></a></p>
<p>上述概念设计到3个名词概念:</p>
<ul>
<li>1.事件源:即谁产生的事件</li>
<li>2.事件对象:即产生了什么事件</li>
<li>3.监听器:监听事件源的动作</li>
</ul>
<p>由于事件源可以产生多个动作(即产生多个事件)，而监听器中的每一个方法监听一个动作，故每个监听器中都有很多方法。</p>
<h2 id="1-JavaWeb中的监听器"><a href="#1-JavaWeb中的监听器" class="headerlink" title="1.JavaWeb中的监听器"></a>1.JavaWeb中的监听器</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h3><p>JavaWeb中的监听器是Servlet规范中定义的一种特殊类，它用于监听web应用程序中的ServletContext、HttpSession和 ServletRequest这三大域对象的创建、销毁事件以及监听这些域对象中的属性发生修改的事件。</p>
<h3 id="1-2JavaWeb中监听器的分类"><a href="#1-2JavaWeb中监听器的分类" class="headerlink" title="1.2JavaWeb中监听器的分类"></a>1.2JavaWeb中监听器的分类</h3><p>在Servlet规范中定义了多种类型的监听器(一共8个监听器)，它们用于监听的事件源分别为ServletContext，HttpSession和ServletRequest这三个域对象。Servlet规范针对这三个对象上的操作，又把多种类型的监听器划分为三种类型：  </p>
<ul>
<li>1.域对象的生命周期监听:监听域对象自身的创建和销毁。这个监听器需要实现相应的监听器接口:ServletContextListener、HttpSessionListener、ServletRequestListener。</li>
<li>2.域对象的属性监听:监听域对象中属性的增加和删除。这个监听器需要实现的监听器接口为:ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener</li>
<li>3.感知监听(都与HttpSession域对象有关):监听绑定到HttpSession域中的某个JavaBean对象的状态的监听器。这个监听器需要实现的监听器接口:HttpSessionBindingListener、HttpSessionActiveationListener.</li>
</ul>
<h3 id="1-3第一类-域对象的生命周期监听"><a href="#1-3第一类-域对象的生命周期监听" class="headerlink" title="1.3第一类:域对象的生命周期监听"></a>1.3第一类:域对象的生命周期监听</h3><p>事件源为:三大域<br>事件对象为:创建与销毁<br>监听器为:实现了ServletContextListener、HttpSessionListener、ServletRequestListener这三个接口的监听器  </p>
<h4 id="1-3-1ServletContext的生命周期监听"><a href="#1-3-1ServletContext的生命周期监听" class="headerlink" title="1.3.1ServletContext的生命周期监听"></a>1.3.1ServletContext的生命周期监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AListener</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">  	<span class="comment">//在项目启动时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">  	<span class="comment">//在项目关闭时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在web.xml文件中对该监听器进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt=""></p>
<h4 id="1-3-2HttpSession的生命周期监听"><a href="#1-3-2HttpSession的生命周期监听" class="headerlink" title="1.3.2HttpSession的生命周期监听"></a>1.3.2HttpSession的生命周期监听</h4><p>代码同上述基本一致:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent sce)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">  	<span class="comment">//在会话产生时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent sce)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line"> 	 <span class="comment">//在会话关闭时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样需要在web.xml文件中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt=""></p>
<h4 id="1-3-3ServletRequest的生命周期"><a href="#1-3-3ServletRequest的生命周期" class="headerlink" title="1.3.3ServletRequest的生命周期"></a>1.3.3ServletRequest的生命周期</h4><p>代码同上述基本一致:  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rquestInitialized</span><span class="params">(ServletRequestEvent sce)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">  	<span class="comment">//在请求产生时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sce)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">  	<span class="comment">//在请求关闭时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样需要在web.xml文件中进行配置:<br><img src="http://od2xrf8gr.bkt.clouddn.com/alistern.png" alt="">  </p>
<h4 id="1-3-4对各个监听器接口的方法中出现的类介绍"><a href="#1-3-4对各个监听器接口的方法中出现的类介绍" class="headerlink" title="1.3.4对各个监听器接口的方法中出现的类介绍"></a>1.3.4对各个监听器接口的方法中出现的类介绍</h4><p>ServletContextEvent类:类中有一个方法getServletContext(),该方法返回ServletContext对象。</p>
<p>HttpSessionEvent类:类中有一个方法getSession()，该方法返回一个HttpSession对象。  </p>
<p>ServletRequestEvent类:类中有两个方法，getServletContext()用于返回一个ServletContext对象，getServletRequest()用于返回一个ServletRequest对象。</p>
<h3 id="1-4第二类-域对象的属性监听"><a href="#1-4第二类-域对象的属性监听" class="headerlink" title="1.4第二类:域对象的属性监听"></a>1.4第二类:域对象的属性监听</h3><p>事件源:三大域<br>事件对象:属性的增加与删除<br>监听器:实现了ServletContextAttributeListener、HttpSessionAttributeListener、ServletRequestAttributeListener接口的监听器  </p>
<h4 id="1-4-1ServletContext的属性监听"><a href="#1-4-1ServletContext的属性监听" class="headerlink" title="1.4.1ServletContext的属性监听"></a>1.4.1ServletContext的属性监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AListener</span> <span class="keyword">implements</span> <span class="title">ServletContextAttributeListener</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletcontextAttribute scab)</span></span>&#123;</span><br><span class="line">  	<span class="comment">//给ServletContext对象添加属性时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletContextAttributeEvent scab)</span></span>&#123;</span><br><span class="line">	<span class="comment">//给ServletContext对象删除属性时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletContextAttributeEvent scab)</span></span>&#123;</span><br><span class="line">	<span class="comment">//给ServletContext对象替换属性值时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样需要在web.xml文件中对AListener进行配置。</p>
<h4 id="1-4-2HttpSession的属性监听"><a href="#1-4-2HttpSession的属性监听" class="headerlink" title="1.4.2HttpSession的属性监听"></a>1.4.2HttpSession的属性监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionAttributeListener</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(HttpSessionAttribute scab)</span></span>&#123;</span><br><span class="line">  	<span class="comment">//给HttpSession对象添加属性时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(HttpSessionAttributeEvent scab)</span></span>&#123;</span><br><span class="line">	<span class="comment">//给HttpSession对象删除属性时调用</span></span><br><span class="line">	&#125;	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(HttpSessionAttributeEvent scab)</span></span>&#123;</span><br><span class="line">	<span class="comment">//给HttpSession对象替换属性值时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样需要在web.xml中对AListener进行配置。</p>
<h4 id="1-4-3ServletRequest的属性监听"><a href="#1-4-3ServletRequest的属性监听" class="headerlink" title="1.4.3ServletRequest的属性监听"></a>1.4.3ServletRequest的属性监听</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestAttributeListener</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeAdded</span><span class="params">(ServletRequestAttribute scab)</span></span>&#123;</span><br><span class="line">  	<span class="comment">//给ServletRequest对象添加属性时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeRemoved</span><span class="params">(ServletRequestAttributeEvent scab)</span></span>&#123;</span><br><span class="line">	<span class="comment">//给ServletRequest对象删除属性时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attributeReplaced</span><span class="params">(ServletRequestAttributeEvent scab)</span></span>&#123;</span><br><span class="line">	<span class="comment">//给ServletRequest对象替换属性值时调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样需要在web.xml中对AListener进行配置。</p>
<h4 id="1-4-4对各个监听器接口的方法中出现的类介绍"><a href="#1-4-4对各个监听器接口的方法中出现的类介绍" class="headerlink" title="1.4.4对各个监听器接口的方法中出现的类介绍"></a>1.4.4对各个监听器接口的方法中出现的类介绍</h4><p>ServletContextAttributeEvent类:该类对象有三个方法，getSevletContext()用于返回一个ServletContext，getName()用于返回属性名，getValue()用于返回属性值。  </p>
<p>HttpSessionBindingEvent类:该类对象有两个方法，getName()用于获取属性名，getValue()用于获取属性值。  </p>
<p>ServletRequestAttributeEvent类:该类对象有两个方法，getName()用于获取属性名，getValue()用于获取属性值。  </p>
<h3 id="1-5感知监听器"><a href="#1-5感知监听器" class="headerlink" title="1.5感知监听器"></a>1.5感知监听器</h3><p>保存在Session域中的对象可以有多种状态：绑定(session.setAttribute(“bean”,Object))到Session中,随Session对象持久化到一个存储设备中；从Session域中解除(session.removeAttribute(“bean”))绑定,随Session对象从一个存储设备中恢复。  </p>
<p>Servlet 规范中定义了两个特殊的监听器接口”HttpSessionBindingListener和HttpSessionActivationListener”来帮助JavaBean 对象了解自己在Session域中的这些状态，实现这两个接口的类不需要 web.xml 文件中进行注册。  </p>
<h4 id="1-5-1HttpSessionBindingListener接口"><a href="#1-5-1HttpSessionBindingListener接口" class="headerlink" title="1.5.1HttpSessionBindingListener接口"></a>1.5.1HttpSessionBindingListener接口</h4><p>实现了HttpSessionBindingListener接口的JavaBean对象可以感知自己被绑定到Session中和 Session中删除的事件。  </p>
<p>当对象被绑定到HttpSession对象中时，web服务器调用该对象的void valueBound(HttpSessionBindingEvent event)方法。  </p>
<p>当对象从HttpSession对象中解除绑定时，web服务器调用该对象的void valueUnbound(HttpSessionBindingEvent event)方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBeanDemo1</span> <span class="keyword">implements</span> <span class="title">HttpSessionBindingListener</span> </span>&#123;</span><br><span class="line"><span class="number">18</span> </span><br><span class="line"><span class="number">19</span>     <span class="keyword">private</span> String name;</span><br><span class="line"><span class="number">20</span>     </span><br><span class="line"><span class="number">21</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">22</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueBound</span><span class="params">(HttpSessionBindingEvent event)</span> </span>&#123;</span><br><span class="line"><span class="number">23</span>         System.out.println(name+<span class="string">"被加到session中了"</span>);</span><br><span class="line"><span class="number">24</span>     &#125;</span><br><span class="line"><span class="number">25</span> </span><br><span class="line"><span class="number">26</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">27</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">valueUnbound</span><span class="params">(HttpSessionBindingEvent event)</span> </span>&#123;</span><br><span class="line"><span class="number">28</span>         System.out.println(name+<span class="string">"被session踢出来了"</span>);</span><br><span class="line"><span class="number">29</span>     &#125;</span><br><span class="line"><span class="number">30</span> </span><br><span class="line"><span class="number">31</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">32</span>         <span class="keyword">return</span> name;</span><br><span class="line"><span class="number">33</span>     &#125;</span><br><span class="line"><span class="number">34</span> </span><br><span class="line"><span class="number">35</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="number">36</span>         <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="number">37</span>     &#125;</span><br><span class="line"><span class="number">38</span> </span><br><span class="line"><span class="number">39</span>     <span class="function"><span class="keyword">public</span> <span class="title">JavaBeanDemo1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="number">40</span>         <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="number">41</span>     &#125;</span><br><span class="line"><span class="number">42</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述的JavaBeanDemo1这个javabean实现了HttpSessionBindingListener接口，那么这个JavaBean对象可以感知自己被绑定到Session中和从Session中删除的这两个操作。  </p>
<h4 id="1-5-2HttpSessionActivationListener接口"><a href="#1-5-2HttpSessionActivationListener接口" class="headerlink" title="1.5.2HttpSessionActivationListener接口"></a>1.5.2HttpSessionActivationListener接口</h4><p>实现了HttpSessionActivationListener接口的JavaBean对象可以感知自己被活化(反序列化)和钝化(序列化)的事件。  </p>
<p>当绑定到HttpSession对象中的javabean对象将要随HttpSession对象被钝化(序列化)之前，web服务器调用该javabean对象的void sessionWillPassivate(HttpSessionEvent event) 方法。这样javabean对象就可以知道自己将要和HttpSession对象一起被序列化(钝化)到硬盘中。  </p>
<p>当绑定到HttpSession对象中的javabean对象将要随HttpSession对象被活化(反序列化)之后，web服务器调用该javabean对象的void sessionDidActive(HttpSessionEvent event)方法。这样javabean对象就可以知道自己将要和 HttpSession对象一起被反序列化(活化)回到内存中。(javabean随着HttpSession对象一起被活化的前提是该javabean对象除了实现该接口外还应该实现Serialize接口)。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">27</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaBeanDemo2</span> <span class="keyword">implements</span> <span class="title">HttpSessionActivationListener</span>,</span><br><span class="line">28         <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="number">29</span> </span><br><span class="line"><span class="number">30</span>      </span><br><span class="line"><span class="number">31</span>     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">7589841135210272124L</span>;</span><br><span class="line"><span class="number">32</span>     <span class="keyword">private</span> String name;</span><br><span class="line"><span class="number">33</span>     </span><br><span class="line"><span class="number">34</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">35</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionWillPassivate</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line"><span class="number">36</span>         </span><br><span class="line"><span class="number">37</span>         System.out.println(name+<span class="string">"和session一起被序列化(钝化)到硬盘了，session的id是："</span>+se.getSession().getId());</span><br><span class="line"><span class="number">38</span>     &#125;</span><br><span class="line"><span class="number">39</span> </span><br><span class="line"><span class="number">40</span>     <span class="meta">@Override</span></span><br><span class="line"><span class="number">41</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDidActivate</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line"><span class="number">42</span>         System.out.println(name+<span class="string">"和session一起从硬盘反序列化(活化)回到内存了，session的id是："</span>+se.getSession().getId());</span><br><span class="line"><span class="number">43</span>     &#125;</span><br><span class="line"><span class="number">44</span> </span><br><span class="line"><span class="number">45</span>     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="number">46</span>         <span class="keyword">return</span> name;</span><br><span class="line"><span class="number">47</span>     &#125;</span><br><span class="line"><span class="number">48</span> </span><br><span class="line"><span class="number">49</span>     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="number">50</span>         <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="number">51</span>     &#125;</span><br><span class="line"><span class="number">52</span> </span><br><span class="line"><span class="number">53</span>     <span class="function"><span class="keyword">public</span> <span class="title">JavaBeanDemo2</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="number">54</span>         <span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="number">55</span>     &#125;</span><br><span class="line"><span class="number">56</span> &#125;</span><br></pre></td></tr></table></figure>
<p>既然这里谈到了session的序列化(钝化)，反序列化(活化)那我们就来具体聊聊。</p>
<h2 id="2-session序列化-钝化"><a href="#2-session序列化-钝化" class="headerlink" title="2.session序列化(钝化)"></a>2.session序列化(钝化)</h2><p>在session上线时，会在<code>tomcat／work／Catalina／localhost／项目名／</code>下生成一个sessions.ser文件，里面存放了所有session的信息，当你正在访问某个网页时若此时服务器关闭(关闭时才生成这个文件)又打开(打开后这个文件会消失)，你依旧能正常访问该网页。(故说session有重生的效果)。<br>若想废掉session的序列化,需要在<code>tomcat／conf／context.xml</code>中添加<code>&lt;Manager pathname=“”/&gt;</code></p>
<h2 id="3-session的钝化与活化"><a href="#3-session的钝化与活化" class="headerlink" title="3.session的钝化与活化"></a>3.session的钝化与活化</h2><p>Tomcat会在session一段时间内不被使用时钝化session对象，所谓钝化session，就是把session通过序列化的方法保存到硬盘文件中。当用户再使用session时，Tomcat还会把钝化的对象再活化session，所谓活化就是把硬盘文件中的session在反序列化中放回内存。当session被tomcat钝化时，sesseion中存储的对象也被钝化，当session被活化时，也会把session中存储的对象(javabean对象)活化。如果某个类(javabean对象)实现了HttpSessionActiveationListener接口后，当对象随着session被钝化和活化时，下面两个方法就会被调用:</p>
<pre><code>public void sessionWillPassivate(HttpSessionEvent se):当对象感知被活化时调用本方法。  
public void sessionDidActivate(HttpSessionEvent se):当对象感知被钝化时调用本方法。
</code></pre><p>钝化时会在<code>tomcat/work/Catalina/localhost/项目/mysession／</code>文件下生成一个后缀为.session的文件，网页中一个被钝化的session就对应一个.session文件(而上面的序列化是一个.ser文件存在所有的session)，在活化时此文件也不会消失(不同于上述的.ser文件消失)。<br>当然要看到上述效果，应该先配置tomcat钝化session的参数，在<code>tomcat/conf/catalina/localhost</code>目录下，添加以下配置内容(google一下吧)。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb项目之客户管理系统]]></title>
      <url>http://codingxiaxw.cn/2016/10/25/25-JavaWeb%E9%A1%B9%E7%9B%AE%E4%B9%8B%E5%AE%A2%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1.项目介绍"></a>1.项目介绍</h2><h3 id="1-1功能介绍"><a href="#1-1功能介绍" class="headerlink" title="1.1功能介绍"></a>1.1功能介绍</h3><ul>
<li>添加客户:添加客户的信息，包括姓名，性别，手机，邮箱，自我描述</li>
<li>查询客户:查询数据库中所有的客户，查询结果将客户信息以列表的形式给出，可以对列表中的客户信息进行编辑及删除</li>
<li>高级搜索:多条件组合在数据库中进行客户信息的查询，搜索结果以列表的形式给出，可以对列表中的客户信息进行编辑及删除</li>
<li>10月30日更:新增分页功能，逻辑性很强，具体逻辑请参照源码中相应代码。</li>
</ul>
<a id="more"></a>
<p><a href="https://github.com/codingXiaxw/CustomerManagement" target="_blank" rel="external">源码请点击这里前往我的github</a>  </p>
<h3 id="1-2运用知识"><a href="#1-2运用知识" class="headerlink" title="1.2运用知识"></a>1.2运用知识</h3><ul>
<li>数据库基本查询</li>
<li>数据库连接池c3p0</li>
<li>运用dbutil.jar包一键封装表单数据到bean对象中</li>
<li>利用dbutils.jar包简化对数据库增、删、改、查的代码</li>
<li>标签库</li>
<li>JavaWeb三层框架的分离(MVC模式)</li>
<li>将servlet的转发、重定向及方法进行封装，这样当设计到多个功能时不用建立多个servlet类。</li>
<li>反射</li>
</ul>
<h2 id="2-准备"><a href="#2-准备" class="headerlink" title="2.准备"></a>2.准备</h2><p><strong>1.导入第三方jar包以及c3p0配置文件</strong>。</p>
<ul>
<li>c3p0.jar</li>
<li>mchange-commons.java.jar</li>
<li>commons-beanutils.jar</li>
<li>commons-dbutils.jar</li>
<li>commons-logging.jar</li>
<li>自己写的小工具itcast-tools.jar</li>
<li>jstl.jar</li>
<li>mysql-connector-java.jar</li>
</ul>
<p><strong>2.建包</strong></p>
<ul>
<li>dao</li>
<li>service</li>
<li>servlet</li>
<li>domain</li>
</ul>
<p><strong>3.建表</strong>  </p>
<p>很多人问我源码怎么没有附上sql语句，我想有必要今天更新一下，因为数据库中的表就是一张用户信息表啊，这么简单我还上传个啥的sql语句脚本呢?看下面的效果图就知道表的字段无非:id(主键，varchar类型，根据UUID类自动生成)、name、gender、phone、email、description这几个咯，直接在控制台(或者第三方数据库建表工具，我mac上用的就是MySQL Workbench)创建这样包含这些字段的一张表就好咯。  </p>
<p>至于如何在表中添加数据，你可以将我的代码在你的电脑上面跑起来之后直接点击”添加客户”就可以在你数据库中的用户表中查到相应的用户信息咯。还有一种方法就是利用sql语句的<code>insert</code>语法自己在控制台中手动插入数据咯。  </p>
<p><strong>2017.02.17更:</strong>好吧，已经有太多的小伙伴让我给出sql语句了，想着为了减轻你们的负担我还是把sql语句给出来吧。这是我这个项目涉及到表的表结构，如下图,别告诉我把表结构都给你了你还写不出来它的sql语句…  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-02-17%20%E4%B8%8B%E5%8D%885.29.45.png" alt=""></p>
<h2 id="3-搭建环境"><a href="#3-搭建环境" class="headerlink" title="3.搭建环境"></a>3.搭建环境</h2><p>IntelliJ IDEA  +  MySQL 或者  eclipse + MySQL</p>
<h2 id="4-使用方法"><a href="#4-使用方法" class="headerlink" title="4.使用方法"></a>4.使用方法</h2><ol>
<li>git clone <code>https://github.com/codingXiaxw/CustomerManagement.git</code>  </li>
<li>使用IntelliJ IDEA导入打开 或者 使用eclipse打开<code>CustomerManagement_for_Eclipse</code>项目</li>
<li>使用eclipse/src/create_table.sql文件中的sql语句创建相应的数据库及表</li>
<li>修改<code>CustomerManagement/src</code>下<code>c3p0-config.xml</code>中数据库相关信息</li>
<li>部署Tomcat并启动，在浏览器中输入:<code>http://localhost:8080/项目名/index.jsp</code></li>
<li>enjoy it!</li>
</ol>
<p>有读者发来邮件告诉我他用IDEA时遇到的坑，就是在浏览器中输入上述网址时会出现<code>404</code>的报错信息，但是控制台又没报错，他问我是不是代码的问题。我告诉他控制台既然没报错而且网页上说<code>404</code>肯定是访问路径的问题啊，后来才发现是因为他没在IDEA的配置中设置项目的访问路径，因为IDEA启动web项目时它默认在访问路径中没有加上项目名，所以此时你在浏览器中输入的访问路径不加上项目名(即访问<code>http://localhost:8080/页面.jsp</code>)才能成功访问;解决访问就是在IDEA的配置中，在访问路径那一栏加上该项目的项目名即可。  </p>
<p>附上那位读者的邮件供大家参考:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-10%20%E4%B8%8A%E5%8D%8811.25.46.png" alt="">  </p>
<p>以及我的回答:<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-12-10%20%E4%B8%8A%E5%8D%8811.27.56.png" alt=""></p>
<h2 id="5-项目功能截图"><a href="#5-项目功能截图" class="headerlink" title="5.项目功能截图"></a>5.项目功能截图</h2><h3 id="5-1添加客户"><a href="#5-1添加客户" class="headerlink" title="5.1添加客户"></a>5.1添加客户</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/tianjia.png" alt=""></p>
<h3 id="5-2查询客户"><a href="#5-2查询客户" class="headerlink" title="5.2查询客户"></a>5.2查询客户</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/chaxun.png" alt=""></p>
<h3 id="5-3编辑客户"><a href="#5-3编辑客户" class="headerlink" title="5.3编辑客户"></a>5.3编辑客户</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/bianji.png" alt=""></p>
<h3 id="5-4高级搜索客户"><a href="#5-4高级搜索客户" class="headerlink" title="5.4高级搜索客户"></a>5.4高级搜索客户</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/sousuo.png" alt=""></p>
<h3 id="5-5-10月30日更新分页界面"><a href="#5-5-10月30日更新分页界面" class="headerlink" title="5.5 10月30日更新分页界面"></a>5.5 10月30日更新分页界面</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/fenye.png" alt=""></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Java实现网络爬虫三之开始爬取]]></title>
      <url>http://codingxiaxw.cn/2016/10/23/22-%E7%94%A8Java%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%89%E4%B9%8B%E5%BC%80%E5%A7%8B%E7%88%AC%E5%8F%96/</url>
      <content type="html"><![CDATA[<p>下面的代码用于爬取知乎推荐页面的所有问题、问题描述、地址、回答内容，爬取地址为<a href="http://www.zhihu.com/explore/recommendations" target="_blank" rel="external">http://www.zhihu.com/explore/recommendations</a>   </p>
<p>项目源代码见我<a href="https://github.com/codingXiaxw/Crawler" target="_blank" rel="external">github上的project</a></p>
<a id="more"></a>
<h2 id="代码介绍"><a href="#代码介绍" class="headerlink" title="代码介绍"></a>代码介绍</h2><p>1.新建Zhihu.java类，它是一个JavaBean类，用于封装我们需要得到的内容。代码如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/zhihu.png" alt="">  </p>
<p>2.新建Spider.java类包括两个方法:  </p>
<ul>
<li>String sendGet(String url):用于获取网页源码。<br><img src="http://od2xrf8gr.bkt.clouddn.com/sendget.png" alt="">  </li>
</ul>
<p>打印出result可以得到网页的源码，会看到下面这一串串代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/source.png" alt="">  </p>
<p>找到我们需要爬取的标题那一块，可以看到:<br><img src="http://od2xrf8gr.bkt.clouddn.com/lianjie.png" alt="">  </p>
<p>href=””中的内容即是标题的地址链接，而<a></a>中的内容即是我们需要的标题。那我们该如何使用正则表达式爬取到这些内容呢？标题可以使用<code>&quot;question_link.+?&gt;(.+?)&lt;&quot;</code>来匹配得到，而链接可以使用<code>&quot;&lt;h2&gt;.+?question_link.+?href=\&quot;(.+?)\&quot;.+?&lt;/h2&gt;&quot;</code>来匹配得到。下面我们就来看看Spide.java中的第二个方法，如何匹配我们我们的内容。</p>
<ul>
<li>ArrayList<zhihu> regexString(String targetStr,String regex):用于将正则表达式和网页源码进行匹配，将得到的内容封装到Zhihu对象中，然后将对象加入到集合lists中，返回集合。</zhihu></li>
</ul>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/regexstring.png" alt=""></p>
<p>最后我们只需要定义一个测试类，先调用Spider的sendGet(String url)方法中传入目标网页url并得到返回的网页源码，然后调用Spider的regexString(String target)方法得到返回的Zhihu对象的集合，然后将这些内容打印出来，即可看到我们爬取到的内容。  </p>
<p>测试类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/test.png" alt="">  </p>
<p>打印出的内容:<br><img src="http://od2xrf8gr.bkt.clouddn.com/lianjie2.png" alt=""> </p>
<p>这样我们便实现了从一个页面上爬取到我们所需信息的网络爬虫。如何进阶呢？  </p>
<p>问题分析:  </p>
<ul>
<li>1.从打印台的信息我们可以发现，我们爬取到的问题地址链接并不是属于问题的地址链接，而是属于回答的地址链接，那么这里我们就需要截掉链接后半部分的”/answer/数字”部分。  <blockquote>
<p>解决方法如下:对爬取到的链接采取二次正则表达式的方法进行再一次匹配，需要匹配的字符串即为<code>/question/数字部分</code>，这样我们就将链接作为目标字符串，将该数字部分作为正则表达式即可。代码如下:  </p>
<pre><code>在Zhihu.java文件下添加方法:
boolean getRealUrl(String url)
{
    String regex=&quot;question/(.+?)/&quot;;
    Pattern pattern=Pattern.compile(regex);
    Matcher matcher=pattern.matcher(url);
        while (matcher.find())
        {
            zhihuUrl=&quot;http://www.zhihu.com/question/&quot;+matcher.group(1);
            return true;
        }
    return false;
}
</code></pre></blockquote>
</li>
</ul>
<ul>
<li>2.我们爬取的只是一个页面的相关内容，并没有发挥爬虫的真正强大之处。所以接下来我们就将从该页面爬取到的链接作为二次起始链接。只需在Zhihu.java的构造函数里添加如下方法即可:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (getRealUrl(url))</span><br><span class="line">      &#123;</span><br><span class="line">          System.out.println(<span class="string">"正在抓取链接"</span>+zhihuUrl);</span><br><span class="line"></span><br><span class="line">          String content=Spider.sendGet(zhihuUrl);</span><br><span class="line"></span><br><span class="line">          Pattern pattern;</span><br><span class="line">          Matcher matcher;</span><br><span class="line"></span><br><span class="line">          pattern=Pattern.compile(<span class="string">"zh-question-title.+?&lt;h2.+?&gt;(.+?)&lt;/h2&gt;"</span>);</span><br><span class="line">          matcher=pattern.matcher(content);</span><br><span class="line">          <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">              title = matcher.group(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          pattern=Pattern.compile(<span class="string">"zh-question-detail.+?&lt;div.+?&gt;(.*?)&lt;/div&gt;"</span>);</span><br><span class="line">          matcher=pattern.matcher(content);</span><br><span class="line">          <span class="keyword">if</span> (matcher.find()) &#123;</span><br><span class="line">              titleDescription=matcher.group(<span class="number">1</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          pattern=Pattern.compile(<span class="string">"/answer/content.+?&lt;div.+?&gt;(.*?)&lt;/div&gt;"</span>);</span><br><span class="line">          matcher=pattern.matcher(content);</span><br><span class="line">          <span class="keyword">while</span> (matcher.find())</span><br><span class="line">          &#123;</span><br><span class="line">              answers.add(matcher.group(<span class="number">1</span>));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样当我们在Spider类的regexString()方法里，每当用构造方法创建一个Zhihu对象时就会执行上述代码生成从一个链接爬取到的文章标题、内容、标题描述即回答内容并封装到该Zhihu对象里，然后继续执行Spider后面的代码时将该对象添加至list集合中。  </p>
<p>最后打印出的内容如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/printi2.png" alt=""></p>
<p>至于抓到的内容如何处理这要看你自己如何利用咯。</p>
<p>项目源代码见我<a href="https://github.com/codingXiaxw/Crawler" target="_blank" rel="external">Github</a>,地址为 <a href="https://github.com/codingXiaxw/Crawler" target="_blank" rel="external">https://github.com/codingXiaxw/Crawler</a> </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Java实现网络爬虫二之Java正则表达式]]></title>
      <url>http://codingxiaxw.cn/2016/10/23/21-%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%BA%8C%E4%B9%8BJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>正则表达式定义了字符串的模式，可以用来搜索、编辑或处理文本，正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。  </p>
<a id="more"></a>
<p>爬虫项目源代码见我<a href="https://github.com/codingXiaxw/Crawler" target="_blank" rel="external">github上的project</a></p>
<h2 id="1-正则表达式语法"><a href="#1-正则表达式语法" class="headerlink" title="1.正则表达式语法"></a>1.正则表达式语法</h2><table>
<thead>
<tr>
<th>字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>\</td>
<td style="text-align:center">将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\“匹配”\”，”(“匹配”(“。</td>
</tr>
<tr>
<td>^</td>
<td style="text-align:center">匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</td>
</tr>
<tr>
<td>$</td>
<td style="text-align:center">匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</td>
</tr>
<tr>
<td>*</td>
<td style="text-align:center">零次或多次匹配前面的字符或子表达式。例如，zo<em> 匹配”z”和”zoo”。</em> 等效于 {0,}。</td>
</tr>
<tr>
<td>+</td>
<td style="text-align:center">一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</td>
</tr>
<tr>
<td>?</td>
<td style="text-align:center">零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。当此字符紧随任何其他限定符（ * 、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</td>
</tr>
<tr>
<td>{n}</td>
<td style="text-align:center">n 是非负整数。正好匹配 n 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</td>
</tr>
<tr>
<td>{n,}</td>
<td style="text-align:center">n 是非负整数。至少匹配 n 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*”。</td>
</tr>
<tr>
<td>{n,m}</td>
<td style="text-align:center">M 和 n 是非负整数，其中 n &lt;= m。匹配至少 n 次，至多 m 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于 ‘o?’。注意：不能将空格插入逗号和数字之间。</td>
</tr>
<tr>
<td>.</td>
<td style="text-align:center">匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</td>
</tr>
<tr>
<td>x｜y</td>
<td style="text-align:center">匹配 x 或 y。例如，’z｜food’ 匹配”z”或”food”。’(z｜f)ood’ 匹配”zood”或”food”。</td>
</tr>
<tr>
<td>[xyz]</td>
<td style="text-align:center">字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</td>
</tr>
<tr>
<td>[^xyz]</td>
<td style="text-align:center">反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</td>
</tr>
<tr>
<td>[a-z]</td>
<td style="text-align:center">字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</td>
</tr>
<tr>
<td>[^a-z]</td>
<td style="text-align:center">反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</td>
</tr>
<tr>
<td>\b</td>
<td style="text-align:center">匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</td>
</tr>
<tr>
<td>\B</td>
<td style="text-align:center">非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</td>
</tr>
<tr>
<td>\d</td>
<td style="text-align:center">数字字符匹配。等效于 [0-9]。</td>
</tr>
<tr>
<td>\D</td>
<td style="text-align:center">非数字字符匹配。等效于 [^0-9]。</td>
</tr>
<tr>
<td>\n</td>
<td style="text-align:center">换行符匹配。等效于 \x0a 和 \cJ。</td>
</tr>
<tr>
<td>\f</td>
<td style="text-align:center">换页符匹配。等效于 \x0c 和 \cL。</td>
</tr>
<tr>
<td>\r</td>
<td style="text-align:center">匹配一个回车符。等效于 \x0d 和 \cM。</td>
</tr>
<tr>
<td>\s</td>
<td style="text-align:center">匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td>\S</td>
<td style="text-align:center">匹配任何非空白字符。与 [^ \f\n\r\t\v] 等效。</td>
</tr>
<tr>
<td>\t</td>
<td style="text-align:center">制表符匹配。与 \x09 和 \cI 等效。</td>
</tr>
<tr>
<td>\w</td>
<td style="text-align:center">匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</td>
</tr>
<tr>
<td>\W</td>
<td style="text-align:center">与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</td>
</tr>
</tbody>
</table>
<h2 id="2-Pattern类与Matcher类详解"><a href="#2-Pattern类与Matcher类详解" class="headerlink" title="2.Pattern类与Matcher类详解"></a>2.Pattern类与Matcher类详解</h2><p>java.util.regex是一个用正则表达式所订制的模式来对字符串进行匹配工作的类库包。它包括两个类：Pattern和Matcher。一个Pattern对象是一个正则表达式经编译后的表现模式；一个Matcher对象是一个状态机器，它依据Pattern对象做为匹配模式对字符串展开匹配检查。 首先一个Pattern实例订制了一个所用语法与PERL的类似的正则表达式经编译后的模式，然后一个Matcher实例在这个给定的Pattern实例的模式控制下进行字符串的匹配工作。  </p>
<p>以下我们就分别来看看这两个类: </p>
<h3 id="2-1-捕获组的概念"><a href="#2-1-捕获组的概念" class="headerlink" title="2.1 捕获组的概念"></a>2.1 捕获组的概念</h3><p>捕获组可以通过从左到右计算其开括号来编号，编号是从1开始的。例如，在表达式<code>((A)(B(C)))</code>中，存在四个这样的组:  </p>
<pre><code>第0组:    ((A)(B(C)))
第1组:    (A)
第2组:    (B(C))
第3组:    (C)
</code></pre><p>组零始终代表整个表达式，以(?)开头的组是纯的非捕获组，它不捕获文本，也不针对组合进行计数。  </p>
<p>与组关联的捕获输入始终是与组最近匹配的子序列。如果由于量化的缘故再次计算了组，则在第二次计算失败时将保留其以前捕获的值(如果有的话)，例如，将字符串”aba”与表达式(a(b)?)+相匹配，会将第二组设置为”b”。在每个匹配的开头，所有捕获的输入都会被丢弃。</p>
<h3 id="2-3详解Pattern类和Matcher类"><a href="#2-3详解Pattern类和Matcher类" class="headerlink" title="2.3详解Pattern类和Matcher类"></a>2.3详解Pattern类和Matcher类</h3><p>java正则表达式通过java.util.regex包下的Pattern类与Matcher类实现(建议在阅读本文时,打开java API文档,当介绍到哪个方法时,查看java API中的方法说明,效果会更佳).  </p>
<p>Pattern类用于创建一个正则表达式,也可以说创建一个匹配模式,它的构造方法是私有的,不可以直接创建,但可以通过Pattern.complie(String regex)简单工厂方法创建一个正则表达式, Java代码示例:  </p>
<pre><code>Pattern p=Pattern.compile(&quot;\\w+&quot;);

p.pattern();//返回 \w+ 
//或者直接输出p,例如System.out.println(p);得到的也是\w+。
</code></pre><p>pattern() 返回正则表达式的字符串形式,其实就是返回Pattern.complile(String regex)的regex参数(当然regex中的某些特殊字符应在其前加上“\”进行转义)。如上方的”\w”就需要在”w”前面的”\”加上”\”进行转义。</p>
<h4 id="2-3-1Pattern-split-CharSequence-input"><a href="#2-3-1Pattern-split-CharSequence-input" class="headerlink" title="2.3.1Pattern.split(CharSequence input)"></a>2.3.1Pattern.split(CharSequence input)</h4><p>Pattern有一个split(CharSequence input)方法，用于分隔字符串，并返回一个String[]，我猜String.split(String regex)就是通过该方法来实现的。代码示例:  </p>
<pre><code>Pattern p=Pattern.compile(&quot;\\d+&quot;); 

String[] str=p.split(&quot;我的QQ是:456456我的电话是:0532214我的邮箱是:aaa@aaa.com&quot;); 
</code></pre><p>结果:str[0]=”我的QQ是:” str[1]=”我的电话是:” str[2]=”我的邮箱是:aaa@aaa.com” 。</p>
<h4 id="2-3-2Pattern-matches-String-regex-CharSequence-input"><a href="#2-3-2Pattern-matches-String-regex-CharSequence-input" class="headerlink" title="2.3.2Pattern.matches(String regex,CharSequence input)"></a>2.3.2Pattern.matches(String regex,CharSequence input)</h4><p>是一个静态方法，用于快速匹配字符串，该方法适合用于只匹配一次，且匹配全部字符串。代码示例:  </p>
<pre><code>Pattern.matches(&quot;\\d+&quot;,&quot;2223&quot;);//返回true 
Pattern.matches(&quot;\\d+&quot;,&quot;2223aa&quot;);//返回false,需要匹配到所有字符串才能返回true,这里aa不能匹配到 
Pattern.matches(&quot;\\d+&quot;,&quot;22bb23&quot;);//返回false,需要匹配到所有字符串才能返回true,这里bb不能匹配到 
</code></pre><h4 id="2-3-3Pattern-matcher-charSequence-input"><a href="#2-3-3Pattern-matcher-charSequence-input" class="headerlink" title="2.3.3Pattern.matcher(charSequence input)"></a>2.3.3Pattern.matcher(charSequence input)</h4><p>说了这么多，终于轮到Matcher类登场了，Pattern.matcher(CharSequence input)返回一个Matcher对象。Matcher类的构造方法也是私有的，不能随意创建，只能通过Pattern.matcher(CharSequence input)方法得到该类的实例。Pattern类只能做一些简单的匹配操作，要想得到更强更便捷的正则匹配操作，那就需要将Pattern与Matcher一起合作。Matcher类提供了对正则表达式的分组支持，以及对正则表达式的多次匹配支持。代码示例:  </p>
<pre><code>Pattern p=Pattern.compile(&quot;\\d+&quot;); 
Matcher m=p.matcher(&quot;22bb23&quot;); 
m.pattern();//返回正则表达式，等同于System.out.println(p)中的p或者System.out.println(p.pattern())中的p.pattern()
System.out.println(m);//返回p 也就是返回该Matcher对象是由哪个Pattern对象的创建的 
</code></pre><h4 id="2-3-4Matcher-matches-Matcher-lookingAt-Matcher-find"><a href="#2-3-4Matcher-matches-Matcher-lookingAt-Matcher-find" class="headerlink" title="2.3.4Matcher.matches()/Matcher.lookingAt()/Matcher.find"></a>2.3.4Matcher.matches()/Matcher.lookingAt()/Matcher.find</h4><p>Matcher类提供三个匹配操作方法，三个方法均返回boolean类型，当匹配到时返回true，没匹配到则返回false。  </p>
<p><strong>matches()</strong>方法对整个字符串进行匹配，只有整个字符串都匹配了才返回true。代码示例:  </p>
<pre><code>Pattern p=Pattern.compile(&quot;\\d+&quot;); 
Matcher m=p.matcher(&quot;22bb23&quot;); 
m.matches();//返回false,因为bb不能被\d+匹配,导致整个字符串匹配未成功. 

Matcher m2=p.matcher(&quot;2223&quot;); 
m2.matches();//返回true,因为\d+匹配到了整个字符串
</code></pre><p>我们现在回头看一下Pattern.matches(String regex,CharSequence input),它与下面这段代码等价:<code>Pattern.compile(String regex).matcher(String input).matches();</code>  </p>
<p><strong>lookingAt()</strong>对前面的字符串进行匹配，只有匹配到的字符串在最前面才返回true。代码示例:  </p>
<pre><code>Pattern p=Pattern.compile(&quot;\\d+&quot;); 
Matcher m=p.matcher(&quot;22bb23&quot;); 
m.lookingAt();//返回true,因为\d+匹配到了前面的22 

Matcher m2=p.matcher(&quot;aa2223&quot;); 
m2.lookingAt();//返回false,因为\d+不能匹配前面的aa 
</code></pre><p><strong>find()</strong>对字符串进行匹配，匹配到的字符串可以在字符串的任何位置。代码示例:</p>
<pre><code>Pattern p=Pattern.compile(&quot;\\d+&quot;); 
Matcher m=p.matcher(&quot;22bb23&quot;); 
m.find();//返回true 

Matcher m2=p.matcher(&quot;aa2223&quot;); 
m2.find();//返回true 

Matcher m3=p.matcher(&quot;aa2223bb&quot;); 
m3.find();//返回true 

Matcher m4=p.matcher(&quot;aabb&quot;); 
m4.find();//返回false 
</code></pre><h4 id="2-3-5Matcher-start-Matcher-end-Matcher-group"><a href="#2-3-5Matcher-start-Matcher-end-Matcher-group" class="headerlink" title="2.3.5Matcher.start()/Matcher.end()/Matcher.group()"></a>2.3.5Matcher.start()/Matcher.end()/Matcher.group()</h4><p>当使用matches()、lookingAt()、find()执行匹配操作并返回的值为true后，就可以利用以上三个方法得到更详细的信息。(若上述三个方法matches()、lookingAt()、find()返回的是false或者根本没有调用过上述三个方法则不能进行这三个查找方法)  </p>
<p>start()返回匹配到的子字符串在字符串中的索引位置。<br>end()返回匹配到的子字符串的最后一个字符的后一个字符在字符串中的索引位置。<br>group()返回匹配到的子字符串。(group()等同与group(0)方法)。代码示例:  </p>
<pre><code>Pattern p=Pattern.compile(&quot;\\d+&quot;); 
Matcher m=p.matcher(&quot;aaa2223bb22&quot;); 
m.find();//匹配2223 ，匹配的是一个和正则表达式相匹配的字符串，返回true
m.start();//返回3 
m.end();//返回7,返回的是2223后的索引号 
m.group();//返回2223，返回的是第一个和正则表达式相匹配的字符串，若想全部输出应采用while(m.find){System.out.println(m.group());}的形式将全部匹配到的字符串返回

Mathcer m2=p.matcher(&quot;2223bb&quot;); 
m2.lookingAt();   //匹配2223，返回true
m2.start();   //返回0,由于lookingAt()只能匹配前面的字符串,所以当使用lookingAt()匹配时,start()方法总是返回0 
m2.end();   //返回4 
m2.group();   //返回2223 

Matcher m3=p.matcher(&quot;2223bb&quot;);
m3.matches();   //匹配整个字符串,返回false;
m3.start();   //出现异常，因为m3.matches()返回的是false，故不能用start()、end()、group()方法。
m3.end();   //出现异常 
m3.group();   //出现异常
</code></pre><p>说了这么多,相信大家都明白了以上几个方法的使用,该说说正则表达式的分组在java中是怎么使用的。start(),end(),group()均有一个重载方法，它们是start(int i),end(int i),group(int i)专用于分组操作,Mathcer类还有一个groupCount()用于返回此正则表达式有多少分组(实际上组的数量等于groupCount返回的分组＋1)。代码示例:</p>
<pre><code>Pattern p=Pattern.compile(&quot;([a-z]+)(\\d+)&quot;); 
Matcher m=p.matcher(&quot;aaa2223bb&quot;); 
m.find();   //匹配aaa2223 
m.groupCount();   //返回2,但此正则表达式中有3组，因为默认0组是(([a-z]+)(\\d+)). 
m.start(1);   //返回0 返回第一组匹配到的子字符串在字符串中的索引号 
m.start(2);   //返回3 

m.end(1);   //返回3 返回第一组匹配到的子字符串的最后一个字符在字符串中的索引位置. 
m.end(2);   //返回7 

m.group(1);   //返回aaa,返回第一组匹配到的子字符串 
m.group(2);   //返回2223,返回第二组匹配到的子字符串 
m.group();//返回aaa2223,返回的是第0组匹配到的子字符串
m.group(0);//等同于m.group(),返回aaa2223,返回的是第0组匹配到的子字符串
</code></pre><p>现在我们使用一下稍微高级点的正则匹配操作,例如有一段文本,里面有很多数字,而且这些数字是分开的,我们现在要将文本中所有数字都取出来,利用java的正则操作是那么的简单. 代码示例:</p>
<pre><code>Pattern p=Pattern.compile(&quot;\\d+&quot;); 
Matcher m=p.matcher(&quot;我的QQ是:456456 我的电话是:0532214 我的邮箱是:aaa123@aaa.com&quot;); 

while(m.find()) { 
     System.out.println(m.group()); 
 }
</code></pre><p>输出:</p>
<pre><code>456456 
0532214 
123 
</code></pre><p>如将以上while()循环替换成:</p>
<pre><code>while(m.find()) { 
     System.out.println(m.group()); 
     System.out.print(&quot;start:&quot;+m.start()); 
     System.out.println(&quot; end:&quot;+m.end()); 
 } 
</code></pre><p>则输出:  </p>
<pre><code>456456 
start:6 end:12 
0532214 
start:19 end:26 
123 
start:36 end:39 
</code></pre><p>现在大家应该知道,每次执行匹配操作后start(),end(),group()三个方法的值都会改变,改变成匹配到的子字符串的信息,以及它们的重载方法,也会改变成相应的信息.  </p>
<p><strong>注意:</strong>只有当匹配操作成功,才可以使用start(),end(),group()三个方法,否则会抛出java.lang.IllegalStateException,也就是当matches(),lookingAt(),find()其中任意一个方法返回true时,才可以使用.</p>
<h2 id="3-贪婪模式和懒惰模式"><a href="#3-贪婪模式和懒惰模式" class="headerlink" title="3.贪婪模式和懒惰模式"></a>3.贪婪模式和懒惰模式</h2><h3 id="3-1概述"><a href="#3-1概述" class="headerlink" title="3.1概述"></a>3.1概述</h3><p>贪婪与非贪婪模式影响的是被量词修饰的子表达式的匹配行为，贪婪模式在整个表达式匹配成功的前提下，尽可能多的匹配，而非贪婪模式在整个表达式匹配成功的前提下，尽可能少的匹配。非贪婪模式只被部分NFA引擎所支持。  </p>
<p>属于贪婪模式的量词，也叫做匹配优先量词，包括：<br><code>{m,n}”、“{m,}”、“?”、“*”和“+”。</code>  </p>
<p>在一些使用NFA引擎的语言中，在匹配优先量词后加上“?”，即变成属于非贪婪模式的量词，也叫做忽略优先量词，包括：  </p>
<p><code>“{m,n}?”、“{m,}?”、“??”、“*?”和“+?”。</code>  </p>
<p>从正则语法的角度来讲，被匹配优先量词修饰的子表达式使用的就是贪婪模式，如“(Expression)+”；被忽略优先量词修饰的子表达式使用的就是非贪婪模式，如“(Expression)+?”。  </p>
<p>对于贪婪模式，各种文档的叫法基本一致，但是对于非贪婪模式，有的叫懒惰模式或惰性模式，有的叫勉强模式，其实叫什么无所谓，只要掌握原理和用法，能够运用自如也就是了。个人习惯使用贪婪与非贪婪的叫法，所以文中都会使用这种叫法进行介绍。  </p>
<h3 id="3-2什么是贪婪模式与非贪婪模式"><a href="#3-2什么是贪婪模式与非贪婪模式" class="headerlink" title="3.2什么是贪婪模式与非贪婪模式"></a>3.2什么是贪婪模式与非贪婪模式</h3><p>示例:  </p>
<pre><code>源字符串：aa&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;cc
正则表达式一：&lt;div&gt;.*&lt;/div&gt;
匹配结果一：&lt;div&gt;test1&lt;/div&gt;bb&lt;div&gt;test2&lt;/div&gt;

正则表达式二：&lt;div&gt;.*?&lt;/div&gt;
匹配结果二：&lt;div&gt;test1&lt;/div&gt;（这里指的是一次匹配结果，所以没包括&lt;div&gt;test2&lt;/div&gt;）  
</code></pre><p>根据上面的例子，从匹配行为上分析一下，什是贪婪与非贪婪模式。  </p>
<p>正则表达式一采用的是贪婪模式，在匹配到第一个“”时已经可以使整个表达式匹配成功，但是由于采用的是贪婪模式，所以仍然要向右尝试匹配，查看是否还有更长的可以成功匹配的子串，匹配到第二个“”后，向右再没有可以成功匹配的子串，匹配结束，匹配结果为“<div>test1</div>bb<div>test2</div>”。  </p>
<p>仅从应用角度分析，可以这样认为，贪婪模式，就是在整个表达式匹配成功的前提下，尽可能多的匹配，也就是所谓的“贪婪”，通俗点讲，就是看到想要的，有多少就捡多少，除非再也没有想要的了。  </p>
<p>正则表达式二采用的是非贪婪模式，在匹配到第一个“”时使整个表达式匹配成功，由于采用的是非贪婪模式，所以结束匹配，不再向右尝试，匹配结果为“<div>test1</div>”。  </p>
<p>仅从应用角度分析，可以这样认为，非贪婪模式，就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Java实现网络爬虫一之项目介绍]]></title>
      <url>http://codingxiaxw.cn/2016/10/20/20-%E7%94%A8Java%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%80%E4%B9%8B%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<p>网络爬虫(Web crawler)也叫网络爬虫(Web spider)、蚂蚁（ant）、自动检索工具(automatic indexer)，或者(在FOAF软件概念中)网络疾走(WEB scutter)，是一种“自动化浏览网络”的程序，或者说是一种网络机器人。它们被广泛用于互联网搜索引擎或其他类似网站，以获取或更新这些网站的内容和检索方式。它们可以自动采集所有其能够访问到的页面内容，以供搜索引擎做进一步处理（分检整理下载的页面），而使得用户能更快的检索到他们需要的信息。  </p>
<a id="more"></a>
<h2 id="用Java实现网络爬虫系列"><a href="#用Java实现网络爬虫系列" class="headerlink" title="用Java实现网络爬虫系列"></a>用Java实现网络爬虫系列</h2><p>这系列文章我打算用5篇博客来完成，源代码见我<a href="https://github.com/codingXiaxw/Crawler" target="_blank" rel="external">github上的project</a>  </p>
<p>一览表:</p>
<ul>
<li>1.<a href="http://codingxiaxw.cn/2016/10/20/20-%E7%94%A8Java%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%80%E4%B9%8B%E9%A1%B9%E7%9B%AE%E4%BB%8B%E7%BB%8D/">用Java实现网络爬虫一之项目介绍</a></li>
<li>2.<a href="http://codingxiaxw.cn/2016/10/23/21-%E7%94%A8Java%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%BA%8C%E4%B9%8BJava%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">用Java实现网络爬虫二之Java正则表达式</a></li>
<li>3.<a href="http://codingxiaxw.cn/2016/10/23/22-%E7%94%A8Java%E5%86%99%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB%E4%B8%89%E4%B9%8B%E5%BC%80%E5%A7%8B%E7%88%AC%E5%8F%96/">用Java实现网络爬虫三之开始爬取</a></li>
<li>4.<a href="">进阶段:用Java实现网络爬虫四之将爬取内容存入数据库</a></li>
<li>5.<a href="">进阶段:开始使用框架实现网络爬虫</a></li>
</ul>
<p>制作网络爬虫主要的步骤就是:  </p>
<ul>
<li>1.通过输入流获取到网页源码</li>
<li>2.利用正则表达式在源码中找到自己想要的内容  <blockquote>
<p>正因为正则表达式在制作网络爬虫中的重要，所以这里我有必要把Java正则表达式拿出来单独写篇博客，当然基础好的可以直接忽略跳到第三篇。</p>
</blockquote>
</li>
<li>3.将自己找到的内容输出来并查看</li>
</ul>
<p>后续进阶可以对第三步进行改善，如将自己爬到的内容不是打印出来，而是通过JDBC存入MySQL中然后在MySQL中进行查看(见第四篇文章)。  </p>
<h2 id="需要用到的知识"><a href="#需要用到的知识" class="headerlink" title="需要用到的知识"></a>需要用到的知识</h2><ul>
<li>Java IO流</li>
<li>Java 正则表达式</li>
<li>html/css 的基本了解</li>
</ul>
<h2 id="我的爬虫目标"><a href="#我的爬虫目标" class="headerlink" title="我的爬虫目标"></a>我的爬虫目标</h2><p>制作网络爬虫爬取知乎网上提的问题、问题链接、问题描述以及回答内容，并将它们打印在输出台。(后续进阶我选择将这些内容存入MySQL数据库，而不是)</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java之IO流详解]]></title>
      <url>http://codingxiaxw.cn/2016/10/17/19-Java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>大多数应用程序都需要实现与设备之间的数据传输，例如键盘可以输入数据，显示器可以显示程序的运行结果等。在Java中，将这种通过不同输入输出设备(键盘，内存，显示器，网络等)之间的数据传输抽象表述为”流”，程序允许通过流的方式与输入输出设备进行数据传输。Java中的”流”都位于java.io包中，称为IO(输入输出)流。  </p>
<a id="more"></a>
<p>IO流四大家族:</p>
<ul>
<li>1.InputStream:输入字节流。</li>
<li>2.OutputStream:输出字节流。</li>
<li>3.Reader:输入字符流。</li>
<li>4.Writer:输出字符流。</li>
</ul>
<p>其中1、2统称字节流，3、4统称字符流。接下来就来详细介绍这四大家族流的用法。</p>
<h2 id="1-字节流"><a href="#1-字节流" class="headerlink" title="1.字节流"></a>1.字节流</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念"></a>1.1概念</h3><p>在计算机中，无论是文本、图片、音频、还是视频，所有的文件都是以二进制(字节)形式存在，IO流中针对字节的输入输出提供了一系列的流，统称为字节流。字节流是程序中最常用的流，根据数据的传输方向可将其分为字节输入流和字节输出流。在JDK中，提供了两个抽象类InputStream和OutputStream，它们是字节流的顶级父类，所有的字节输入流都继承自InputStream，所有的字节输出流都继承自OutputStream。  </p>
<p><strong>注意:</strong>以上所说的所有”输入”、”输出”都是相对于程序而言。数据通过输入流从源设备输入到程序，通过输出流从程序输出到目标设备，从而实现数据的传输。  </p>
<h3 id="1-2字节输入流-InputStream"><a href="#1-2字节输入流-InputStream" class="headerlink" title="1.2字节输入流(InputStream)"></a>1.2字节输入流(InputStream)</h3><p><strong>常用方法:</strong>  </p>
<ul>
<li>int read();从输入流读取一个8位的字节，把它转换成0~255之间的整数，并返回这一整数。</li>
<li>int read(byte[] b);从输入流读取若干字节，把它们保存到参数b指定的字节数组中，返回的整数表示读取字节数。</li>
<li>int read(byte[] b,int off,int len);从输入流读取若干字节，把它们保存到参数b指定的字节数组中，off指定字节数组开始保存数据的起始下标，len表示读取的字节数目。</li>
<li>void close();关闭此输入流并释放与该流关联的所有系统资源。</li>
</ul>
<p>前三个read()方法都是用来读数据的，其中，第一个read()方法是从输入流中逐个读入字节，而第二个和第三个read()方法则将若干字节以字节数组的形式一次性读入，从而提高读数据的效率。在进行IO流操作时，当前IO流会占用一定的内存，由于系统资源宝贵，因此，在IO流操作结束后，应该调用close()方法关闭流，从而释放当前IO流所占的系统资源。 </p>
<p><strong>Demo:读取文件text.txt中的内容</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		FileInputStream in=<span class="keyword">new</span> FileInputStream(<span class="string">"text.txt"</span>);</span><br><span class="line">		<span class="keyword">int</span> b;<span class="comment">//定义一个int类型的变量，记住每次读取的一个字节。</span></span><br><span class="line">		<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			System.out.prinln(b);<span class="comment">//逐个打印出读取的每一个字节</span></span><br><span class="line">		&#125;</span><br><span class="line">		in.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3字节输出流-OutputStream"><a href="#1-3字节输出流-OutputStream" class="headerlink" title="1.3字节输出流(OutputStream)"></a>1.3字节输出流(OutputStream)</h3><p><strong>常用方法:</strong>  </p>
<ul>
<li>void write(int b);向输出流写入一个字节。</li>
<li>void write(byte[] b);把参数b指定的字节数组的所有字节写到输出流。</li>
<li>void write(byte[] b,int off,int len);将指定byte数组中从偏移量off开始的len个字节写入输出流。</li>
<li>void flush();刷新此输出流并强制写出所有缓冲的输出字节。</li>
<li>void close();关闭此输出流并释放与此流相关的所有系统资源。</li>
</ul>
<p>前三个是重载的write()方法，都是用于向输出流写入字节，其中，第一个方法逐个写入字节，后两个方法是将若干个字节以字节数组的形式一次性写入，从而提高写数据的效率。flush()方法用来将当前输出流缓冲区(通常是字节数组)中的数据强制写入目标设备，此过程称为刷新。close()方法是用来关闭流并释放与当前IO流相关的系统资源。  </p>
<p><strong>Demo:将字符串(首先要将字符串转换为字节)写入到文件中</strong>  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		FileOutputStream out=<span class="keyword">new</span> FileOutputStream(目标文件的路径);</span><br><span class="line">		String str=<span class="string">"hello world"</span>;</span><br><span class="line">		<span class="keyword">byte</span>[] b=str.getBytes();<span class="comment">//字符串调用getBytes()方法即可转换成字节数组。</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;b.length;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			out.write(b[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>InputStream和OutputStream这两个类虽然提供了一系列和读写数据有关的方法，但是这两个类都是抽象类，不能被实例化。因此，针对不同的功能，二者提供了不同的子类。</p>
<h3 id="1-4代码示例"><a href="#1-4代码示例" class="headerlink" title="1.4代码示例"></a>1.4代码示例</h3><p>下面这个例子通过对文件的复制来讲解InputStream和OutputStream的用法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	 	String fileName=<span class="string">"/Users/codingBoy/Desktop/example1.jpg"</span>;<span class="comment">//源文件路径</span></span><br><span class="line">	 	String fileName2=<span class="string">"/Users/codingBoy/Desktop/example2.jpg"</span>;<span class="comment">//目标文件路径</span></span><br><span class="line">	 	InputStream in=<span class="keyword">null</span>;</span><br><span class="line">	 	OutputStream out=<span class="keyword">null</span>;</span><br><span class="line">	 	<span class="keyword">try</span> &#123;</span><br><span class="line">	 		in = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">	 		out = <span class="keyword">new</span> FileOutputStream(fileName2);</span><br><span class="line">	 		<span class="keyword">int</span> b;</span><br><span class="line">	 		<span class="keyword">while</span> ((b = in.read())!= -<span class="number">1</span>) &#123;</span><br><span class="line">	 			out.write(b);</span><br><span class="line">	 		&#125;</span><br><span class="line">		 &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">		 &#123;</span><br><span class="line">		 	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> 		 &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		 	<span class="keyword">try</span> &#123;</span><br><span class="line">		 		<span class="keyword">if</span> (in != <span class="keyword">null</span>) in.close();</span><br><span class="line">				<span class="keyword">if</span> (out!=<span class="keyword">null</span>) out.close();</span><br><span class="line"> 			&#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line"> 			&#123;</span><br><span class="line">	 			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-5字节缓冲流"><a href="#1-5字节缓冲流" class="headerlink" title="1.5字节缓冲流"></a>1.5字节缓冲流</h3><p>上面的例子实现了对文件的复制，但是一个字节一个字节的读写，需要频繁的操作文件，效率非常低。为了提高效率，需要使用两个带缓冲的字节流，分别是BufferedInputStream和BufferedOutputStream,它们两个同时也属于上文<a href="http://codingxiaxw.cn/2016/10/16/18-JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BJdbc%E4%BA%8C/">JavaWeb学习笔记之Jdbc二</a>中讲到的装饰流。下面通过增加字节缓冲流来对上述例子进行变动:  </p>
<p><strong>Demo:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String fileName=<span class="string">"/Users/codingBoy/Desktop/example1.jpg"</span>;<span class="comment">//源文件路径</span></span><br><span class="line">	 	String fileName2=<span class="string">"/Users/codingBoy/Desktop/example2.jpg"</span>;<span class="comment">//目标文件路径</span></span><br><span class="line">	 	InputStream in=<span class="keyword">null</span>;</span><br><span class="line">	 	OutputStream out=<span class="keyword">null</span>;</span><br><span class="line">	 	BufferedInputStream bis=<span class="keyword">null</span>;</span><br><span class="line">	 	BufferedOutputStream bos=<span class="keyword">null</span>;</span><br><span class="line">	 	<span class="keyword">try</span> &#123;</span><br><span class="line">	 		in = <span class="keyword">new</span> FileInputStream(fileName);</span><br><span class="line">	 		bis = <span class="keyword">new</span> BufferedInputStream(in);<span class="comment">//将输入流对象作为参数传递给输入缓冲流</span></span><br><span class="line">	 		out = <span class="keyword">new</span> FileOutputStream(fileName2);</span><br><span class="line">	 		bos = <span class="keyword">new</span> BufferedOutputStream(out);</span><br><span class="line">	 		</span><br><span class="line">	 		<span class="keyword">int</span> len;</span><br><span class="line">	 		<span class="keyword">while</span>((len=bis.read())!=-<span class="number">1</span>)		 		&#123;</span><br><span class="line">	 			bos.write(len);</span><br><span class="line">	 		&#125;</span><br><span class="line">	 	<span class="keyword">catch</span> (Exception e)</span><br><span class="line">		 &#123;</span><br><span class="line">		 	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> 		 &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		 	<span class="keyword">try</span> &#123;</span><br><span class="line">		 		<span class="keyword">if</span> (in != <span class="keyword">null</span>) in.close();</span><br><span class="line">		 		<span class="keyword">if</span> (bis!=<span class="keyword">null</span>) bis.close();</span><br><span class="line">				<span class="keyword">if</span> (out!=<span class="keyword">null</span>) out.close();</span><br><span class="line">				<span class="keyword">if</span> (bos!=<span class="keyword">null</span>) bos.close();</span><br><span class="line"> 			&#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line"> 			&#123;</span><br><span class="line">	 			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-字符流"><a href="#2-字符流" class="headerlink" title="2.字符流"></a>2.字符流</h2><h3 id="2-1定义"><a href="#2-1定义" class="headerlink" title="2.1定义"></a>2.1定义</h3><p>前面我们讲过的InputStream和OutputStream类在读写文件时操作的都是字节，如果希望在程序中操作字符，使用这两个类就不太方便，为此JDK提供了字符流。同字节流一样，字符流也有两个抽象的顶级父类，分别是Reader和Writer。其中Reader是字符输入流，用于从某个源设备读取字符，Writer是字符输出流，用于向某个目标设备写入字符。其API跟字节流的类似。  </p>
<h3 id="2-2输入字符流-Reader"><a href="#2-2输入字符流-Reader" class="headerlink" title="2.2输入字符流(Reader)"></a>2.2输入字符流(Reader)</h3><p><strong>Demo:读取reader.txt中的字符串</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	 	FileReader reader=<span class="keyword">new</span> FileReader(<span class="string">"reader.txt"</span>);</span><br><span class="line">	 	<span class="keyword">int</span> ch;</span><br><span class="line">	 	<span class="keyword">while</span>((ch=reader.read())!=-<span class="number">1</span>)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		System.out.println((<span class="keyword">char</span>)ch);<span class="comment">//通过read()方法读取到的是int类型的值，所以需要进行强制转换。</span></span><br><span class="line">	 	&#125;</span><br><span class="line">	 	reader.close();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3输出字符流-Writer"><a href="#2-3输出字符流-Writer" class="headerlink" title="2.3输出字符流(Writer)"></a>2.3输出字符流(Writer)</h3><p><strong>Demo:将字符串输出到目标文件中</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		FileWrite out=<span class="keyword">new</span> FileWrite(目标文件的路径);</span><br><span class="line">		String str=<span class="string">"hello world"</span>;</span><br><span class="line">		</span><br><span class="line">		out.write(str);</span><br><span class="line">		out.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-4字符缓冲流"><a href="#2-4字符缓冲流" class="headerlink" title="2.4字符缓冲流"></a>2.4字符缓冲流</h3><p>字符流同样提供了带缓冲区的包装流，分别是BufferedWriter和BufferedReader,其中BufferedReader用于对字符输入流的包装，BufferedWriter用于对字符输出流的包装。需要注意的是，在BufferedReader中有一个重要的方法readLine()，该方法用于一次读取一行文本。接下来通过一个例子学习如何使用这两个包装流实现文件的复制。  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	 	String fileName=<span class="string">"/Users/codingBoy/Desktop/example1.jpg"</span>;<span class="comment">//源文件路径</span></span><br><span class="line">	 	String fileName2=<span class="string">"/Users/codingBoy/Desktop/example2.jpg"</span>;<span class="comment">//目标文件路径</span></span><br><span class="line">	 	Reader reader=<span class="keyword">null</span>;</span><br><span class="line">	 	BufferedReader bf=<span class="keyword">null</span>;</span><br><span class="line">	 	Writer writer=<span class="keyword">null</span>;</span><br><span class="line">	 	BufferedWriter bw=<span class="keyword">null</span>;</span><br><span class="line">	 	<span class="keyword">try</span> &#123;</span><br><span class="line">	 		reader = <span class="keyword">new</span> Reader(fileName);</span><br><span class="line">	 		br=<span class="keyword">new</span> BufferedReader(reader);</span><br><span class="line">	 		writer = <span class="keyword">new</span> Writer(fileName2);</span><br><span class="line">	 		bw=<span class="keyword">new</span> BufferedWriter(writer);</span><br><span class="line">	 		String str;</span><br><span class="line">	 		<span class="keyword">while</span> ((str = bf.readLine())!= <span class="keyword">null</span>) &#123;</span><br><span class="line">	 			bw.write(str);</span><br><span class="line">	 			bw.newLine();<span class="comment">//写入一个换行符，该方法会根据不同的操作系统生成相应的换行符。</span></span><br><span class="line">	 		&#125;</span><br><span class="line">		 &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">		 &#123;</span><br><span class="line">		 	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line"> 		 &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		 	<span class="keyword">try</span> &#123;</span><br><span class="line">		 		<span class="keyword">if</span> (reader != <span class="keyword">null</span>) reader.close();</span><br><span class="line">		 		<span class="keyword">if</span> (br !=<span class="keyword">null</span>) br.close();</span><br><span class="line">				<span class="keyword">if</span> (writer!=<span class="keyword">null</span>) writer.close();</span><br><span class="line">				<span class="keyword">if</span> (bw !=<span class="keyword">null</span>) bw.close();</span><br><span class="line"> 			&#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line"> 			&#123;</span><br><span class="line">	 			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">			&#125;</span><br><span class="line"> 		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-转换流"><a href="#3-转换流" class="headerlink" title="3.转换流"></a>3.转换流</h2><p>前面提到IO流可分为字节流和字符流，有时字节流和字符流之间也需要进行转换。在JDK中提供了两个类可以将字节流转换为字符流，它们分别是InputStreamReader和OutputStreamWriter。  </p>
<p>转换流也是一种包装流，其中OutputStreamWriter是Writer的子类，它可以将一个字节输出流包装成字符输出流，方便直接写入字符，而InputStreamReader是Reader的子类，它可以将一个字节输入流包装成字符输入流，方便直接读取字符。  </p>
<p><strong>Demo:将字节流转换为字符流</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	 	String fileName=<span class="string">"/Users/codingBoy/Desktop/example1.jpg"</span>;<span class="comment">//源文件路径</span></span><br><span class="line">	 	String fileName2=<span class="string">"/Users/codingBoy/Desktop/example2.jpg"</span>;<span class="comment">//目标文件路径</span></span><br><span class="line">	 	InputStreamReader isr=<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(fileName1));</span><br><span class="line">	 	BufferedReader br=<span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">	 	</span><br><span class="line">	 	OutputStreamWriter osw=<span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(fileName2));</span><br><span class="line">	 	BufferedWriter bw=<span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">	 	</span><br><span class="line">	 	String line;</span><br><span class="line">	 	<span class="keyword">while</span>((line=br.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		bw.write(line);</span><br><span class="line">	 	&#125;</span><br><span class="line">	 	</span><br><span class="line">	 	br.close();</span><br><span class="line">	 	bw.close();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-其他IO流"><a href="#4-其他IO流" class="headerlink" title="4.其他IO流"></a>4.其他IO流</h2><h4 id="4-1ByteArrayInputStream和ByteArrayOutputStream"><a href="#4-1ByteArrayInputStream和ByteArrayOutputStream" class="headerlink" title="4.1ByteArrayInputStream和ByteArrayOutputStream"></a>4.1ByteArrayInputStream和ByteArrayOutputStream</h4><p>在前面的学习中，都是将文件直接存储到硬盘，但有时候我们希望将文件临时存储到缓冲区，方便以后读取。为此JDK中提供了一个ByteArrayOutputStream类。该类会在创建对象时就创建一个byte型数组的缓冲区，当向数组中写数据时，该对象会把所有的数据先写入缓冲区，最后一次行写入文件。<br><strong>Demo:将数据写入缓冲区</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	 	String fileName1=<span class="string">"/Users/codingBoy/Desktop/example1.jpg"</span>;<span class="comment">//源文件路径</span></span><br><span class="line">	 	String fileName2=<span class="string">"/Users/codingBoy/Desktop/example2.jpg"</span>;<span class="comment">//目标文件路径</span></span><br><span class="line">	 	FileInputStream in=<span class="keyword">new</span> FileInputStream(fileName1);</span><br><span class="line">	 	ByteArrayOutputStream bos=<span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">	 	FileOutputStream out=<span class="keyword">new</span> FileOutputStream(fileName2);</span><br><span class="line">	 	</span><br><span class="line">	 	<span class="keyword">int</span> b;</span><br><span class="line">	 	<span class="keyword">while</span>((b=in.read())!=-<span class="number">1</span>)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		bos.write(b);<span class="comment">//先将数据写入缓冲区，当需要写入目标文件中的时候再调用输出流的write(bos.toByteArray())方法。</span></span><br><span class="line">	 	&#125;</span><br><span class="line">	 	</span><br><span class="line">	 	in.close();</span><br><span class="line">	 	bos.close();</span><br><span class="line">	 	out.write(bos.toByteArray());</span><br><span class="line">	 	out.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在该例中，定义了一个ByteArrayOutputStream对象，将从fileName1文件中读取的字节全部写入该对象的缓冲区，通过FileOutputStream对象将缓冲区的数据一次性写入fileName2文件。  </p>
<p>与ByteArrayOutputStream类似，ByteArrayInputStream是从缓冲区中读取数据，接下来通过一个案例来演示ByteArrayInputStream如何读取缓冲区的数据。  </p>
<p><strong>Demo:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">byte</span>[] bytes=<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>,<span class="number">100</span>&#125;;</span><br><span class="line">	 	ByteArrayInputStream bis=<span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">	 	</span><br><span class="line">	 	<span class="keyword">int</span> b;</span><br><span class="line">	 	<span class="keyword">while</span>((b=bis.read())!=-<span class="number">1</span>)</span><br><span class="line">	 	&#123;</span><br><span class="line">	 		System.out.println((<span class="keyword">char</span>)b);</span><br><span class="line">	 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="5-联系"><a href="#5-联系" class="headerlink" title="5.联系"></a>5.联系</h2><p>If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><p><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a> </p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb学习笔记之Jdbc(二)]]></title>
      <url>http://codingxiaxw.cn/2016/10/16/18-JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BJdbc%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1.事务"></a>1.事务</h2><h3 id="1-1事务的四大特性-ACID"><a href="#1-1事务的四大特性-ACID" class="headerlink" title="1.1事务的四大特性(ACID)"></a>1.1事务的四大特性(ACID)</h3><ul>
<li>1.原子性:事务中的所有操作要么全部执行成功，要么执行全部失败。</li>
<li>2.一致性:事务执行后，数据库状态与其它业务规则保持一致。</li>
<li>3.隔离性:隔离性是指在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。</li>
<li>4.持久性:一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库中。即使提交事务后数据库马上崩溃，在数据库重启后，也必须能保证通过某种机制恢复数据。  </li>
</ul>
<a id="more"></a>
<h3 id="1-2mysql中操作事务"><a href="#1-2mysql中操作事务" class="headerlink" title="1.2mysql中操作事务"></a>1.2mysql中操作事务</h3><p>在控制台中输入语句:<code>start transaction;</code>即开始事务。  </p>
<p>在控制台中输入语句:<code>commit transaction;</code>即提交事务。  </p>
<p>在控制台中输入语句:<code>rollback;</code>回滚事务，即在此事务中执行的操作全部无效，数据库回到<code>start transaction;</code>之前(前提是使用该语法前没有执行<code>commit transaction;</code>操作)。  </p>
<h3 id="1-3Jdbc中操作事务"><a href="#1-3Jdbc中操作事务" class="headerlink" title="1.3Jdbc中操作事务"></a>1.3Jdbc中操作事务</h3><p>在Jdbc中处理事务都是通过Connection对象完成的，同一事务中的所有操作，都在使用同一个Connection对象。  </p>
<p><code>setAutoCommit(boolean);</code>设置是否自动提交事务，如果为true表示自动提交(默认值就是true)，也就是每条执行的sql语句都是一个单独的事务，如果设置false，那么就相当于开启了事务了。<code>con.setAutoCommit(false);</code>语句表示开启事务。  </p>
<p><code>con.commit();</code>提交并结束事务。</p>
<p><code>con.rollback();</code>回滚事务。</p>
<h2 id="2-事务的隔离级别"><a href="#2-事务的隔离级别" class="headerlink" title="2.事务的隔离级别"></a>2.事务的隔离级别</h2><h3 id="2-1事务的并发读问题"><a href="#2-1事务的并发读问题" class="headerlink" title="2.1事务的并发读问题"></a>2.1事务的并发读问题</h3><ul>
<li>脏读:读取到另一份事务未提交数据，即读到了脏数据。</li>
<li>不可重复读：两次读取不一致。对统一记录的两次读取不一致，因为另一事务对该记录做了修改。</li>
<li>幻读：又叫虚读。对同一张表的两次查询不一致，因为另一事务进行了插入了一条记录的操作。</li>
</ul>
<h3 id="2-2四大隔离级别-防止上述问题"><a href="#2-2四大隔离级别-防止上述问题" class="headerlink" title="2.2四大隔离级别(防止上述问题)"></a>2.2四大隔离级别(防止上述问题)</h3><ul>
<li>a.SERIALIZABLE(串行化)：不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的。性能最差，可能导致死锁。</li>
<li>b.REPEATABLE READ(可重复读)(mysql默认级别)：防止脏读和不可重复读，不能处理幻读问题。性能比a的好。</li>
<li>c.READ COMMITTED(读已提交数据)(Oracle默认级别)：防止脏读，没有处理不可重复读，也没有处理幻读。性能比上述b好。</li>
<li>d.READ UNCOMMITTED(读未提交数据):可能出现任何事务并发问题。性能最好。但基本没人用。  </li>
</ul>
<h3 id="2-3查看mysql的隔离级别"><a href="#2-3查看mysql的隔离级别" class="headerlink" title="2.3查看mysql的隔离级别"></a>2.3查看mysql的隔离级别</h3><p>在控制台中输入语句:<code>select @@tx_isolation;</code>  </p>
<p>也可以通过下面命令来设置隔离级别:<code>set transaction isolationlevel[4选1];</code></p>
<h3 id="2-4在Jdbc中设置隔离级别"><a href="#2-4在Jdbc中设置隔离级别" class="headerlink" title="2.4在Jdbc中设置隔离级别"></a>2.4在Jdbc中设置隔离级别</h3><p><code>con.setTransactionisolation[int lever];</code>  </p>
<h2 id="3-数据库连接池"><a href="#3-数据库连接池" class="headerlink" title="3.数据库连接池"></a>3.数据库连接池</h2><p>用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并且极易造成数据库服务器内存溢出、拓机。如下图所示:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="">  </p>
<p>数据库连接是一种关键的有限的昂贵的资源,这一点在多用户的网页应用程序中体现的尤为突出.。对数据库连接的管理能显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。数据库连接池正式针对这个问题提出来的。数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。如下图所示:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.png" alt="">  </p>
<p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量.连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中。  </p>
<p>数据库连接池的最小连接数和最大连接数的设置要考虑到以下几个因素:  </p>
<ul>
<li><p>1.最小连接数(MinActive):是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有大量的数据库连接资源被浪费。</p>
</li>
<li><p>2.最大连接数(MaxActive):是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将被加入到等待队列中,这会影响以后的数据库操作。</p>
</li>
<li><p>3.如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被释放,他将被放到连接池中等待重复使用或是空间超时后被释放。  </p>
</li>
</ul>
<h3 id="3-1池参数-所有池参数都有默认值"><a href="#3-1池参数-所有池参数都有默认值" class="headerlink" title="3.1池参数(所有池参数都有默认值)"></a>3.1池参数(所有池参数都有默认值)</h3><pre><code>设置初始化大小:connection.setInitialSize();
设置最小空闲连接数:connection.setMinIdle();
设置最大空闲连接数:connection.setMaxIdle();
设置最小连接数:connection.setMinActive();
设置最大连接数:connection.setMaxActive();
设置增量:一次创建的最小单位。
设置最大的等待时间:connection.setMaxWait();
</code></pre><h3 id="3-2四大连接参数"><a href="#3-2四大连接参数" class="headerlink" title="3.2四大连接参数"></a>3.2四大连接参数</h3><p>连接池也是使用Jdbc中的四大连接参数和驱动jar包来完成创建连接对象。</p>
<h3 id="3-3实现的接口"><a href="#3-3实现的接口" class="headerlink" title="3.3实现的接口"></a>3.3实现的接口</h3><p>连接池必须实现javax.sql.DataSource接口。  </p>
<p>从连接池返回的Connection对象，它的close()方法与众不同。调用它的close()方法不是关闭，而是把连接归还给池。  </p>
<h3 id="3-4DBCP数据库连接池"><a href="#3-4DBCP数据库连接池" class="headerlink" title="3.4DBCP数据库连接池"></a>3.4DBCP数据库连接池</h3><p>DBCP是Apache软件基金组织下的开源连接池实现，要使用DBCP数据源，需要应用程序应在系统中增加如下两个jar文件:</p>
<ul>
<li>Commons-dbcp.jar：连接池的实现</li>
<li>Commons-pool.jar：连接池实现的依赖库</li>
</ul>
<p><strong>Demo:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 *1.创建连接池对象</span><br><span class="line">		 *2.配置四大参数</span><br><span class="line">		 *3.配置池参数</span><br><span class="line">		 *4.得到连接对象</span><br><span class="line">		 */</span></span><br><span class="line">		BasicDataSource dataSource=<span class="keyword">new</span> BasicDataSource();</span><br><span class="line">		</span><br><span class="line">		dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);</span><br><span class="line">		dataSource.setUrl(“jdbc:mysql:<span class="comment">//localhost:3306/mydb”);</span></span><br><span class="line">		dataSource.setUsername(“root”);</span><br><span class="line">		dataSource.setPassword(<span class="number">123</span>);</span><br><span class="line">		</span><br><span class="line">		dataSource.setMaxActive(<span class="number">20</span>);</span><br><span class="line">		dataSource.setMinIdle(<span class="number">3</span>);</span><br><span class="line">		dataSource.setMaxWait(<span class="number">1000</span>);</span><br><span class="line">		</span><br><span class="line">		Connection con=dataSource.getConnection();</span><br><span class="line">		System.out.println(con);</span><br><span class="line">		</span><br><span class="line">	  <span class="comment">/*</span><br><span class="line">		*连接池内部使用四大参数创建了连接对象，即mysql驱动提供的Connection</span><br><span class="line">		*连接池使用mysql的连接对象进行了装饰，只对close()方法进行了增强！</span><br><span class="line">		*装饰之后的Connection的close()方法，用来把当前连接归还给池</span><br><span class="line">		*/</span></span><br><span class="line">		con.close();<span class="comment">//把连接归还给池。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>既然谈到装饰，那下面我们就在下文3.7中来谈谈装饰者模式。  </p>
<h3 id="3-5c3p0数据库连接池"><a href="#3-5c3p0数据库连接池" class="headerlink" title="3.5c3p0数据库连接池"></a>3.5c3p0数据库连接池</h3><p>c3p0,全名叫ComboPooledDataSource;   </p>
<p>需要导入的jar包:</p>
<ul>
<li>连接池的实现:c3p0-0.9.5.2.jar</li>
<li>依赖库:mchange－commons.jar   </li>
</ul>
<p><strong>Demo:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="comment">//创建连接池对象</span></span><br><span class="line">		ComboPooledDataSource dataSource=<span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//进行四大参数的配置</span></span><br><span class="line">		dataSource.setDriverClass(“com.mysql.jdbc.Driver”);</span><br><span class="line">		dataSource.setJdbcUrl(“jdbc:mysql:<span class="comment">//localhost:3306/mydb”);</span></span><br><span class="line">		dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">		dataSource.setPassword(<span class="string">"123"</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//池配置</span></span><br><span class="line">		dataSource.setAcquireIncrement(<span class="number">5</span>);</span><br><span class="line">		dataSource.setInitialPoolSize(<span class="number">20</span>);</span><br><span class="line">		dataSource.setMinPoolSize(<span class="number">2</span>);</span><br><span class="line">		dataSource.setMaxPoolSize(<span class="number">50</span>);</span><br><span class="line">		</span><br><span class="line">		Connection con=dataSource.getConnection();</span><br><span class="line">		System.out.println(con);</span><br><span class="line">		</span><br><span class="line">		con.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-5-1c3p0配置文件的使用"><a href="#3-5-1c3p0配置文件的使用" class="headerlink" title="3.5.1c3p0配置文件的使用"></a>3.5.1c3p0配置文件的使用</h4><p>配置文件要求:</p>
<blockquote>
<p>文件名称:必须叫c3p0-config.xml。<br>文件的位置:必须在src下。  </p>
</blockquote>
<p><strong>c3p0配置文件:</strong><br><img src="http://od2xrf8gr.bkt.clouddn.com/c3p0%E9%85%8D%E7%BD%AE.png" alt="">  </p>
<p><strong>写入配置文件后的Demo:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span><br><span class="line">	</span>&#123;</span><br><span class="line">		<span class="comment">//在创建连接池对象时，这个对象就会自动加载配置文件，不用我们来指定。</span></span><br><span class="line">		ComboPooledDataSource data=<span class="keyword">new</span> comboPooledDataSource();</span><br><span class="line">		Connection con=data.getConnection();</span><br><span class="line">		System.out.println(con);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-6Tomcat配置数据库连接池"><a href="#3-6Tomcat配置数据库连接池" class="headerlink" title="3.6Tomcat配置数据库连接池"></a>3.6Tomcat配置数据库连接池</h3><h4 id="3-6-1Tomcat配置JNDI资源"><a href="#3-6-1Tomcat配置JNDI资源" class="headerlink" title="3.6.1Tomcat配置JNDI资源"></a>3.6.1Tomcat配置JNDI资源</h4><p><strong>JNDI:</strong>java命名和目录接口。作用:在服务器上配置资源，然后通过统一的方式来获取配置的资源。  </p>
<p>首先需要在Tomcat/conf/Catelina/localhost目录下新建文件名: 项目名.xml  </p>
<p>在该.xml文件中写入以下内容<br><img src="http://od2xrf8gr.bkt.clouddn.com/jdni.png" alt="">  </p>
<h4 id="3-6-1获取资源的代码"><a href="#3-6-1获取资源的代码" class="headerlink" title="3.6.1获取资源的代码"></a>3.6.1获取资源的代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Context initCtx=<span class="keyword">new</span> InitialContext();<span class="comment">//创建一个上下文。</span></span><br><span class="line"></span><br><span class="line">Context envCtx=(Context) initCtx.lookup(“java:comp/env”);<span class="comment">//这个路径是固定的不能改。</span></span><br><span class="line"></span><br><span class="line">MyBean bean=(MyBean)envCtx.lookup(“bean/MyBeanFactory”);<span class="comment">//通过该上下文进行二次查找才能找到资源。</span></span><br></pre></td></tr></table></figure>
<p><strong>Demo:测试类</strong></p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202016-10-17%20%E4%B8%8B%E5%8D%888.43.16.png" alt=""></p>
<h3 id="3-7装饰者模式"><a href="#3-7装饰者模式" class="headerlink" title="3.7装饰者模式"></a>3.7装饰者模式</h3><p>将对象增强的手段有:</p>
<ul>
<li>继承  <blockquote>
<p>缺点:1.增强的内容是死的，不能动。2.被增强的对象也是死的。</p>
</blockquote>
</li>
<li>装饰者模式<blockquote>
<p>特点:1.增强的内容是不能修改的。2.被增强的对象可以是任意的。</p>
</blockquote>
</li>
<li>动态代理(AOP):以后再详讲，博客出来后会给出链接。</li>
</ul>
<p><strong>下面通过一个简单的例子来对装饰者模式进行讲解</strong></p>
<pre><code>class 咖啡类 {};
class 加奶咖啡 extends 咖啡类 {};
class 加糖咖啡 extends 咖啡类 {};
class 加盐咖啡 extends 咖啡类 {};

咖啡 a＝new 加糖咖啡();
咖啡 b＝new 加盐咖啡(a);//对a进行装饰，就是给a加盐
咖啡 c＝new 加奶咖啡(b);//对b进行装饰，就是给b加奶
</code></pre><p>装饰者模式在Java API中的IO流中用到的很多。如BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter、ObjectInputStream、ObjectOutputStream这几个都是运用了装饰模式的装饰流。关于的IO流的详情见下篇博客<a href="http://codingxiaxw.cn/2016/10/17/19-Java%E4%B9%8BIO%E6%B5%81%E8%AF%A6%E8%A7%A3/">Java之IO流详解</a>。</p>
<h2 id="4-ThreadLocal"><a href="#4-ThreadLocal" class="headerlink" title="4.ThreadLocal"></a>4.ThreadLocal</h2><p>早在JDK 1.2的版本中就提供Java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p>
<h3 id="4-1Thread-API"><a href="#4-1Thread-API" class="headerlink" title="4.1Thread API"></a>4.1Thread API</h3><ul>
<li>void set(Object value);设置当前线程的线程局部变量的值。</li>
<li>Object get();该方法返回当前线程所对应的线程局部变量。</li>
<li>void remove();将当前线程局部变量的值删除，目的是为了减少内存的占用。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。  </li>
</ul>
<h3 id="4-2ThreadLocal内部结构"><a href="#4-2ThreadLocal内部结构" class="headerlink" title="4.2ThreadLocal内部结构"></a>4.2ThreadLocal内部结构</h3><p>ThreadLocal内部用Map来保存数据。虽然在使用上述API时没有给出键，但其实它内部使用了当前线程作为键。内部结构见下面demo:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadLocal</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Map&lt;Thread,T&gt; map=<span class="keyword">new</span> HashMap&lt;Thread,T&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">		map.put(Thread.currentThread(),value);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">		map.remove(Thread.currentThread());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> map.get(Thread.currentThread());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-dbtils结果集处理器介绍"><a href="#5-dbtils结果集处理器介绍" class="headerlink" title="5.dbtils结果集处理器介绍"></a>5.dbtils结果集处理器介绍</h2><p>需要导入的jar包:</p>
<ul>
<li>common-dbutil.jar</li>
<li>c3p0.jar</li>
<li>mchange-commons.jar</li>
</ul>
<p>关键要得到QueryRunner对象，然后调用其各种方法。</p>
<ul>
<li><p>update()方法:</p>
<blockquote>
<p>1.int update(String sql,Object… params)  可执行增删改语句。<br>2.重载方法int update(Connection con,String sql, Object… params)需要调用者提供Connection，这说明本方法不再管理Connection了。本重载方法支持事务。</p>
</blockquote>
</li>
<li><p>query()方法:</p>
<blockquote>
<p>1.T query (String sql,ResultSetHandler rsh,Object… params)可执行查询操作。<br>2.重载方法:T query(Connection con,String sql,ResultSetHandler rsh,Object… params);  本重载方法支持事务。它会先得到ResultSet，然后调用rsh的handle()把rs转换成需要的类型。</p>
</blockquote>
</li>
<li><p>ResultSetHandler接口</p>
<blockquote>
<p>1.BeanHandler(单行)－－&gt;构造器需要一个class类型的参数，用来把一行结果转换成指定类型的javaBean对象。<br>2.BeanListHandler(多行)—&gt;构造器也是需要一个Class类型的参数，用来把一行结果集转换成一个javabean，哪么多行就是转换成List对象，一堆javabean。<br>3.MapHandler(单行)—&gt;把一行结果集转换成Map对象。<br>4.MapListHandler(多行)—&gt;把一行记录转换成一个Map，多行就是多个Map，即List<map>。<br>5.ScalarHandler(单行单列)－&gt;同来用于select count(＊)from t_stu语句，结果集是单行单列的，它返回一个Object，就是count(*)的值，为long类型。  </map></p>
</blockquote>
</li>
</ul>
<p><strong>dbutil结果处理集原理代码:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> demo;</span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Created by codingBoy on 16/10/19.</span><br><span class="line"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QR</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line"> </span>&#123;</span><br><span class="line">   	<span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">QR</span><span class="params">(DataSource dataSource)</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.dataSource=dataSource;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">QR</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(String sql,Object... params)</span></span><br><span class="line">   </span>&#123;</span><br><span class="line">       Connection con=<span class="keyword">null</span>;</span><br><span class="line">       PreparedStatement pstmt=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           con=dataSource.getConnection();<span class="comment">//通过连接池得到连接对象</span></span><br><span class="line">           pstmt=con.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">           initParams(pstmt,params);<span class="comment">//给出参数</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> pstmt.executeUpdate();<span class="comment">//调用update执行增、删、该</span></span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="keyword">try</span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (pstmt!=<span class="keyword">null</span>) pstmt.close();</span><br><span class="line">               <span class="keyword">if</span> (con!=<span class="keyword">null</span>) con.close();</span><br><span class="line">           &#125;<span class="keyword">catch</span> (SQLException e)&#123;&#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//给参数赋值</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initParams</span><span class="params">(PreparedStatement pstmt,Object... params)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++)</span><br><span class="line">       &#123;</span><br><span class="line">           pstmt.setObject(i+<span class="number">1</span>,params[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> T <span class="title">query</span><span class="params">(String sql,RsHandler&lt;T&gt; rh,Object... params)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       Connection con=<span class="keyword">null</span>;</span><br><span class="line">       PreparedStatement pstmt=<span class="keyword">null</span>;</span><br><span class="line">       ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span></span><br><span class="line">       &#123;</span><br><span class="line">           con=dataSource.getConnection();<span class="comment">//通过连接池得到连接对象</span></span><br><span class="line">           pstmt=con.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">           initParams(pstmt,params);<span class="comment">//给出参数</span></span><br><span class="line"></span><br><span class="line">           rs=pstmt.executeQuery();<span class="comment">//调用update执行增、删、该</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> rh.handle(rs);</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (rs!=<span class="keyword">null</span>) rs.close();</span><br><span class="line">           <span class="keyword">if</span> (pstmt!=<span class="keyword">null</span>) pstmt.close();</span><br><span class="line">           <span class="keyword">if</span> (con!=<span class="keyword">null</span>) con.close();</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">interface</span> <span class="title">RsHandler</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">   </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> T <span class="title">handle</span><span class="params">(ResultSet rs)</span></span>;</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样我们以后对数据库进行增、删、改操作时，只需写以下代码即可:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.QueryRunner qr=new QueryRunner(JdbcUtils.getDataSource);//创建QueryRunner对象，并传入连接池对象</span><br><span class="line"></span><br><span class="line">2.String sql="insert into user values(?,?,?,?);//给出sql语句模板</span><br><span class="line">3.Object[] params=&#123;参数1，参数2，参数3，参数4&#125;;//传入参数</span><br><span class="line">4.qr.update(sql,params);//调用qr方法。</span><br></pre></td></tr></table></figure>
<p>通过这简单的四步就可以对数据库进行增删改了。  </p>
<p>对数据库进行查询操作时，只需写以下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.QueryRunner qr=<span class="keyword">new</span> QueryRunner(JdbcUtils.getDataSource);<span class="comment">//创建QueryRunner对象，并传入连接池对象</span></span><br><span class="line"><span class="number">2</span>.String sql=<span class="string">"select * from user where id=?"</span>;<span class="comment">//给出sql语句模板</span></span><br><span class="line"><span class="number">3</span>. Object[] params=&#123;参数&#125;;<span class="comment">//传入参数</span></span><br><span class="line"><span class="comment">//4. ResultSetHandler&lt;Object&gt; rsh=new ResultSetHandler()&#123;</span></span><br><span class="line"><span class="comment">//		@Override</span></span><br><span class="line"><span class="comment">//		public Object handle(Result rs) throws SQLException&#123;</span></span><br><span class="line"><span class="comment">//			return null;</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//	&#125;;</span></span><br><span class="line"><span class="number">5</span>.Object object=qr.query(sql,<span class="keyword">new</span> BeanHandler&lt;Object&gt;(Object.class),params);</span><br></pre></td></tr></table></figure></p>
<p>通过这几步即可实现对数据的查询操作了。  </p>
<p><strong>下面的解释写给自己看的:关于connection是否关闭的问题</strong>  </p>
<p>在jar包中，QueryRunner类的update(没有connection参数的)方法，在finally中将connection进行了关闭;在update(有connection参数的)方法中，在finally中没有对connection进行关闭(暂时这么记吧，不然要是进行关闭了的话，在传智播客写的小工具封装类TxQueryRunner中将connection传入JdbcUtils的releaseConnecion()方法中对connection进行关闭时会出现报错)。</p>
<p>在讲到事务时，我们会对QueryRunner进行再次封装。上述写出的QueryRunner的代码只是包中的QueryRunner源码方法的一部分(因为源码中还有很多的重载方法)，我们会通过另一个类TxQueryRunner(较QueryRunner多出的一个功能就是它支持事务)继承该类，在TxQueryrunner类中，对connection进行了判断:若connection为事务中的connection则在TxqueryRunner的update()方法中不对connection进行关闭，而是在commitTransaction()即提交事务时进行关闭;若connection为普通连接，则将connection进行关闭。那么以后我们在DAO中要获取的就不是QueryRunner对象，而是通过<code>QueryRunner qr=new TxQueryRunner();</code>获取TxQueryRunner对象了。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb学习笔记之Jdbc(一)]]></title>
      <url>http://codingxiaxw.cn/2016/10/12/17-JavaWeb%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BJdbc%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><p>Jdbc(java database connectivity):Java数据库连接，就是用Java语言来操作数据库。原来我们操作数据库是在控制台中通过sql语句来操作数据库，而Jdbc是用Java语言来向数据库发送sql语句来操作数据库。</p>
<a id="more"></a>  
<h2 id="2-流程"><a href="#2-流程" class="headerlink" title="2.流程"></a>2.流程</h2><h3 id="2-1得到Connection对象"><a href="#2-1得到Connection对象" class="headerlink" title="2.1得到Connection对象"></a>2.1得到Connection对象</h3><ul>
<li>1.导jar包。mysql-connector-java jar</li>
<li>2.加载驱动类:Class.forName(“类名”);</li>
<li>3.给出url、username、password等参数。</li>
<li>4.使用DriverManager类来的到Connection对象。</li>
</ul>
<p><strong>时刻牢记Jdbc中的四大参数:</strong></p>
<ul>
<li>driverClassName:com.mysql.jdbc.Driver</li>
<li>url:jdbc:mysql://localhost:3306/数据库名</li>
<li>username:mysql用户名</li>
<li>password:mysql密码</li>
</ul>
<p><strong>Demo:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class="line">	</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">//加载驱动类。</span></span><br><span class="line">		String url=<span class="string">"jdbc:mysql://localhost:3306/数据库名"</span>;</span><br><span class="line">		String username=<span class="string">"root"</span>;</span><br><span class="line">		String password=<span class="string">"123"</span>;</span><br><span class="line">		</span><br><span class="line">		Connection con=DriverManager.getConnection(url,username,password);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>代码分析:</strong>  </p>
<ol>
<li>url的格式为–jdbc:厂商名称:子协议(由厂商自己来规定)。对于mysql而言，它的子协议结构的格式为://localhost:3306/数据库名。</li>
<li>出现SQLException的原因:1.url username password 是否正确。2.检查是否打开了sql服务器</li>
<li>出现ClassNotFoundException的原因:1.没导入驱动包。2.Class.forName()传入的字符串参数错误。</li>
</ol>
<h2 id="3-Jdbc对数据库进行增、删、改、查"><a href="#3-Jdbc对数据库进行增、删、改、查" class="headerlink" title="3.Jdbc对数据库进行增、删、改、查"></a>3.Jdbc对数据库进行增、删、改、查</h2><h3 id="3-1增、删、改"><a href="#3-1增、删、改" class="headerlink" title="3.1增、删、改"></a>3.1增、删、改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class="line">	</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">//加载驱动类。</span></span><br><span class="line">		String url=<span class="string">"jdbc:mysql://localhost:3306/数据库名"</span>;</span><br><span class="line">		String username=<span class="string">"root"</span>;</span><br><span class="line">		String password=<span class="string">"123"</span>;</span><br><span class="line">		</span><br><span class="line">		Connection con=DriverManager.getConnection(url,username,password);</span><br><span class="line">		</span><br><span class="line">		Statement stmt=con.createStatement();<span class="comment">//调用Connection的方法创建Statement对象，它是sql语句的发送器，功能就是向数据库发送sql语句</span></span><br><span class="line">		String sql＝<span class="string">"insert into stu values('...','...','...','...')"</span>;<span class="comment">//右括号不需要打分号，打了就会出错，因为程序会自动帮我们加。</span></span><br><span class="line">		stmt.executeUpdate(sql);<span class="comment">//调用此方法向数据库发送sql语句。该语句返回的值为改变数据库的行数。</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong>上述中出现的Connection和Statement都应该导入java.mysql下的包，而不是java.jdbc下的包。</p>
<h3 id="3-2查询"><a href="#3-2查询" class="headerlink" title="3.2查询"></a>3.2查询</h3><p><strong>Demo:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class="line">	</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">//加载驱动类。</span></span><br><span class="line">		String url=<span class="string">"jdbc:mysql://localhost:3306/数据库名"</span>;</span><br><span class="line">		String username=<span class="string">"root"</span>;</span><br><span class="line">		String password=<span class="string">"123"</span>;</span><br><span class="line">		</span><br><span class="line">		Connection con=DriverManager.getConnection(url,username,password);</span><br><span class="line">		</span><br><span class="line">		Statement stmt=con.createStatement();</span><br><span class="line">		</span><br><span class="line">		String sql=<span class="string">"selece * from stu"</span>;</span><br><span class="line">		</span><br><span class="line">		ResultSet rs=stmt.execute(sql);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*</span><br><span class="line">		 *解析ResultSet</span><br><span class="line">		 *ResultSet提供了一系列的getXxx()方法</span><br><span class="line">		 */</span></span><br><span class="line">		 <span class="keyword">while</span>(rs.next())<span class="comment">//第一次调用next()方法是将光标移动到该表的第一行</span></span><br><span class="line">		 &#123;</span><br><span class="line">		 	rs.getInt(<span class="number">1</span>);<span class="comment">//通过列编号来获取该列的值</span></span><br><span class="line">		 	rs.getString(<span class="string">"name"</span>);<span class="comment">//通过列名称来获取该列的值。</span></span><br><span class="line">		 &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-关闭资源"><a href="#4-关闭资源" class="headerlink" title="4.关闭资源"></a>4.关闭资源</h2><p>关闭资源时采用倒关的手法将对象进行处理:即先得到的对象后关，后得到的对象先关。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.close();</span><br><span class="line">stmt.close();</span><br><span class="line">con.close();</span><br></pre></td></tr></table></figure></p>
<p>为了注意代码的规范化:在try外给出引用的定义，在try内位对象实例化，在finally中对资源进行关闭。</p>
<h2 id="5-PreparedStatement-预处理"><a href="#5-PreparedStatement-预处理" class="headerlink" title="5.PreparedStatement(预处理)"></a>5.PreparedStatement(预处理)</h2><h3 id="5-1介绍"><a href="#5-1介绍" class="headerlink" title="5.1介绍"></a>5.1介绍</h3><p>PrepaerdStatement是Statement的子接口。下面通过一个例子学习PreparedStatement，注意与上述例子中Statement的区别。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException,SQLException</span>&#123;</span><br><span class="line">	</span><br><span class="line">		Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);<span class="comment">//加载驱动类。</span></span><br><span class="line">		String url=<span class="string">"jdbc:mysql://localhost:3306/数据库名"</span>;			String username=<span class="string">"root"</span>;</span><br><span class="line">		String password=<span class="string">"123"</span>;</span><br><span class="line">		</span><br><span class="line">		Connection con=DriverManager.getConnection(url,username,password);</span><br><span class="line">		</span><br><span class="line">		String sql=<span class="string">"insert into stu values(?,?)"</span>;<span class="comment">//定义sql模板，即参数以问号的形式给出</span></span><br><span class="line">		</span><br><span class="line">		PreparedStatement pst=con.prepaerStatement(sql);</span><br><span class="line">		pst.setString(<span class="number">1</span>,username);<span class="comment">//数字1代表第一个问号</span></span><br><span class="line">		pst.setString(<span class="number">2</span>.password);<span class="comment">//数字2代表第二个问号</span></span><br><span class="line">		pst.executeUpdate();<span class="comment">//向数据库发送sql语句</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-2预处理的原理"><a href="#5-2预处理的原理" class="headerlink" title="5.2预处理的原理"></a>5.2预处理的原理</h3><p>服务器的工作:</p>
<ul>
<li>1.检验sql语句的语法</li>
<li>2.编译：一个与函数相似的东西</li>
<li>3.执行：调用函数</li>
</ul>
<p>PreparedStatement使用的前提就是:连接的数据库必须支持预处理。</p>
<p>以后我们要学的DAO模式就是写一个类，把访问数据库的代码封装起来，DAO在数据库与业务逻辑层之间。</p>
<h2 id="6-Java中的时间类型和mysql中的时间类型转换"><a href="#6-Java中的时间类型和mysql中的时间类型转换" class="headerlink" title="6.Java中的时间类型和mysql中的时间类型转换"></a>6.Java中的时间类型和mysql中的时间类型转换</h2><h3 id="6-1数据库类型与Java中类型的对应关系"><a href="#6-1数据库类型与Java中类型的对应关系" class="headerlink" title="6.1数据库类型与Java中类型的对应关系"></a>6.1数据库类型与Java中类型的对应关系</h3><p>数据库中的DATE–&gt;java.sql.Date–&gt;java.util.Date;  </p>
<p>数据库中的TIME–&gt;java.sql.Time–&gt;java.util.Date;  </p>
<p>数据库中的TIMESTAMP–&gt;java.sql.Timestamp–&gt;java.util.Date;  </p>
<p><strong>需要注意的是:</strong></p>
<ul>
<li>1.领域对象(domain)中的所有属性不能出现java.sql包下的东西，即不能使用java.sql.Date、java.sql.Time、java.sql.TimeStamp。</li>
<li>2.ResultSet的getDate()返回的是java.sql.Date()。</li>
<li>3.PreparedStatment的setDate(int,Date),其中第二个参数是sql包下的java.sql.Date()。为了在java中使用sql包下的时间类型，这是就出现了时间类型的转换。</li>
</ul>
<h3 id="6-2转换"><a href="#6-2转换" class="headerlink" title="6.2转换"></a>6.2转换</h3><h4 id="6-2-1将util包下的Date转换为sql包下的Date、Time、Timestamp"><a href="#6-2-1将util包下的Date转换为sql包下的Date、Time、Timestamp" class="headerlink" title="6.2.1将util包下的Date转换为sql包下的Date、Time、Timestamp"></a>6.2.1将util包下的Date转换为sql包下的Date、Time、Timestamp</h4><p><strong>步骤如下:</strong></p>
<ul>
<li>1.把util的的Date转换成毫秒值。</li>
<li>2.使用毫秒值创建sql的Date、Time、Timestamp  <blockquote>
<p>java.util.Date date=new java.util.Date();<br>long l=date.getTime();<br>java.sql.Date sqlDate=new java.sql.Date(l);</p>
</blockquote>
</li>
</ul>
<h4 id="6-2-2将sql包下的Date、Time、Timestamp转换为util包下的Date"><a href="#6-2-2将sql包下的Date、Time、Timestamp转换为util包下的Date" class="headerlink" title="6.2.2将sql包下的Date、Time、Timestamp转换为util包下的Date"></a>6.2.2将sql包下的Date、Time、Timestamp转换为util包下的Date</h4><p>这一步不需要处理了，因为sql包下的Date、Time、和Timestamp继承自util包下的Date。所以可以直接用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> java.util.Date()=<span class="keyword">new</span> java.sql.Date();或</span><br><span class="line"><span class="keyword">new</span> java.util.Date()=<span class="keyword">new</span> java.sql.Time();或</span><br><span class="line"><span class="keyword">new</span> java.util.Date()=<span class="keyword">new</span> java.sql.Timestamp();</span><br></pre></td></tr></table></figure></p>
<h2 id="7-大数据"><a href="#7-大数据" class="headerlink" title="7.大数据"></a>7.大数据</h2><p>将大数据的歌曲存入数据库。代码日后补上。</p>
<h2 id="8-批处理"><a href="#8-批处理" class="headerlink" title="8.批处理"></a>8.批处理</h2><h3 id="8-1Statement批处理"><a href="#8-1Statement批处理" class="headerlink" title="8.1Statement批处理"></a>8.1Statement批处理</h3><p>批处理就是一批一批的处理，而不是一个一个的处理。  </p>
<p>当你有10条sql语句要执行时，一次向服务器发送一条语句，这么做效率很差。处理的方案是用批处理，即一次向服务器发送多条sql语句，然后由服务器一次性处理。  </p>
<p>批处理只针对更新(增、删、改),没有查询什么事。  </p>
<p>添加批的语句:PreparedStatement.addBatch();<br>执行批的语句:PreparedStatement.executeBatch();  </p>
<p>mysql默认批处理是关闭的，需要在url参数后面加上?rewriteBatchedStatement=true;</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="9-联系"><a href="#9-联系" class="headerlink" title="9.联系"></a>9.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySQL学习笔记二之单表查询与多表查询]]></title>
      <url>http://codingxiaxw.cn/2016/10/10/16-SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
      <content type="html"><![CDATA[<h2 id="1-解决中文乱码问题"><a href="#1-解决中文乱码问题" class="headerlink" title="1.解决中文乱码问题"></a>1.解决中文乱码问题</h2><h3 id="1-1查看MySQL数据库编码"><a href="#1-1查看MySQL数据库编码" class="headerlink" title="1.1查看MySQL数据库编码"></a>1.1查看MySQL数据库编码</h3><p>在命令行中输入:<code>SHOW VARIABLES LIKE &#39;CHAR%&#39;;</code>  回车可看到如下内容:  </p>
<a id="more"></a>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%98%E5%90%97.png" alt="">  </p>
<h3 id="1-2编码解释"><a href="#1-2编码解释" class="headerlink" title="1.2编码解释"></a>1.2编码解释</h3><ul>
<li>character_set_client: mysql使用该编码来解读客户端发送过来的数据，例如该编码为utf，那么如果客户端发送过来的数据不是utf，就会出现乱码。</li>
<li>character_set_results：mysql会把数据转换成该编码后，再发送给客户端，例如该编码为utf，那么如果客户端不使用utf来解读，那么就会出现乱码，其它编码只要支持中文即可。</li>
</ul>
<p>除了这两个编码格式外我们还需要考虑一个工具(用于编写sql语句的工具)的编码格式，即控制台(用命令行写sql语句)或者用于写sql语句的可视化工具，为什么要用”或”呢，因为二者就是一体，修改一个即一起修改了两个的编码格式。下面1.3节我在分析乱码原因后会告诉你如何保持client、results以及控制台与可视化工具这四者编码格式的一致，以解决中文乱码问题。</p>
<h3 id="1-3控制台乱码问题"><a href="#1-3控制台乱码问题" class="headerlink" title="1.3控制台乱码问题"></a>1.3控制台乱码问题</h3><p>windows系统中:  </p>
<ul>
<li>插入或修改时出现乱码：因为控制台默认使用gbk，而character_set_client不是gbk的原因。</li>
<li>查询出的数据为乱码，因为character_set_results不是gbk而控制台默认使用gbk。</li>
<li>解决方法:通过在命令行中输入代码<code>set character_set_client=gbk;</code>和<code>set character_set_results=gbk;</code>来设置编码。</li>
</ul>
<p>通过将client和results的编码格式改成gbk后使得它们二者和控制台的编码格式一致，这样便可以实现中文乱码问题解决了编码的问题。</p>
<blockquote>
<p>注意：通过上述方式我们将client、results、控制台这三者编码方式设置一致，设置编码只对当前连接有效，当退出mysql后再次登陆mysql时又回到utf了。解决方法:找到my.ini配置文件，在配置文件中设置<code>set default_character=gbk</code>即可。</p>
</blockquote>
<p>或是保持client和results的编码格式继续为utf-8，然后将控制台默认的的gbk编码方式改为utf-8格式，这种方法我没试过，毕竟我用的是mac，估计也是在控制台的my.ini配置文件中进行设置。</p>
<p>而对于我的mac系统:由于mac的控制台默认编码不是gbk(我也不知道mac系统默认是什么编码格式)，我为什么知道它的默认编码不是gbk呢，因为我修改了client和results的编码格式为gbk后，在控制台中输入中文仍显示乱码，所以我才知道它的默认编码格式不是gbk。针对mac用户我也提供如下两种方法:  </p>
<ul>
<li>1.在命令行中输入<code>set character_set_client=gbk;</code>和<code>set character_set_results=gbk;</code>来设置client和results的编码格式为gbk，然后再修改控制台的编码格式为gbk。那么如何修改控制台的编码格式呢?mac的控制台编码格式是与编写sql语句的可视化工具连在一起的，修改可视化工具的编码格式便可以修改控制台的编码格式。而我用的可视化工具为MySQL Workbench，所以我在MySQL Workbench中创建数据库时指定创建数据库的编码格式为gbk并在创建表时也设置表的编码格式为gbk,这样便保持了它们编码格式的一致，成功解决中文乱码问题。</li>
<li>2.保持client和results的编码格式继续为utf-8,然后修改可视化工具创建数据库时的编码格式为utf-8并在创建表时也指定表的编码格式为utf-8,通过这种方式也保持了它们三者编码格式的一致，成功解决编码乱码的问题。以后便可在控制台或者可视化工具中尽情的输入中文了。(ps:乱码问题真是烦了我学习javaweb的整个历程，后来在做项目时因为要向数据库中插入中文数据所以我不得不去解决这个问题，经过很长时间的奋斗，终于得到解决，所以希望我总结的经验能够帮助到正在看这篇文章的你).</li>
</ul>
<h2 id="2-备份数据库与恢复数据库"><a href="#2-备份数据库与恢复数据库" class="headerlink" title="2.备份数据库与恢复数据库"></a>2.备份数据库与恢复数据库</h2><h3 id="2-1备份数据库"><a href="#2-1备份数据库" class="headerlink" title="2.1备份数据库"></a>2.1备份数据库</h3><p>备份就是将数据库导出为sql脚本。在命令行中输入:<code>mysqldump -u用户名 -p密码 数据库名&gt;导出文件路径</code>  </p>
<blockquote>
<p>注意:1.末尾不要打分号。2.执行此语句前应该先退出mysql客户端。3.导出的内容不包括创建数据库的语句只包含数据库里面的内容。</p>
</blockquote>
<h3 id="2-2恢复数据库"><a href="#2-2恢复数据库" class="headerlink" title="2.2恢复数据库"></a>2.2恢复数据库</h3><p>就是将导出的sql脚本插入到数据库中。有如下两种实现方式:  </p>
<ul>
<li>第一种方式:1.登录mysql:<code>mysql -u用户名 -p密码</code>。2.创建数据库:<code>create database 数据库名</code>。3.输入命令:<code>mysql -uroot -p密码 数据库名&lt;备份的数据路径</code>并回车。</li>
<li>第二种方式:1.删除数据库:<code>drop database 数据库名</code>。2.重新创建数据库:<code>create database 数据库名</code>。3.切换到数据库:<code>use 数据库名</code>。4.输入命令:<code>source sql脚本路径</code>并回车。</li>
</ul>
<h2 id="3-约束"><a href="#3-约束" class="headerlink" title="3.约束"></a>3.约束</h2><p>约束是添加在列上用来约束列的。</p>
<h3 id="3-1主键约束-primary-key"><a href="#3-1主键约束-primary-key" class="headerlink" title="3.1主键约束(primary key)"></a>3.1主键约束(primary key)</h3><p>特点:1.非空。2.唯一。3.可被引用。当表的某一列被指定为主键后，该列的值就不能为空，也不能有重复值出现。  </p>
<ul>
<li><p>创建表时指定主键的两种方式:  </p>
<pre><code>1.create table emp(
  empno int primary key,
  ename varchar(50)
);

2.create table emp(
  empno int,
  ename varchar(50),
  primary key(empno)
 );
</code></pre></li>
<li><p>修改表时指定主键的方式:</p>
<pre><code>alter table emp
add primary key(empno);
</code></pre></li>
<li><p>修改表时删除主键的方式:</p>
<pre><code>alter table emp
drop primary key;
</code></pre></li>
</ul>
<h3 id="3-2主键自增长-auto-increment"><a href="#3-2主键自增长-auto-increment" class="headerlink" title="3.2主键自增长(auto_increment)"></a>3.2主键自增长(auto_increment)</h3><pre><code>create table student(
id int primary key auto_increment,
name varchar(50)
);
</code></pre><p>注意:auto_increment必须添加在int类型后，指定主键自增长后，插入数据时便可以给该主键设置null值。  </p>
<p>限制:主键自增长在群集环境下不好使，所以大部分情况下我们使用UUID来作主键。  </p>
<h3 id="3-3非空约束-not-null"><a href="#3-3非空约束-not-null" class="headerlink" title="3.3非空约束(not null)"></a>3.3非空约束(not null)</h3><p>因为某些列不能设置为null值，所以可以对列添加非空约束。  </p>
<pre><code>create table student(
id int primary key auto_increment,
name varchar(50) not null
);
</code></pre><h3 id="3-4唯一约束-unique"><a href="#3-4唯一约束-unique" class="headerlink" title="3.4唯一约束(unique)"></a>3.4唯一约束(unique)</h3><p>数据库中某些列不能设置重复的值，所以可以对列添加唯一约束。</p>
<pre><code>create table student(
id int primary key auto_increment,
name varchar(50) not null unique
);
</code></pre><h3 id="3-5概念模型"><a href="#3-5概念模型" class="headerlink" title="3.5概念模型"></a>3.5概念模型</h3><ul>
<li>在java中表现为对象模型：在java中是domain。例如：User、Student。</li>
<li>在数据库中表现为关系模型：在数据库中表现为 表。  </li>
</ul>
<p>当我们要完成一个软件系统时，需要把系统中的实体抽取出来，形成概念模型。例如部门、员工都是系统中的实体。概念模型中的实体最终会成为java中的类、数据库中的表。实体之间还存在着关系，关系有三种:</p>
<ul>
<li>1对多:例如员工和部门的关系</li>
<li>1对1:例如老公和老婆的关系</li>
<li>多对1:例如老师与学生的关系</li>
</ul>
<p>对象模型：可以双向关联，而且引用的是对象，而不是一个主键。  </p>
<p>关系模型：只能多方引用一方，而且引用的是主键，而不是一整行记录。</p>
<h3 id="3-6外键约束"><a href="#3-6外键约束" class="headerlink" title="3.6外键约束"></a>3.6外键约束</h3><ul>
<li>1.外键必须是另一表(或自己表)的主键的值(即外键要引用主键的值)。</li>
<li>2.外键可以为空。</li>
<li>3.外键可重复。</li>
<li><p>4.一张表可以有多个外键。</p>
<pre><code>create table dept(
deptno int primary key auto_increment,
name varchar(50)
);

create table emp(
empno int primary key auto_increment,
name varchar(50), 
dno int,
constraint fk_emp_dept  foreign key(dno)  references dept (deptno)
);
</code></pre></li>
</ul>
<p>最后一行就是给emp表添加外键约束，添加外键约束后，在emp表中对dno列进行赋值时就应该考虑外键约束的三个条件了。(上图创建的两张表演示的也是数据库中1对多的关系。)</p>
<h3 id="3-7数据库中1对1的关系"><a href="#3-7数据库中1对1的关系" class="headerlink" title="3.7数据库中1对1的关系"></a>3.7数据库中1对1的关系</h3><pre><code>create table husband (
hid int primary key auto_increment,
hname varchar(50)
);

insert into husband values(null,’刘备’);
insert into husband values(null,’张飞’);
insert into husband values(null,’关羽’);

create table wife(
wid int primary key auto_increment,
wname varchar(50),
constraint fk_wife_husband foreign key (wid)  references husband(hid)
);
</code></pre><p>特点:外键引用自身表的主键。</p>
<h3 id="3-8数据库中多对多的关系"><a href="#3-8数据库中多对多的关系" class="headerlink" title="3.8数据库中多对多的关系"></a>3.8数据库中多对多的关系</h3><p>在表中建立多对多关系需要使用中间表(关联表)，即需要三张表，在中间表中使用两个外键，分别引用其它两个表的主键。</p>
<pre><code>create table student(
sid int primary key auto_increment,
sname varchar(50)
);

create table teacher (
tid int primary key auto_increment,
name varchar(50)
);

create table stu_tea(
sid int,
tid int,
constraint fk_student foreign key(sid) references student(sid),
constraint fk_teacher foreign key(tid) references teacher(tid)
);

insert into student values(null,’刘德华’);
insert into student values(null,’梁朝伟);
insert into student values(null,’黄日华’);
insert into student values(null,’苗侨伟’);
insert into student values(null,’汤镇业’);

insert into teacher values(null,’崔老师’);
insert into teacher values(null,’刘老师’);
insert into teacher values(null,’石老师’);

insert into stu_tea values(1,1);
insert into stu_tea values(2,1);
insert into stu_tea values(3,1);
insert into stu_tea values(4,1);
insert into stu_tea values(5,1);
insert into stu_tea values(1,2);
insert into stu_tea values(2,2);
insert into stu_tea values(3,2);
insert into stu_tea values(3,3);
insert into stu_tea values(4,3);
insert into stu_tea values(5,3);

select * from stu_tea;
</code></pre><h2 id="4-多表查询"><a href="#4-多表查询" class="headerlink" title="4.多表查询"></a>4.多表查询</h2><h3 id="4-1分类"><a href="#4-1分类" class="headerlink" title="4.1分类"></a>4.1分类</h3><ul>
<li>合并结果集(了解)</li>
<li>连接查询</li>
<li>子查询</li>
</ul>
<h3 id="4-2合并结果集"><a href="#4-2合并结果集" class="headerlink" title="4.2合并结果集"></a>4.2合并结果集</h3><p>要求两个结果集(注意这里强调的是结果集，而不是两张表)的列数、列类型完全相同。关键字union:去除重复行;关键字union all:不去除重复行。</p>
<pre><code>create table ab(
a int, 
b,varchar(50)
);

insert into ab values(1,’1’);
insert into ab values(2,’2’);
insert into ab values(3,’3’);

create table cd(
c int,
d varchar(50)
);

insert into cd values (3,’3’);
insert into cd values (5,’5’);
insert into cd values (5,’5’);
</code></pre><p>合并操作为:</p>
<pre><code>select * from ab
union (all)
select * from cd;
</code></pre><h3 id="4-3连接查询"><a href="#4-3连接查询" class="headerlink" title="4.3连接查询"></a>4.3连接查询</h3><ul>
<li>内连接</li>
<li>外连接  <blockquote>
<p>外连接又包括左外连接、右外连接、全外连接(mysql不支持这个)</p>
</blockquote>
</li>
</ul>
<h4 id="4-3-1内连接"><a href="#4-3-1内连接" class="headerlink" title="4.3.1内连接"></a>4.3.1内连接</h4><p>方言语法:<code>select * from 表1 别名1，表2 别名2 where 别名1.xx＝别名2.xx;</code>例如:<code>select * from emp,dept  where emp.deptno=dept.deptno;</code>去除无用行后的笛卡尔积，where后的条件是主外键。  </p>
<p>标准语法:<code>select * from 表1 别名1 inner join 表2 别名2，on 别名1.xx＝别名2.xx;</code>例如:<code>:select * from emp inner join dept on emp.deptno=dept.deptno;</code>  就是把方言版的逗号改为inner join ，把where改为on了。</p>
<p>自然连接语法:<code>select * from 表1 别名1 natural  join 表2 别名2;</code>自然连接特有的特点就是它能够自己找到两个表中相同的列 即自己填全where条件。</p>
<p>内连接的特点:内连接查询出的所有记录都是满足条件的记录，不满足条件的记录不显示出来。</p>
<h4 id="4-3-2外连接"><a href="#4-3-2外连接" class="headerlink" title="4.3.2外连接"></a>4.3.2外连接</h4><p>特点:外连接有一主一次。</p>
<ul>
<li>左外连接左表为主，那么左表中所有的记录无论满足不满足条件，都打印出来。不满足条件的值用null填补。语法为:<code>select * from emp left outer join dept on emp.deptno=dept.deptno;</code></li>
<li>右外连接右表为主，那么右表中所有的记录无论满足不满足条件，都打印出来。不满足条件的值用null填补。语法为:<code>:select * from amp right outer join dept on emp.deptno=dept.deptno;</code></li>
<li>全外连接：左右表都为主，左表和右表中的记录都要打印出来，不满足条件的值用null填补。使用union将左外连接和右外连接的结果集合并起来就是全外连接。  </li>
</ul>
<h3 id="4-4子查询"><a href="#4-4子查询" class="headerlink" title="4.4子查询"></a>4.4子查询</h3><p>子查询通俗来讲，就是查询中有查询。  </p>
<p>见例子:</p>
<pre><code>/*查询本公司工资最高的员工的详细信息*/

select * 
from amp
where sal=max(sal);

此种写法错误，因为where条件中不能有聚合函数。所以想到要用子查询。

思路:首先查出最高工资:select max(sal) from amp;然后查询该工资的员工:select * from amp where sal=刚刚的查询结果。所以合并起来为：select * from amp where sal=(select max(sal) from amp);
</code></pre><h4 id="4-4-1子查询能出现的位置"><a href="#4-4-1子查询能出现的位置" class="headerlink" title="4.4.1子查询能出现的位置"></a>4.4.1子查询能出现的位置</h4><ul>
<li>where后作为条件(上述例子)</li>
<li>from后作为二次查询(下面例子)<blockquote>
<p><code>select e.empno,e.ename from (select * from amp where deptno=30) as e where 条件;</code></p>
</blockquote>
</li>
</ul>
<h4 id="4-4-2子查询的结果集"><a href="#4-4-2子查询的结果集" class="headerlink" title="4.4.2子查询的结果集"></a>4.4.2子查询的结果集</h4><ul>
<li>单行单列:<code>select * from 表1 where 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] （select 列 from 表2  where 条件);</code></li>
<li>多行单列:<code>:select * from 表1 where 列1 [=、&gt;、&lt;、&gt;=、&lt;=、!=] ［any、all、in］（select 列 from 表2  where 条件;</code></li>
<li>单行多列:<code>select * from 表1 where （列1，列2） in (select 列1，列2 from 表2 where 条件);</code></li>
<li>多行多列:该结果集用在from后作为二次查询。<code>select * from 表1,(select …) 别名 where 条件;</code></li>
</ul>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="5-联系"><a href="#5-联系" class="headerlink" title="5.联系"></a>5.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySQL学习笔记一之MySQL语法]]></title>
      <url>http://codingxiaxw.cn/2016/10/09/15-SQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<h2 id="1-SQL语句分类"><a href="#1-SQL语句分类" class="headerlink" title="1.SQL语句分类"></a>1.SQL语句分类</h2><ul>
<li>1.DDL(Data Definition Language):数据定义语言，用来定义数据库对象：库、表、列等。功能：创建、删除、修改库和表结构。</li>
<li>2.DML(Data Manipulation Language):数据操作语言，用来定义数据库记录:增、删、改表记录。</li>
<li>3.DCL(Data Control Language):数据控制语言，用来定义访问权限和安全级别。</li>
<li>4.DQL(Data Query Language):数据查询语言，用来查询记录。也是本章学习的重点。  </li>
</ul>
<a id="more"></a>
<h2 id="2-SQL数据中的属性类型"><a href="#2-SQL数据中的属性类型" class="headerlink" title="2.SQL数据中的属性类型"></a>2.SQL数据中的属性类型</h2><ul>
<li>TINYINT:1字节，小整数值。</li>
<li>SMALLINT:2字节，大整数值。</li>
<li>MEDIUMINT:3字节，大整数值。</li>
<li>INT或INTEGER:4字节，整型,大整数值。</li>
<li>FLOAT:单精度浮点数值。</li>
<li>DOUBLE(5,2):双精度浮点型数值，参数表示该浮点型数值最多有5位，其中必须有2位小数。</li>
<li>DECIMAL(M,D):小数值,参数表示该数值最多有M位，其中必须有D位小数。</li>
<li>CHAR:字符型，固定长度字符串类型:char(255)。你存入一个a字符，虽然a只占一个字符，但是它会自动给你加254个空格凑成255个长度。即数据的长度不足指定长度，它会补足到指定长度。</li>
<li>VARCHAR:可变长度字符串类型：varchar(65535),你存入的数据多长它就是多长。它会抽出几个字节来记录数据的长度。</li>
<li>TEXT(CLOB):mysql独有的数据类型，字符串类型。</li>
<li>BLOB:字节类型。</li>
<li>YEAR:年份值，格式为:YYYY</li>
<li>DATA:日期类型，格式为:yyyy-MM-dd。</li>
<li>TIME:时间类型，格式为:hh:mm:ss。</li>
<li>TIMESTAMP:时间戳类型，格式为上面二者的综合。</li>
<li>DATETIME:混合日期和时间值，格式为:YYYYMMDD HHMMSS.</li>
</ul>
<h2 id="3-SQL语句详解"><a href="#3-SQL语句详解" class="headerlink" title="3.SQL语句详解"></a>3.SQL语句详解</h2><p>当然首先需要再命令行中输入<code>mysql -uroot -p</code>来进入mysql。注意:1.MySQL语法不区分大小写，但是建议在写关键字时用大写。2.每一条语句后面以分号结尾。  </p>
<h3 id="3-1DDL-数据定义语言-语法"><a href="#3-1DDL-数据定义语言-语法" class="headerlink" title="3.1DDL(数据定义语言)语法"></a>3.1DDL(数据定义语言)语法</h3><p>该语言用来对数据库和表结构进行操作。  </p>
<p><strong>对数据库的操作:</strong>  </p>
<p>查看所有数据库:<code>SHOW DATABASES;</code>  </p>
<p>使用数据库:<code>USE 数据库名;</code>  </p>
<p>创建数据库并指定编码:<code>CREATE DATABASE [IF NOT EXISTS] 数据库名 [DEFAULT CHARACTER SET UTF8];</code>  </p>
<p>删除数据库:<code>DROP DATABASE 数据库名;</code>  </p>
<p>修改数据库的编码:<code>ALTER DATABASE 数据库名 CHARACTER SET UTF8;</code>  </p>
<p><strong>对表结构的操作</strong><br>创建表:  </p>
<pre><code>CREATE TABLE (IF NOT EXISTS) 表名(
列名 列类型，
...，
列名 列类型
)；  
</code></pre><p>查看当前数据库中所有表:<code>SHOW TABLES;</code>  </p>
<p>查看表结构:<code>DESC 表名;</code>  </p>
<p>删除表:<code>DROP 表名;</code>  </p>
<p>修改表:修改表有5个操作，但前缀都是一样的:<code>ALTER TABLE 表名...</code>  </p>
<ul>
<li>修改表之添加列:<code>ALTER TABLE 表名 add (列名 列类型，...，列名 列类型);</code></li>
<li>修改表之修改列类型:<code>ALTER TABLE 表名 MODIFY 列名 列的新类型;</code></li>
<li>修改表之列名称列类型一起修改:<code>ALTER TABLE 表名 CHANGE 原列名 新列名 列名类型;</code></li>
<li>修改表之删除列:<code>ALTER TABLE 表名 DROP 列名;</code></li>
<li>修改表之修改表名:<code>ALTER TABLE 表名 RENAME TO 新表名</code></li>
</ul>
<h3 id="3-2DML-数据操作语言-语法"><a href="#3-2DML-数据操作语言-语法" class="headerlink" title="3.2DML(数据操作语言)语法"></a>3.2DML(数据操作语言)语法</h3><p>该语言用来对表记录操作(增、删、改)。  </p>
<h4 id="3-2-1插入数据-一次插入就是插入一行"><a href="#3-2-1插入数据-一次插入就是插入一行" class="headerlink" title="3.2.1插入数据(一次插入就是插入一行)"></a>3.2.1插入数据(一次插入就是插入一行)</h4><p><code>insert into 表名 (列名1，列名2，列名3) values (列值1，列值2，列值3)</code>  </p>
<p>说明:1.在数据库中所有的字符串类型，必须使用单引号。2.(列名1，列名2，列名3)可省略，表示按照表中的顺序插入。但不建议采取这种写法，因为降低了程序的可读性。3.在命令行插入记录不要写中文，否则会出现乱码(解决控制台的乱码问题后便可插入中文，至于如何解决乱码问题请参考我的下篇文章)。  </p>
<h4 id="3-2-2修改记录-不会修改一行"><a href="#3-2-2修改记录-不会修改一行" class="headerlink" title="3.2.2修改记录(不会修改一行)"></a>3.2.2修改记录(不会修改一行)</h4><p>修改某列的全部值:<code>update 表名 set 列名1=列值1(，列名2=列值2);</code>  </p>
<p>修改(某行或者多行记录的)列的指定值:<code>update 表名 set 列名1=列值1 where 列名2=列值2 or 列名3=列值3;</code>  </p>
<p>运算符:<code>=、!=、&lt;&gt;、&lt;、&gt;、&gt;=、&lt;=、between...and、in(…)、is null、not、or、and</code>，其中in(…)的用法表示集合。例如:<code>update 表名 set 列名1=列值1 where 列名2=列值2 or 列名2=列值22</code>用in(…)写成<code>update 表名 set 列名1=列值1 where 列名2 in(列值2，列值3)</code>  </p>
<h4 id="3-2-3删除数据-删除整行"><a href="#3-2-3删除数据-删除整行" class="headerlink" title="3.2.3删除数据(删除整行)"></a>3.2.3删除数据(删除整行)</h4><p><code>delete from 表名 (where 条件);</code>不加where条件时会删除表中所有的记录，所以为了防止这种失误操作，很多数据库往往都会有备份。</p>
<h3 id="3-3DCL-数据控制语言-语法"><a href="#3-3DCL-数据控制语言-语法" class="headerlink" title="3.3DCL(数据控制语言)语法"></a>3.3DCL(数据控制语言)语法</h3><p>该语言用来定义访问权限，理解即可，以后不会多用。需要记住的是，一个项目创建一个用户，一个项目对应的数据库只有一个。这个用户只能对这个数据库有权限，其它数据库该用户就操作不了。  </p>
<h4 id="3-3-1创建用户"><a href="#3-3-1创建用户" class="headerlink" title="3.3.1创建用户"></a>3.3.1创建用户</h4><p>用户只能在指定ip地址上登录mysql:<code>create user 用户名@IP地址 identified by  ‘密码’；</code>  </p>
<p>用户可以在任意ip地址上登录:<code>create user 用户名@‘％’ identified by ‘密码’；</code>  </p>
<h4 id="3-3-2给用户授权"><a href="#3-3-2给用户授权" class="headerlink" title="3.3.2给用户授权"></a>3.3.2给用户授权</h4><p>语法:<code>grant 权限1，…，权限n on 数据库.* to 用户名@IP地址；</code>其中权限1、2、n可以直接用all关键字代替。权限例如:create,alter,drop,insert,update,delete,select。  </p>
<h4 id="3-3-3撤销授权"><a href="#3-3-3撤销授权" class="headerlink" title="3.3.3撤销授权"></a>3.3.3撤销授权</h4><p>语法:<code>revoke 权限1，…，权限n  on  数据库.*   from 用户名@ ip地址；</code>撤销指定用户在指定数据库上的指定权限。撤销例如:<code>revoke create,delete on mydb1.*  form user@localhost;</code>表示的意思是撤消user用户在数据库mydb1伤的create、alter权限。  </p>
<h4 id="3-3-4查看权限"><a href="#3-3-4查看权限" class="headerlink" title="3.3.4查看权限"></a>3.3.4查看权限</h4><p>查看指定用户的权限:<code>show grants for 用户名@ip地址；</code>  </p>
<h4 id="3-3-5删除用户"><a href="#3-3-5删除用户" class="headerlink" title="3.3.5删除用户"></a>3.3.5删除用户</h4><p><code>drop user 用户名@ip地址；</code></p>
<h3 id="3-4DQL-数据查询语言-语法"><a href="#3-4DQL-数据查询语言-语法" class="headerlink" title="3.4DQL(数据查询语言)语法"></a>3.4DQL(数据查询语言)语法</h3><p>重点，该语言用来查询记录，不会修改数据库和表结构。  </p>
<h4 id="3-4-1基本查询-后缀都是统一为from-表名"><a href="#3-4-1基本查询-后缀都是统一为from-表名" class="headerlink" title="3.4.1基本查询(后缀都是统一为from 表名)"></a>3.4.1基本查询(后缀都是统一为from 表名)</h4><ul>
<li>1.字段(列)控制  <blockquote>
<p>1.查询所有列:<code>select * from 表名;</code>其中＊表示查询所有列，而不是所有行的意思。<br>2.查询指定列:<code>select 列1，列2，列n  from 表名；</code><br>3.完全重复的记录只显示一次:在查询的列之前添加distinct:<code>select distinct $ from 表名；</code>缺省值为all。<br>4.列运算<br>a.数量类型的列可以做加、减、乘、除:<code>SELECT sal*5 from 表名；</code>说明:1.遇到null加任何值都等于null的情况，需要用到ifnull()函数。2.将字符串做加减乘除运算，会把字符串当作0。<br>b.字符串累类型可以做连续运算(需要用到concat()函数):<code>select concat(列名1，列名2) from 表名;</code>其中列名的类型要为字符串。<br>c. 给列名起别名:<code>select 列名1 (as) 别名1,列名2 (as) 别名2   from 表名；</code></p>
</blockquote>
</li>
<li>2.条件控制<blockquote>
<p>1.条件查询。在后面添加where指定条件:<code>select * from 表名 where 列名＝指定值;</code><br>2.模糊查询：当你想查询所有姓张的记录。用到关键字like。eg:<code>select * from 表名 where 列名 like ‘张_’;</code>(_代表匹配任意一个字符，％代表匹配0～n个任意字符)。  </p>
</blockquote>
</li>
</ul>
<h4 id="3-4-2排序-所谓升序和降序都是从上往下排列"><a href="#3-4-2排序-所谓升序和降序都是从上往下排列" class="headerlink" title="3.4.2排序(所谓升序和降序都是从上往下排列)"></a>3.4.2排序(所谓升序和降序都是从上往下排列)</h4><ul>
<li>1.升序:<code>select * form 表名 order by 列名 (ASC );</code> ()里面的内容为缺省值；</li>
<li>2.降序:<code>select * from 表名 order by 列名 DESC;</code></li>
<li>3.使用多列作为排序条件: 当第一列排序条件相同时，根据第二列排序条件排序(当第二列依旧相同时可视情况根据第三例条件排序)。eg:<code>select * from 表名 order by 列名1 ASC, 列名2 DESC;</code>意思是当列名1的值相同时按照列名2的值降序排。</li>
</ul>
<h4 id="3-4-3聚合函数"><a href="#3-4-3聚合函数" class="headerlink" title="3.4.3聚合函数"></a>3.4.3聚合函数</h4><ul>
<li>1.count:<code>select count(列名) from 表名；</code>,纪录有效行数。</li>
<li>2.max:<code>select max(列名) from 表名；</code>,列中最大值。</li>
<li>3.min:<code>select min(列名) from 表名；</code>,列中最小值。</li>
<li>4.sum:<code>select sum(列名) from 表名；</code>,求列的总值，null 和字符串默认为0。</li>
<li>5.avg:<code>select avg(列名) from 表名;</code>,一列的平均值。</li>
</ul>
<h4 id="3-4-4分组查询"><a href="#3-4-4分组查询" class="headerlink" title="3.4.4分组查询"></a>3.4.4分组查询</h4><p>分组查询的信息都是组的信息，不能查到个人的信息，其中查询组的信息是通过聚合函数得到的。  </p>
<p>语法：<code>select 分组列名，聚合函数1,聚合函数2  from 表名 group by 该分组列名；</code>其中分组列名需要的条件是该列名中有重复的信息。  </p>
<p>查询的结果只能为：作为分组条件的列和聚合函数；查处的信息都是组的信息。  </p>
<p>分组查询前，还可以通过关键字where先把满足条件的人分出来，再分组。语法为:<code>select 分组列，聚合函数 from 表名 where 条件 group by  分组列；</code>  </p>
<p>分组查询后，也可以通过关键字having把组信息中满足条件的组再细分出来。语法为：<code>select 分组列，聚合函数 from 表名 where 条件 group by  分组列 having 聚合函数或列名(条件)；</code>  </p>
<h4 id="3-4-5LIMIT子句-mysql中独有的语法"><a href="#3-4-5LIMIT子句-mysql中独有的语法" class="headerlink" title="3.4.5LIMIT子句(mysql中独有的语法)"></a>3.4.5LIMIT子句(mysql中独有的语法)</h4><p>LIMIT用来限定查询结果的起始行，以及总行数。  </p>
<p>例如：<code>select * from 表名  limit 4，3；</code>表示起始行为第5行，一共查询3行记录。  </p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>学过的关键字：<code>select,from,where,group by,having ,order by。</code>当一条查询语句中都包含所有这些关键字时它们的优先级是<code>select&gt;from&gt;where&gt;group by&gt;having&gt;order by</code>。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="5-联系"><a href="#5-联系" class="headerlink" title="5.联系"></a>5.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Java中使用dom4j来解析及生成xml文件]]></title>
      <url>http://codingxiaxw.cn/2016/10/04/14-%E5%9C%A8Java%E4%B8%AD%E4%BD%BF%E7%94%A8dom4j%E6%9D%A5%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>在Java中解析xml文件的方式有四种，分别是:Dom、Sax、Jdom、Dom4j。鉴于目前的趋势，我们这里来讲讲Dom4J的用法，不涉及递归等复杂操作。  </p>
<a id="more"></a>
<h2 id="2-示例—解析xml文件"><a href="#2-示例—解析xml文件" class="headerlink" title="2.示例—解析xml文件"></a>2.示例—解析xml文件</h2><p>首先我们需要创建一个文档，然后才能对其解析。  </p>
<h3 id="2-1xml文档"><a href="#2-1xml文档" class="headerlink" title="2.1xml文档"></a>2.1xml文档</h3><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;books&gt;
    &lt;book id=&quot;001&quot;&gt;
        &lt;title&gt;Harry Potter&lt;/title&gt;
        &lt;author&gt;J K.Rowling&lt;/author&gt;
    &lt;/book&gt;
    &lt;book id=&quot;002&quot;&gt;
        &lt;title&gt;Learning XML&lt;/title&gt;
        &lt;author&gt;Erik T.Ray&lt;/author&gt;
    &lt;/book&gt;
&lt;/books&gt;  
</code></pre><h3 id="2-2示例一、使用List列表方式来解析xml"><a href="#2-2示例一、使用List列表方式来解析xml" class="headerlink" title="2.2示例一、使用List列表方式来解析xml"></a>2.2示例一、使用List列表方式来解析xml</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E4%BD%BF%E7%94%A8list%E9%9B%86%E5%90%88%E6%96%B9%E6%B3%95%E6%9D%A5%E8%A7%A3%E6%9E%90xml%28%E5%B7%B2%E7%9F%A5%E5%B1%9E%E6%80%A7%29.png" alt="">  </p>
<p>以上方式是我们在知道xml文件中的详细内容(如根元素名字、根元素中包含的子元素、子元素的属性名、子元素中又包含子元素的元素名即文本内容)时采用的代码。但当我们不知道xml中的详细信息时，我们应该采用如下方式来解析xml。  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%AD%90%E5%85%83%E7%B4%A0%20%E7%94%A8list%E9%81%8D%E5%8E%86xml%E5%85%83%E7%B4%A0.png" alt=""></p>
<h3 id="2-3示例二、使用迭代器Iterator来解析xml"><a href="#2-3示例二、使用迭代器Iterator来解析xml" class="headerlink" title="2.3示例二、使用迭代器Iterator来解析xml"></a>2.3示例二、使用迭代器Iterator来解析xml</h3><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E7%9F%A5%E9%81%93%E5%B1%9E%E6%80%A7%E4%BD%BF%E7%94%A8iterator.png" alt=""></p>
<p>同示例一，以上代码也是我们在知道xml文本详细内容后采用的代码。当我们不知道xml中的详细信息时，我们应该采用如下代码方式来解析xml。<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E4%B8%8D%E7%9F%A5%E9%81%93%E5%B1%9E%E6%80%A7%E7%A7%81%E7%94%A8iterator.png" alt="">  </p>
<p>运行结果如下:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="3-示例—生成xml文件"><a href="#3-示例—生成xml文件" class="headerlink" title="3.示例—生成xml文件"></a>3.示例—生成xml文件</h2><p><img src="http://od2xrf8gr.bkt.clouddn.com/%E7%94%9F%E6%88%90xml%E6%96%87%E4%BB%B6.png" alt="">  </p>
<p>运行代码后在桌面的dom4j种即可看到如下内容:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C2.png" alt="">  </p>
<p><strong>说明:</strong>我这里用的是mac系统，文件路径是:/Users/codingBoy/Desktop/dom4j.xml，上图中的路径打错，这个才是正确的路径.</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaWeb学习笔记之EL表达式]]></title>
      <url>http://codingxiaxw.cn/2016/10/03/12-EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>EL，即Expression Language。在JavaWeb中属于JSP技术。  </p>
<p>JSP中的表达式:Java脚本表达式<code>&lt;%=Java表达式%&gt;</code>;EL表达式<code>${EL表达式}</code>。  </p>
<a id="more"></a>
<p>JavaWeb中最好不要在JSP中写Java代码，所以用EL表达式来替代Java表达式。  </p>
<h2 id="2-语法及用法"><a href="#2-语法及用法" class="headerlink" title="2.语法及用法"></a>2.语法及用法</h2><h3 id="2-1获取某个对象的值，并将其输出到页面上。"><a href="#2-1获取某个对象的值，并将其输出到页面上。" class="headerlink" title="2.1获取某个对象的值，并将其输出到页面上。"></a>2.1获取某个对象的值，并将其输出到页面上。</h3><ul>
<li>1.点运算符:<code>${stu.name}</code>，即调用域中<code>stu</code>对应的对象的<code>name</code>的读属性<code>getName()</code>。但，若stu在4个域中没有绑定相应对象，那么就在网页上输出空字符串(即什么都不输出)。  </li>
</ul>
<p><code>${stu.name}</code>相当于:  </p>
<pre><code>&lt;%  
Student stu=pageContext.getAttribute(&quot;stu&quot;);  
if(stu!=null) out.println(stu.getName());  
%&gt;
</code></pre><ul>
<li>2.[]运算符:<code>${stu[&#39;name&#39;]}</code>或者<code>${stu[&quot;name&quot;]}</code>。与点运算符作用一样，但当索引或者名称不符合Java名称规范时(如，获取数组中的某个值)，只能用[]运算符。</li>
<li>3.获取集合中的元素:List按照索引来获取元素:<code>${obj.list[1]}</code>，Map按照指定的key来获取元素:<code>${obj.map.key}</code>或者<code>${obj.map[&#39;key&#39;]}</code>。</li>
</ul>
<h3 id="2-2逻辑和数学运算"><a href="#2-2逻辑和数学运算" class="headerlink" title="2.2逻辑和数学运算"></a>2.2逻辑和数学运算</h3><ul>
<li>1.empty运算符:判断一个对象是否为null或者””，是则返回true，否则返回false。也可以判断一个数组和集合，当数组或集合对象不是null，但对象中没有原素也返回true。</li>
<li>2.数学运算符:<code>+-*/</code>。如<code>${i+1}</code></li>
<li>3.三元运算符:<code>${表达式?T表达式:F表达式}</code>。如<code>${a&gt;1?a+1:a-1}</code></li>
<li>4.不支持字符串连接。如<code>${str+str}</code>，这是错误的。</li>
</ul>
<h3 id="2-3、11个内置对象"><a href="#2-3、11个内置对象" class="headerlink" title="2.3、11个内置对象"></a>2.3、11个内置对象</h3><p>EL内置对象(或隐式对象)，即在EL表达式中可以直接调用的对象。总结起来就是有一个JSP对象，十个Map对象。</p>
<ul>
<li>pageContext:与JSP内置对象pageContext完全一样。</li>
<li>pageScope:当前页面的域对象的Map。</li>
<li>requestScope:请求域对象的Map。</li>
<li>sessionScope:会话域对象的Map。</li>
<li>applicationScope:应用域对象的Map。</li>
<li>param:请求参数的Map，key为请求参数名，value为请求参数的值。</li>
<li>paramValues:请求参数(可重名)的<code>Map&lt;String,String[])</code>，key为请求参数名，value为请求参数的值数组。</li>
<li>header:请求消息头Map，key为请求头名，value为对应的值。</li>
<li>headerValues:请求消息头(可重名)的<code>Map&lt;String,String[]&gt;</code>，key为请求名，value为请求头值数组。</li>
<li>cookie:封装cookie的<code>Map&lt;String,Cookie&gt;</code>，key为cookie的name属性，value为cookie对象本身。</li>
<li>initParam:初始化参数的Map，在web.xml中的context-param元素中定义的初始化参数。</li>
</ul>
<h3 id="2-4自定义EL函数。"><a href="#2-4自定义EL函数。" class="headerlink" title="2.4自定义EL函数。"></a>2.4自定义EL函数。</h3><h4 id="第一步：定义一个有静态方法的类。"><a href="#第一步：定义一个有静态方法的类。" class="headerlink" title="第一步：定义一个有静态方法的类。"></a>第一步：定义一个有静态方法的类。</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> net.codingXiax.util;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtil</span></span>&#123;  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toUppercase</span><span class="params">(String str)</span></span>&#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="string">"字符串"</span>;  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h4 id="第二步-配置tld。"><a href="#第二步-配置tld。" class="headerlink" title="第二步:配置tld。"></a>第二步:配置tld。</h4><p>在Web-INF目录下(也可以在其他目录下，该目录下建立安全性更高)，建立一个扩展名为tld的xml文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;  </span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span>  </span><br><span class="line">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-jsptaglibrary_2_0.xsd"</span>  </span><br><span class="line">        <span class="attr">version</span>=<span class="string">"2.0"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">tlib-version</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">short-name</span>&gt;</span>myfn<span class="tag">&lt;/<span class="name">short-name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">uri</span>&gt;</span>http://www.yrom.net/jsp/string/fn<span class="tag">&lt;/<span class="name">uri</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">function</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">name</span>&gt;</span>toUppercase<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">function-class</span>&gt;</span>net.yrom.util.StringUtil<span class="tag">&lt;/<span class="name">function-class</span>&gt;</span>  </span><br><span class="line">              <span class="tag">&lt;<span class="name">function-signature</span>&gt;</span>java.lang.String toUpperCase( java.lang.String )<span class="tag">&lt;/<span class="name">function-signature</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="name">function</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="第三步-配置web-xml"><a href="#第三步-配置web-xml" class="headerlink" title="第三步:配置web.xml."></a>第三步:配置web.xml.</h4><p>如果tld文件是在Web-INF目录或类路径下，此步可跳过。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">taglib</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">taglib-uri</span>&gt;</span>http://www.yrom.net/jsp/string/fn<span class="tag">&lt;/<span class="name">taglib-uri</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">taglib-location</span>&gt;</span>/WEB-INF/myfn.tld<span class="tag">&lt;/<span class="name">taglib-location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">taglib</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">jsp-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="第四步：在JSP中使用。"><a href="#第四步：在JSP中使用。" class="headerlink" title="第四步：在JSP中使用。"></a>第四步：在JSP中使用。</h4><p>注意应先用taglib指令引入该uri。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">taglib</span> <span class="attr">uri</span>=<span class="string">"/该tld所在位置"</span> <span class="attr">prefix</span>=<span class="string">"myfn"</span> %&gt;</span>  </span><br><span class="line">...  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">%</span>  </span><br><span class="line">   <span class="attr">pageContext.setAttribute</span>("<span class="attr">a</span>","<span class="attr">aaa</span>");  </span><br><span class="line">%&gt;</span>  </span><br><span class="line">   $&#123;myfn:toUppercase(a)&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span>  </span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="2-5JSTL标签库"><a href="#2-5JSTL标签库" class="headerlink" title="2.5JSTL标签库"></a>2.5JSTL标签库</h3><p>JSTL标签库将在下篇文章<a href="">JavaWeb学习笔记之JSTL标签库</a>中详细介绍。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java学习笔记之反射机制]]></title>
      <url>http://codingxiaxw.cn/2016/10/02/11-java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<h2 id="理论介绍"><a href="#理论介绍" class="headerlink" title="理论介绍"></a>理论介绍</h2><p>为了便于理解，在给出代码例子之前，首先用文字给大家说说关于”Java反射机制”的理论介绍。  </p>
<p>Java反射是Java语言的一个很重要的特征，它使得Java具有了“动态性”。  </p>
<a id="more"></a>
<p>在Java运行时环境中，对于一个类，能否知道这个类有哪些属性和方法？对于任意一个对象，能否调用它的任意一个方法？答案是肯定的。这种动态获取类的信息以及动态调用对象的方法的功能来自于Java语言的反射(Reflection)机制。  </p>
<p>Java反射机制主要提供了以下功能:  </p>
<ul>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时调用任意一个对象的方法。  </li>
</ul>
<p>Reflection是Java被视为动态(或准动态)语言的一个关键性质。这个机制允许程序在运行时透过Reflection APIs取得任何一个已知名称的class的内部信息，包括modifiers(诸如public,static等等)、superclass(例如Object)、实现之interfaces(例如Serializable)，也包括fields和methods的所有信息，并可于运行时改变fields内容或调用methods。  </p>
<p>一般而言，开发者社群说到动态语言，大致认同的一个定义是:“程序运行时，允许改变程序结构或变凉类型，这种语言成为动态语言”。从这个观点看，Java就不是动态语言。  </p>
<p>尽管在这样的定义与分类下Java不是动态语言，它却有着一个非常突出的动态相关机制:Reflection。这个字的意思是“反射、映像、倒影”，用在Java身上指的是我们可以于运行时加载、探知、使用编译器件完全未知的classes。换句话说，Java程序可以加在一个运行时才得知名称的class，获悉其完整构造(但不包括methods定义)，并生成其对象实体、或对其fields设值、或唤起其methods。这种“看透class”的能力(the ability of the program to examine itselt)被称为introspection(内省、内观、反省)。Reflection和introspection是常被并提的两个术语。  </p>
<p>在JDK中，主要由以下类来实现Java反射机制，这些类都位于java.lang.reflet包中:  </p>
<ul>
<li>Class类：代表一个类。</li>
<li>field类：代表类的成员变量(成员变量也被称为类的属性)</li>
<li>Method类：代表类的方法。</li>
<li>Constructor类：代表类的构造方法。</li>
<li>Array类：提供了动态创建数组，以及访问数组的元素的静态方法。  </li>
</ul>
<h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><p>Java中每个类被加载之后，系统就会为该类生成一个对应的Class对象，通过该Class对象就可以访问到JVM中的这个类。在Java程序中获得Class对象通常有如下三种方式。  </p>
<ul>
<li><p>1.使用Class类的forName(String clazzName)静态方法。该方法需要传入字符串参数，该字符串参数的值是某个类的全限定类名(必须包括完整包名)。  </p>
<blockquote>
<p>代码示例：Class clazz=Class.forName(“demo.Person”);”Demo”代表包名，”Person”代表类名。  </p>
</blockquote>
</li>
<li><p>2.调用某个类的class属性来获取该类对应的Class对象，例如，Person.class将会返回Person类对应的Class对象。  </p>
<blockquote>
<p>代码示例：Class clazz=Person.class;  </p>
</blockquote>
</li>
<li><p>3.调用某个对象的getClass()方法，该方法是java.lang.Object类中的一个方法，所以所有的Java对象都可以调用该方法，该方法将会返回该对象所属类对应的Class对象。  </p>
<blockquote>
<p>代码示例:Person person=new Person();<br>Class clazz=person.getClass();  </p>
</blockquote>
</li>
</ul>
<p>Class对象可以获得该类里的方法(由Method对象表示)、构造器(由Constructor对象表示)、成员变量(由Field)对象表示，这三个类都位于java.lang.reflect包下并实现了java.lang.reflect.Member接口。程序可以通过Method对象来执行对应的方法，通过Constructor对象来调用对应的构造器创建实例，能通过Field对象直接访问并修改对象的成员变量值。  </p>
<h3 id="创建实例对象"><a href="#创建实例对象" class="headerlink" title="创建实例对象"></a>创建实例对象</h3><p>通过反射来生成实例对象有如下两种方式。  </p>
<ul>
<li><p>1.使用Class对象的newInstance()方法来创建该Class对应类的实例，这种方式要求该Class对象的对应类有默认构造器，而执行newInstance()时实际上是利用默认构造器来创建该类的实例。  </p>
<blockquote>
<p>代码示例:Class clazz=Person.class;<br>Object obj=clazz.newInstance();  </p>
</blockquote>
</li>
<li><p>2.先使用Class对象获取指定的Constructor对象，再调用Constructor对象的newInstance()方法来创建该Class对象对应类的实例。通过这种方式可以选择使用指定的构造器来创建实例。  </p>
<blockquote>
<p>代码示例:Class clazz=Person.class;<br>Constructor constructor=clazz.getConstructor(String.class);<br>Object obj=constructor.newInstance();  </p>
</blockquote>
</li>
</ul>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>理论说了这么多，接下来给个很全的案例大家看，毕竟”Talk is cheap,show me your code”。相信看了这个案例你们就会掌握对Java的反射机制了，我这里参考的是CSDN上的一篇文章，就不重复造轮子了直接给链接你们去看他写的代码。<a href="http://blog.csdn.net/ljphhj/article/details/12858767" target="_blank" rel="external">一个例子让你了解Java反射机制</a>。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p> If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a> </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java随机生成图片与HTML表单中的验证码实现]]></title>
      <url>http://codingxiaxw.cn/2016/09/30/10-Java%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%9B%BE%E7%89%87%E4%B8%8EHTML%E8%A1%A8%E5%8D%95%E4%B8%AD%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%BB%8B%E7%BB%8D/</url>
      <content type="html"><![CDATA[<h2 id="Java随机生成图片"><a href="#Java随机生成图片" class="headerlink" title="Java随机生成图片"></a>Java随机生成图片</h2><p>用Java语言生成一个带有字符串文本的图片总结来说只需要如下四步:</p>
<ul>
<li>1.创建图片缓冲区</li>
<li>2.设置图片缓冲区的宽高及保存图片的类型</li>
<li>3.得到这个图片的绘制环境(拿到画笔)</li>
<li>4.将图片保存起来</li>
</ul>
<p>代码如下:<br><a id="more"></a></p>
<pre><code>//第一、二步，传入参数为缓冲区宽、高、保存图片类型
BufferedImage image=new BufferedImage(width1,height1,BufferedImage.TYPE_INT_RGB);

//第三步，得到绘制环境(需要用到Graphics类)
Graphics paint=image.getGraphics();
paint.setColor(Color.WHITE);//设置画笔颜色为白色
paint.fillRect(start,end,width2,height2);//绘制矩形并填充，将图片缓冲区的(start,end)坐标作为绘制图片的左上角坐标，绘制图片宽为width2、高为height2
paint.setColor(Color.RED);//设置画笔颜色为红色
paint.drawString(str,x,y);//设置需要绘制在图片上的文本，参数为字符串、字符串所在的x坐标和y坐标

//第四步，将图片保存起来(需要用到ImageIO类)
ImageIO.write(image,&quot;JPEG&quot;,out);//参数为图片缓冲区、图片类型、输出流  
</code></pre><p>通过以上代码便可实现用java语言生成一个简易的带有字符串文本的图片，具体实现如下，首先在IDEA中创建VerifyCode.java类:<br>    <img src="http://od2xrf8gr.bkt.clouddn.com/verify1.png" alt=""><br>    有错误，请将g.drawStrig(sb.toString(),width/4,height-5);改为g.drawString(str,i*width/4,height-5);<br>    <img src="http://od2xrf8gr.bkt.clouddn.com/verify2.png" alt=""><br>    <img src="http://od2xrf8gr.bkt.clouddn.com/verify3.png" alt="">  </p>
<p>通过代码<code>VerifyCode vc=new VerifyCode();</code>创建VerifyCode对象后就可以调用上述所有方法便可以实现随机验证码的图片了。  </p>
<h2 id="在HTML表单中实现验证码"><a href="#在HTML表单中实现验证码" class="headerlink" title="在HTML表单中实现验证码"></a>在HTML表单中实现验证码</h2><p>借用上篇<a href="">Java Web学习笔记之session入门</a>中的保存用户登录信息案例中的代码，新增:  </p>
<ul>
<li>VerifyServlet.java:生成图片，保存图片上的文本到session域中，将图片响应给客户端。</li>
<li>LoginServlet.java中新增作用:判断用户输入的验证码是否正确，若正确则跳转至下一链接，若错误则保存错误信息到request域中，然后请求转发至login.jsp登录页面。  </li>
</ul>
<p>代码如下图:  </p>
<div align="center">VerifyServlet.java</div>

<p><img src="http://od2xrf8gr.bkt.clouddn.com/verifyServlet.png" alt="">  </p>
<div align="center">LoginServlet.java</div>  

<p><img src="http://od2xrf8gr.bkt.clouddn.com/LoginServlet2.png" alt="">  </p>
<p><div align="center">login.jsp(用到了javascript语法来更换验证码)</div><br><img src="http://od2xrf8gr.bkt.clouddn.com/loginJsp.png" alt=""><br>10月8日更正:途中的js代码有错误，将”ducument”改为”document”。  </p>
<p>通过如上代码便可实现HTML中的验证码效果。</p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Web学习笔记之session入门]]></title>
      <url>http://codingxiaxw.cn/2016/09/27/9-java-web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8Bsession%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-HttpSession概述"><a href="#1-HttpSession概述" class="headerlink" title="1.HttpSession概述"></a>1.HttpSession概述</h2><ul>
<li>HttpSession是由JavaWeb提供的，用来会话跟踪的类。session是服务器端对象，保存在服务器端。</li>
<li>HttpSession是Servlet三大域对象(request、session、application)之一，所以它也有setAttribute()、getAttribute()、removeAttribute()三个方法。</li>
<li><p>HttpSession底层依赖Cookie，或是URL重写。 </p>
<a id="more"></a> 
</li>
</ul>
<h2 id="2-HttpSession的作用"><a href="#2-HttpSession的作用" class="headerlink" title="2.HttpSession的作用"></a>2.HttpSession的作用</h2><ul>
<li>会话范围:会话范围是某个用户从首次访问服务器开始，到该用户关闭浏览器结束。(会话:一个用户对服务器的多次连贯性请求！所谓连贯请求，就是该用户多次请求 中间没有关闭浏览器)  </li>
<li>服务器会为每个客户端创建一个session对象，session就好比客户在服务器端的账户，它们被服务器保存到一个Map中，这个Map被称之为session缓存。  <ul>
<li>Servlet中得到session对象的方法为:HttpSession session=request.getSession();</li>
<li>Jsp中得到session对象的方法:session是JSP内置对象之一，不用创建就可以直接使用。  </li>
</ul>
</li>
<li>session域相关方法:  <ul>
<li>void setAttribute(String name,Object value);</li>
<li>Object getAttribute(String name);</li>
<li>void removeAttribute(String name);  </li>
</ul>
</li>
</ul>
<h2 id="3-案例-演示保存用户登录信息"><a href="#3-案例-演示保存用户登录信息" class="headerlink" title="3.案例:演示保存用户登录信息"></a>3.案例:演示保存用户登录信息</h2><ul>
<li>案例相关页面和Servlet:  <ul>
<li>login.jsp:登录页面</li>
<li>succ1.jsp:只有登录成功才能访问的页面</li>
<li>LoginServlet:效验用户是否登录成功(这里随便判断的，以后学了数据库后可以根据该用户名和密码是否和数据库中的用户名和密码匹配来判断)</li>
</ul>
</li>
<li>各页面和Servlet内容:  <ul>
<li>login.jsp:提供登录表单，提交表单请求至LoginServlet</li>
<li>LoginServlet：获取请求参数，效验用户是否登录成功  <blockquote>
<p>失败:保存错误信息到request域，转发到login.jsp。(login.jsp中显示request域中的错误信息)<br>成功:保存用户信息到sussion域中，重定向到succ1.jsp页面，显示session域中的用户信息。</p>
</blockquote>
</li>
<li>succ1.jsp:从session域中获取用户信息，如果不存在，显示“您还没有登录”，存在则显示用户信息。  </li>
</ul>
</li>
</ul>
<h3 id="各页面代码如下"><a href="#各页面代码如下" class="headerlink" title="各页面代码如下:"></a>各页面代码如下:</h3><p><font align="center">login.jsp</font><br><img src="http://od2xrf8gr.bkt.clouddn.com/login.png" alt="">  </p>
<p><font align="center">LoginServlet.java</font><br><img src="http://od2xrf8gr.bkt.clouddn.com/loginservlet.png" alt="">  </p>
<p><font align="center">succ1.jsp</font><br><img src="http://od2xrf8gr.bkt.clouddn.com/succ1.png" alt="">  </p>
<h2 id="4-HttpSession的原理-需要理解"><a href="#4-HttpSession的原理-需要理解" class="headerlink" title="4.HttpSession的原理(需要理解)"></a>4.HttpSession的原理(需要理解)</h2><h3 id="初入HttpSession原理"><a href="#初入HttpSession原理" class="headerlink" title="初入HttpSession原理"></a>初入HttpSession原理</h3><blockquote>
<p>1.每当客户端与服务器建立了一个会话，服务器就会为该客户端建立一个session对象，将session对象保存在服务器端的同时服务器还会给客户端发送一个带有JSESSIONID的Cookie(放在响应头中)；2.当客户端在不关闭浏览器的情况下再次访问该服务器时，客户端就会通过这个JSESSIONID来取出保存在服务器端相应session对象。3.当客户关闭了浏览器时，意味着与服务器断开连接然后会话session也随着就结束了，此时能识别存在服务器端的HttpSession对象的JSESSIONID也就跟着丢失了。4.但是此HttpSession对象依旧保存在服务器端。5.当再次打开浏览器时，就会重新建立新连接，服务器给过来的JSESSIONID也是新的了。  </p>
<p>这就好比你第一次去银行办卡，1.银行给你办了一张带有独特帐号的银行卡(JSESSIONID)然后你回家了，你存在银行卡里的钱保存在银行里(相应的HttpSession对象)(对应上面的步骤1)；2.当你再次访问该银行取钱时，你首先要给银行你的带有独特帐号的银行卡(将JSESSIONID给服务器),然后银行会给你要取的钱(获取相应的HttpSession对象)(对应上面的步骤2)。3.当你丢失了你的银行卡，而银行的工作人员又不小心在数据库中删除了你银行卡对应的帐号(对应上面的步骤3关闭浏览器)。4.但是你的钱还保存在银行里(对应上面的步骤4)。5.这时当你再次返回该银行时，你就需要重新办一张银行卡(由于工作人员删除了你原先的帐号所以不能补办),并且新办理的银行卡会对应新的帐号(新的JSESSIONID)。  </p>
</blockquote>
<p>对于断开连接后保存在服务器端的HttpSession对象不会一直存在，它有它的生命时间，一般为30分钟，到达这个时间后服务器端就会将它删除。还有一种情况就是当客户端与服务器建立一个会话后，但是该客户却很长时间不对服务器发请求，当时间到达该session对象存活的时间后服务器也会删除该session对象。就比如你登录了淘宝的主页，然后你半天时间不去碰电脑，当你想起要去购物时，你点击一个超链接后服务器就会要求你重新登录，因为由于你长时间不给服务器发起请求，服务器就误认为这是一个没用的session，然后服务器就将它删了。  </p>
<h3 id="深入HttpSession原理"><a href="#深入HttpSession原理" class="headerlink" title="深入HttpSession原理"></a>深入HttpSession原理</h3><p>首先纠正下上面的一句话，其实当客户端与服务器建立连接时，虽然会话是建立了但是服务器不会立刻建立HttpSession对象(因为对象在服务器端存活时间较长，所以服务器没那么傻)，只有当客户端请求的Servlet中调用了request.getSession()方法要求获取HttpSession对象时服务器才会创建；但是若请求的是jsp页面，则服务器会立刻创建HttpSession对象，因为jsp对应的Servlet类中已经默认调用了request.getSession()。  </p>
<p>调用request.getSession()方法后服务器的做法  </p>
<ul>
<li>获取Cookie中的JSESSIONID，需要判断:  <ol>
<li>如果JSESSIONID不存在，则创建session，把session保存起来并把新创建的JSESSIONID保存到Cookie中。</li>
<li>如果JSESSIONID存在，通过JSESSIONID查找session对象，如果没有查找到，则创建session并保存起来，把新创建的JSESSIONID保存到Cookie中。</li>
<li>如果JSESSIONID存在，通过JSESSIONID查找到了session对象，那么就不会再创建session对象了。  </li>
</ol>
</li>
</ul>
<h2 id="5-HttpSession的其它方法"><a href="#5-HttpSession的其它方法" class="headerlink" title="5.HttpSession的其它方法"></a>5.HttpSession的其它方法</h2><ul>
<li>String getId():获取JSESSIONID。</li>
<li>int getMaxInactiveInterval():获取session可以的最大不活动时间(秒),默认为30分钟，当session在30分钟内没有使用，哪么Tomcat会在session缓存中删掉这个session。</li>
<li>void invalidate():让session失效。调用这个方法会被session失效，当session失效后，客户端再次请求，服务器会给客户端创建一个新的session，并在响应中创建一个新的JSESSIONID。</li>
<li>boolean isNew():查看session是否为新。当客户端第一次请求时，服务器为客户端创建session，并把JSESSIONID存在Cookie中发给客户端，这时调用这个方法返回的就是新session；当再次发起请求时，JSESSIONID放在Cookie中作为请求头发给服务器，这时调用此方法，返回的就是false，即此session不是新的。  </li>
</ul>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="6-联系"><a href="#6-联系" class="headerlink" title="6.联系"></a>6.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Web读书笔记之Cookie入门]]></title>
      <url>http://codingxiaxw.cn/2016/09/27/8-java-web%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8BCookie%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="1-Http协议与Cookie-了解"><a href="#1-Http协议与Cookie-了解" class="headerlink" title="1.Http协议与Cookie(了解)"></a>1.Http协议与Cookie(了解)</h2><ol>
<li>Cookie是Http协议制定的。先有服务器保存Cookie到浏览器，再下次浏览器请求服务器时把上一次请求得到的Cookie归还给服务器。</li>
<li><p>由服务器创建保存到客户端的一个键值对。服务器保存Cookie的响应头,使用response发送响应头:Set-Cookie:aaa=AAA;Set-Cookie:bbb=BBB;例如:  </p>
<pre><code>response.addHeader(&quot;Set-Cookie&quot;,&quot;aaa=AAA&quot;);
response.addHeader(&quot;Set-Cookie&quot;,&quot;bbb=BBB&quot;);
</code></pre></li>
</ol>
 <a id="more"></a>
<ol>
<li>当浏览器请求服务器时，会把该服务器保存的Cookie随请求发送给服务器。浏览器归还Cookie的请求头:Cookie:aaa=AAA;bbb=BBB。多个键值对间用分号隔开。</li>
<li>Http协议规定(为了不给浏览器太大压力)  <ul>
<li>1个Cookie最大4KB</li>
<li>1个服务器最多向1个浏览器保存20个Cookie</li>
<li>1个浏览器最多可以保存300个Cookie  </li>
</ul>
</li>
</ol>
<h2 id="2-Cookie的用途"><a href="#2-Cookie的用途" class="headerlink" title="2.Cookie的用途"></a>2.Cookie的用途</h2><ul>
<li>服务器使用Cookie来跟踪客户端状态。</li>
<li>保存购物车(购物车中的商品不能使用request域来保存，因为它是一个用户向服务器发送的多个请求信息)</li>
<li>显示上次登录用户名(并记住密码)  </li>
</ul>
<h2 id="3-Java-Web中使用Cookie"><a href="#3-Java-Web中使用Cookie" class="headerlink" title="3.Java Web中使用Cookie"></a>3.Java Web中使用Cookie</h2><ul>
<li>原始的方式:  <ul>
<li>使用response发送Set-Cookie响应头。</li>
<li>使用request获取请求头。</li>
</ul>
</li>
<li>便捷方式:<ul>
<li>使用response.addCookie()方法向浏览器保存Cookie。</li>
<li>使用request.getCookies()方法获取浏览器归还的Cookie，返回的对象为Cookie数组。若没有Cookie则返回NULL。  </li>
</ul>
</li>
</ul>
<h2 id="4-Cookie详解"><a href="#4-Cookie详解" class="headerlink" title="4.Cookie详解"></a>4.Cookie详解</h2><ol>
<li>Cookie不只有name和value两个属性。</li>
<li>Cookie的maxAge:指Cookie的最大生命，即Cookie可保存在客户端中的最大时长，以秒为单位。<ul>
<li>maxAge&gt;0:浏览器会把Cookie保存到客户端硬盘上，有效时长为maxAge的值决定，例如:cookie.setMaxAge(60)表示这个Cookie会被浏览器保存到硬盘上60秒。</li>
<li>maxAge&lt;0:Cookie只会在浏览器内存中存在，当用户关闭浏览器时浏览器进程结束，同时Cookie也就死亡了。</li>
<li>maxAge=0:浏览器会马上删除这个Cookie。  </li>
</ul>
</li>
</ol>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="5-联系"><a href="#5-联系" class="headerlink" title="5.联系"></a>5.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Web中的Servlet请求转发和请求包含]]></title>
      <url>http://codingxiaxw.cn/2016/09/26/7-java-web%E4%B8%AD%E7%9A%84Servlet%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%AB/</url>
      <content type="html"><![CDATA[<p>为什么需要这样的操作呢？因为很多时候一个请求需要多个Servlet协作才能完成，所以需要在一个Servlet中跳转到另一个Servlet中处理。  </p>
<h2 id="1-格式"><a href="#1-格式" class="headerlink" title="1.格式"></a>1.格式</h2><p>首先调用request的getRequestDispatcher(“参数”)方法，获取到一个RequestDispatcher对象:  </p>
<pre><code>ResquestDispatcher rd=request.getRequestDispatcher(&quot;/MyServlet&quot;);  
</code></pre><p>参数为被包含或被转发的目标Servlet路径。  </p>
<a id="more"></a>
<p>若是请求转发，接下来输入  </p>
<pre><code>rd.forward(request,response);  
</code></pre><p>若是请求包含，接下来输入  </p>
<pre><code>rd.include(request,response);  
</code></pre><p>即可完成我们的请求转发和请求包含。二者的区别为:  </p>
<ul>
<li>请求转发:由当前Servlet设置响应头(不能设置响应体)，下一个Servlet既可设置响应头也可设置响应体。  </li>
<li>请求包含:当前Servlet和下一个Servlet共同完成相应头和响应体。  </li>
</ul>
<p>需要注意的是无论是请求转发还是请求包含，都在一个请求范围内，所以多个Servlet中使用的是同一个request和response。  </p>
<h2 id="2-请求转发"><a href="#2-请求转发" class="headerlink" title="2.请求转发"></a>2.请求转发</h2><p>OneServlet代码如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91One.png" alt="">  </p>
<p>TwoServlet代码如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%ABtwo.png" alt="">  </p>
<p>网页响应结果为:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E7%BB%93%E6%9E%9C.png" alt="">  </p>
<p>由响应结果我们可以看到OneServlet中设置的响应体没有在网页中显示出来，只有TwoServlet中设置的响应体显示出来了。  </p>
<h2 id="3-请求包含"><a href="#3-请求包含" class="headerlink" title="3.请求包含"></a>3.请求包含</h2><p>请求包含和请求转发中代码相比，只是在OneServlet中将forward()方法改为include()方法而已。  </p>
<p>OneServlet中代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%ABOne.png" alt="">  </p>
<p>TwoServlet中代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%ABtwo.png" alt="">  </p>
<p>网页响应结果为:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E8%AF%B7%E6%B1%82%E5%8C%85%E5%90%AB%E5%93%8D%E5%BA%94%E7%BB%93%E6%9E%9C.png" alt="">  </p>
<p>从响应结果中我们可以看到在OneServlet和TwoServlet中设置的响应体都显示了出来。  </p>
<h2 id="4-请求转发和重定向的区别"><a href="#4-请求转发和重定向的区别" class="headerlink" title="4.请求转发和重定向的区别"></a>4.请求转发和重定向的区别</h2><ol>
<li>请求转发是一个请求一次响应，而重定向是两次请求两次响应。</li>
<li>请求转发地址栏不变化，而重定向会显示后一个请求的地址。 </li>
<li>请求转发智能转发到本项目其他Servlet，而重定向不只能重定向到本项目的其它Servlet，还能定向到其它项目。</li>
<li>请求转发是服务器端行为，只需给出转发的Servlet路径，而重定向需要给出requestURI,即包含项目名。</li>
<li>请求转发和重定向二者效率前者高，因为前者只发出一个请求。  <blockquote>
<p>很多时候我们需要地址栏发生变化，那时候必须使用重定向。<br>需要在下一个Servlet中获取到request域中的数据，必须用请求转发。  </p>
</blockquote>
</li>
</ol>
<p>既然请求转发和请求包含都是一个请求需要多个servlet协作完成，那么这些Servlet是如何传递数据的呢？见下文新概念。  </p>
<h2 id="5-request域"><a href="#5-request域" class="headerlink" title="5.request域"></a>5.request域</h2><p>何为域？上一篇文章中提到对ServletContext域对象(详见<a href="http://codingxiaxw.cn/2016/09/24/%E5%AE%9E%E7%8E%B0Servlet%E7%9A%84%E6%96%B9%E5%BC%8F/">Servlet的实现方式</a>)的介绍时已经说过域的功能，即具有能存数据和取数据的功能。  </p>
<p>同一请求范围内使用request.setAttribute()来传值、使用request.getAttribute()方法来取值.即前一个Servlet使用request.setAttribute()来传值、后一个Servlet使用request.getAttribute()方法来取值。而当想清除request中的值时，调用request.removeAttribute()方法即可清除。如下图:</p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/request%E5%9F%9F%E6%96%B9%E6%B3%95.png" alt="">  </p>
<p>上图中三大域对象的生命周期长度为:  </p>
<pre><code>request&lt;session&lt;application  
</code></pre><p><strong>扩展:</strong>&nbsp;&nbsp;注意上图中三个方法和请求参数方法的区别，请求参数是客户端传给服务器的，我们不能修改；而此处的setAttribute()是我们自己设置的属性与属性值。另外Servlet类中有上述三大域，而JSP中有四大域，多了一个pageContext域。  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Web中实现Servlet的方式]]></title>
      <url>http://codingxiaxw.cn/2016/09/24/6-java-web%E5%AE%9E%E7%8E%B0Servlet%E7%9A%84%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="1-Servlet是什么"><a href="#1-Servlet是什么" class="headerlink" title="1.Servlet是什么?"></a>1.Servlet是什么?</h2><p>Servlet是Java Web三大组件之一，它属于动态资源。Servlet的作用是处理请求，服务器会把接收到的请求交给Servlet来处理，在Servlet中通常需要:  </p>
<ul>
<li>接受数据请求</li>
<li>处理请求</li>
<li><p>完成响应  </p>
<a id="more"></a>
</li>
</ul>
<p>例如客户端发出登录请求，或者输入注册请求，这些请求都应该由Servlet来完成处理。当然Servlet类需要我们自己来编写，每个Servlet类都必须实现javax.servlet.Servlet接口。  </p>
<h2 id="2-实现Servlet的方式-需要我们自己来写"><a href="#2-实现Servlet的方式-需要我们自己来写" class="headerlink" title="2.实现Servlet的方式(需要我们自己来写)"></a>2.实现Servlet的方式(需要我们自己来写)</h2><ol>
<li>实现javax.servlet.Servlet接口;</li>
<li>继承javax.servlet.GenericServlet类;</li>
<li>继承javax.servlet.http.HttpServlet类;  </li>
</ol>
<p>一般来说我们都选择实现HttpServlet类来完成我们的Servlet，但学习Servlet还要从javax.servlet.Servlet接口来学起。  </p>
<h3 id="2-1实现javax-servlet-Servlet接口"><a href="#2-1实现javax-servlet-Servlet接口" class="headerlink" title="2.1实现javax.servlet.Servlet接口"></a>2.1实现javax.servlet.Servlet接口</h3><p>实现该接口的代码如下，需要实现该接口中的5个方法(各个方法的作用见注释)。  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%AE%9E%E7%8E%B0Servlet%E6%8E%A5%E5%8F%A3.png" alt="">  </p>
<p>其中只有三个生命周期的方法是由服务器(例如我用的Tomcat)在认为需要调用的时候自动调用的(即我们自己是无法调用的)，另外的两个方法由我们自己需要的时候调用。   </p>
<h3 id="2-2继承javax-servlet-GenericServlet类"><a href="#2-2继承javax-servlet-GenericServlet类" class="headerlink" title="2.2继承javax.servlet.GenericServlet类"></a>2.2继承javax.servlet.GenericServlet类</h3><p>有人会说，那我每次实现Servlet接口都要重写这5个方法岂不是很麻烦？那肯定麻烦！所以GenericServlet类派上用场了。  </p>
<p>GenericServlet类实现了Servlet接口，所以在GenericServlet类中实现了Servlet接口中的5个抽象方法，另外在GenerecServlet类中还定义了自己的方法，将其作为我们要定义的xxxServlet类的父类，这样我们在自己定义的xxxServlet类中便可以不用<strong>全部</strong>实现Servlet接口中的方法。  </p>
<p>GenericServlet类中的方法如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/GenericServlet%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%85%A8%E9%83%A8%E6%96%B9%E6%B3%95.png" alt="">  </p>
<p>由图可知，GenericServlet类除了实现Servlet接口中的四个方法外，还定义了getInitParameter()返回Servlet的参数值、getInitParameterNames()返回Servlet的参数名、getServletName()返回Servlet名、getServletContext()返回Servlet上下文、不带参数的init()、log()等方法。这些自己定义的方法中，前面四个是ServletConfig接口中的方法，不带参数的init()方法跟Servlet接口中的init(ServletConfig config)方法要区别，在init()方法中，我们可以添加当xxxServlet被初始化的操作，此方法在初始化方法init(ServletConfig config)中被调用(若是文字解析看不懂见下图GenericServlet源代码中注释)。  </p>
<p>另外不知道你们发现了没有，图中只有service()方法属于抽象方法，所以当我们定义的xxxServlet类去继承GenericServlet类时我们只需重写这一个方法即可，其他方法可重写可不重写。  </p>
<p>另外附上GenericServlet类的源代码:<br><img src="http://od2xrf8gr.bkt.clouddn.com/GenericServlet%E7%B1%BB%E6%BA%90%E4%BB%A3%E7%A0%81.jpg" alt="">  </p>
<p>代码中的xxxServlet类即是我们自己定义的servlet类。  </p>
<p>扩展:<strong>对ServletContext的解释</strong>:  </p>
<p>服务器会为每个应用创建一个ServletContext对象，一个应用只有一个ServletContext对象！我们可以在N多个Servlet中来获取这个唯一的对象，使用它可以给多个Servlet传递数据。此对象在Tomcat(服务器)启动时就创建，在服务器关闭时就销毁。  </p>
<p>ServletContext是Java Web四大域对象(PageContext、ServletRequest、HttpSession、ServletContext)之一，域对象所具有的特点是:  </p>
<ul>
<li>能够存数据</li>
<li>能够取数据  </li>
</ul>
<p>所有的域对象都有存取数据的功能，因为域对象内部有一个Map，用来存储数据，下面是ServletContext对象用来操作数据的方法:  </p>
<p><img src="http://od2xrf8gr.bkt.clouddn.com/ServletContext%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E7%9A%84%E6%96%B9%E6%B3%95.png" alt="">  </p>
<p>扩展:<strong>Servlet类三大域:</strong>  </p>
<ul>
<li>request:在Servlet中直接用，因为实现的doPost()方法中有request这个参数。</li>
<li>session:在Servlet中通过<code>HttpSession session=request.getSession();</code>得到。</li>
<li>application:在Servlet中通过<code>ServletContext application=this.getServletContext();</code>得到。</li>
</ul>
<p>扩展:<strong>JSP中四大域</strong></p>
<ul>
<li>page域:即9大内置对象中的pageContext，为PageContext的实例。注意:“page域”不同于9大内置对象中“page”。</li>
<li>request域:即9大内置对象中的request，为HttpServletRequest的实例。</li>
<li>session域:即9大内置对象中的session,为HttpSession的实例。</li>
<li>application:即9大内置对象中的ServletContext的实例。</li>
</ul>
<h3 id="2-3-继承HttpServlet类"><a href="#2-3-继承HttpServlet类" class="headerlink" title="2.3.继承HttpServlet类"></a>2.3.继承HttpServlet类</h3><p>HttpServlet类是我们用到次数最多的，也是最简单的。由类名可知，该类总是跟http协议相关的。  </p>
<p>HttpServlet类中的方法如下图:<br><img src="http://od2xrf8gr.bkt.clouddn.com/httpservlet%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95.png" alt=""><br>方法中值得我们注意的有doGet()、doPost()、还有两个service()方法。其中doGet()和doPost()方法是需要我们重写的，我来解释下两个service()方法的区别。  </p>
<p>估计你们从方法中的参数就知道他们的区别了吧，其中一个service()方法是Serlvet接口中的生命周期方法，另外一个是跟http协议有关的方法。二者方法的解释见下两站图的说明(图1中指出HttpServlet类是继承自GenderServlet类):<br><img src="http://od2xrf8gr.bkt.clouddn.com/httpServlet%E4%B8%AD%E5%AF%B9service%E6%96%B9%E6%B3%95%E7%9A%84%E8%A7%A3%E9%87%8A.png" alt=""><br>uml(时序图)如下:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt=""><br>图中405的含义是说服务器不支持客户端(即浏览器)用此种方法访问。因为HttpServlet类的源代码中的doGet()和doPost()方法体里面就是这样写的，你在定义的xxxservlet中如果不重新重写这两个方法就会出现405的响应状态码。接下来我们看看如何继承HttpServlet类:<br><img src="http://od2xrf8gr.bkt.clouddn.com/%E5%AE%9E%E7%8E%B0httpservlet%E7%B1%BB.png" alt=""><br>FServlet即为我们自己定义的servlet类，在doGet()方法和doPost()方法中即可写具体要进行的操作。  </p>
<p>如上三种方式便可实现我们自己定义的Servlet类，但实际开发中我们只需要使用第三种方式即继承HttpServlet类完成我们的自定义xxxServlet就好(另外等学了SSM框架中的Spring MVC框架后，就用不着我们再这样实现Servlet了，哈哈！当然这是后话)。  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<h2 id="3-联系"><a href="#3-联系" class="headerlink" title="3.联系"></a>3.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从Android开发转战Java Web]]></title>
      <url>http://codingxiaxw.cn/2016/09/12/5-%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B/</url>
      <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>&emsp;&emsp;一个伟大事迹的诞生总要牺牲点什么，William Henry Gates大学时选择休学而去搞开发，最后成就了自己的 SoftWare；Steven Jobs因父母财务紧张不得不辍学，最后成就了自己的apple；而我，一个平凡的在校大三狗，在Andriod开发的世界里摸黑打滚了大半年之后，在仔细的思考过后，而今打算放弃Android去选择Web开发(你以为我也要辍学去搞开发吗)。<img src="http://od2xrf8gr.bkt.clouddn.com/%E5%9D%8F%E7%AC%91.jpg" alt="">希望在接下来的日子里，能学有所得。 </p>
<a id="more"></a>
<h2 id="2-细数这一年来自己的经历"><a href="#2-细数这一年来自己的经历" class="headerlink" title="2.细数这一年来自己的经历:"></a>2.细数这一年来自己的经历:</h2><h3 id="2-1开发过的app"><a href="#2-1开发过的app" class="headerlink" title="2.1开发过的app"></a>2.1开发过的app</h3><ul>
<li>计算器， 源码<a href="https://github.com/codingXiaxw/Caculator" target="_blank" rel="external">点击这里</a>前往我的github</li>
<li>记事本， 源码<a href="https://github.com/codingXiaxw/NoteBook" target="_blank" rel="external">点击这里</a>前往我的github</li>
<li>智能聊天机器人， 源码<a href="https://github.com/codingXiaxw/TuLingMachine" target="_blank" rel="external">点击这里</a>前往我的github</li>
<li>天气预报， 源码<a href="https://github.com/codingXiaxw/coolweather" target="_blank" rel="external">点击这里</a>前往我的github</li>
<li>2048小游戏， 源码<a href="https://github.com/codingXiaxw/Android2048Game" target="_blank" rel="external">点击这里</a>前往我的github</li>
<li>知乎日报， 源码<a href="https://github.com/codingXiaxw/ZhiHuDailyPaper" target="_blank" rel="external">点击这里</a>前往我的github</li>
</ul>
<h3 id="2-2学习过的网站"><a href="#2-2学习过的网站" class="headerlink" title="2.2学习过的网站"></a>2.2学习过的网站</h3><ul>
<li><a href="http://www.imooc.com/" target="_blank" rel="external">慕课网</a>  </li>
<li><a href="http://www.jikexueyuan.com/" target="_blank" rel="external">极客学院</a>  </li>
<li><a href="http://study.163.com/" target="_blank" rel="external">网易云课堂</a></li>
</ul>
<h3 id="2-3看过的书籍"><a href="#2-3看过的书籍" class="headerlink" title="2.3看过的书籍"></a>2.3看过的书籍</h3><p>有关java:  </p>
<ul>
<li>《java从入门到精通》  </li>
<li>《java疯狂讲义》  </li>
</ul>
<p>有关Android：</p>
<ul>
<li>《第一行代码》</li>
<li>《Android群英传》</li>
<li>《Android开发艺术探索》  </li>
</ul>
<p>这一年，开发进行的真的格外辛苦，从最开始立下的向Web开发的flag转战Android开发。这一年里，经常遇到调了几天几夜都还调不出来的bug，很是难受；看着书上那一串串乏味的代码和解说，真的很让人犯困；特别是当你的编程能力过了初级工程师的编程能力想要进阶的时候，看到那些源码真的让人很难受；很多时候想过放弃，但还是坚持了下来；因为当你完成一个功能而设计出一个app的时候，那种自豪感真的很让人兴奋。 </p>
<h2 id="3-做的好好的为什么要转？"><a href="#3-做的好好的为什么要转？" class="headerlink" title="3.做的好好的为什么要转？"></a>3.做的好好的为什么要转？</h2><p>纯属兴趣。  </p>
<p>做就要做到最好，我会依旧保持自己对编程的热爱之情，向大牛发展，争取在2018年毕业之际顺利进入自己梦想的大公司(当然BAT是首选啊哈哈）。  </p>
<p>人若没有理想，跟咸鱼有什么区别呢？  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p> If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android中Activity的生命周期]]></title>
      <url>http://codingxiaxw.cn/2016/09/07/4-Android%E4%B8%ADActivity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      <content type="html"><![CDATA[<p>刚刚在stormzhang的一篇叫    <strong><a href="http://mp.weixin.qq.com/s?__biz=MzA4NTQwNDcyMA==&amp;mid=2650661665&amp;idx=1&amp;sn=8127335085ce285473eb5ba53663fc29&amp;scene=21#wechat_redirect" target="_blank" rel="external">android学到哪种程度可以去找工作</a></strong>中看到张哥提了这么一个观点<strong>如果我问你Android中Activity生命周期你还支支吾吾的那我就对你没什么兴趣了</strong>。吓得我赶紧在脑海中回顾了下有关activity生命周期的知识，便打算趁热打铁写下自己对activity生命周期的理解。    </p>
<a id="more"></a>
<h2 id="1-Activity形态"><a href="#1-Activity形态" class="headerlink" title="1.Activity形态"></a>1.Activity形态</h2><p>Activity一个最大的特点就是拥有多种形态，它可以在多种形态间进行切换，以此来控制自己的生命周期。    </p>
<ul>
<li><strong>Active/Running</strong><br>这时候，Activity处于Activity栈的最顶层，可见，并与用户进行交互。  </li>
<li><strong>Paused</strong><br>当Activity失去焦点，被一个新的非全屏的Activity或者一个透明的Activity放置在栈顶时，Activity就转化为Paused形态。但它只是失去了与用户交互的能力，所有状态信息，成员变量都还保持着，只有在系统内存极低的情况下，才会被系统回收掉。</li>
<li><strong>Stopped</strong><br>如果一个Activity被另一个Activity完全覆盖，那么Activity就会进入Stopped形态。此时，它不再可见，但却依然保持了所有状态信息和成员变量。</li>
<li><strong>Killed</strong><br>当Activity被系统回收掉或者Activity从来没有创建过，Activity就处于Killed形态。<br>由此可见，用户的不同动作，会让activity在这四种形态间切换。而开发者，虽然可以控制Activity如何“生”，却无法控制Activity何时“死”。  </li>
</ul>
<h2 id="2-Activity生命周期"><a href="#2-Activity生命周期" class="headerlink" title="2.Activity生命周期"></a>2.Activity生命周期</h2><p>Google给了我们一张图来揭示Activity生命周期，如图。<br><img src="http://od2xrf8gr.bkt.clouddn.com/android%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""><br>程序启动运行并结束上述生命周期的方法执行顺序是这样的：<br>onCreate()–&gt;onStart()–&gt;onResume()–&gt;onPause()–&gt;onStop()–&gt;onDestroy()，这张经典图众所周知，开发者当然不必实现所有的生命周期方法，但知道每一个生命周期状态的含义，可以让我们更好地掌控Activity，让它能更好地完成你所期望的效果。 </p>
<ul>
<li>onCreate():创建基本的UI元素。 </li>
<li>onPause与onStop:清除Activity的资源，避免浪费。</li>
<li>onResume():需要重新初始化在onPause()中释放的资源。</li>
<li>onStart():每当Activity由不可见到可见时，都会调用该方法。</li>
<li>onRestart():需要初始化在onStop()中释放的资源。</li>
<li>onDestroy():当活动完成或者被系统销毁的时候会调用该方法。  </li>
</ul>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><ol>
<li>在系统调用onCreate()方法之后，就会马上调用onStart()方法，然后继续调用onResume()方法以进入Resumed状态(也就是前面说的Active/Running形态),最后就会停在Resumed状态，完成启动。  </li>
<li>当栈顶的Activity部分不可见后，就会导致Activity进入Pause形态，此时就会调用onPause()方法，当结束阻塞后，就会调用onResume()方法来恢复到Resume形态。  </li>
<li>当栈顶的Activity由部分不可见(调用onPause())到完全不可见(调用OnStop())或者从可见(调用onResume())到完全不可见时，也就是停止过程，此时系统会调用onPause()方法和onStop()方法。  </li>
</ol>
<p>另外，由图可知，从可见到不可见中间一定会经过部分不可见也就是一定会调用onPause()方法，而不能直接从可见跳到完全不可见，可见系统在Activity不可见的时候一定会调用onPause()方法;而当Activity由不可见到可见时，系统会通过顺序依次调用onStoped()–&gt;onRestart()–&gt;onStart()。  </p>
<p>以上便是我对Android 中Activity生命周期的理解。  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="4-联系"><a href="#4-联系" class="headerlink" title="4.联系"></a>4.联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">github@codingXiaxw</a> </li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java中String、StringBuilder和StringBuffer的区别]]></title>
      <url>http://codingxiaxw.cn/2016/09/06/3-java%E4%B8%ADstring%E3%80%81StringBuffer%E5%92%8CStringBuilder%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>  在网上查找知识点时很容易产生当时看了就会，下次又遇到这个知识点时却不得不再次上网查看这个知识点的毛病。于是打算以后将自己领悟不清的知识点写下来（相信这也是大多数人喜欢写博客的原因吧），一方面为了给后来者借鉴，另一方面也是为了自己加深印象和自己对知识的总结。  </p>
<p>  今天就来谈谈自己对java中String、StringBuilder和StringBuffer知识点的理解。  </p>
<ul>
<li><strong>String字符串常量</strong>  </li>
<li><strong>StringBuffer字符串变量(线程安全）</strong>  </li>
<li><p><strong>StringBuilder字符串变量（非线程安全）</strong>  </p>
<a id="more"></a>
</li>
</ul>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>所谓常量，即该对象的值已经被赋予了，不能再更改。若非要更改，则只能再重新创建另一个对象，在这个新创建的对象上再进行赋值。因此，每次在对String类型的对象进行改变的时候其实都等同于生成了一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后，JVM的GC就会开始工作，那速度是一定会相当慢的。  </p>
<h2 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h2><p>所谓变量，即是可以随时变化的量。如果对StringBuffer对象进行改变，每次结果都会对StringBuffer对象进行操作，而不是生成新的对象。所以一般字符串要经常变化的话我推荐使用StringBuffer。  </p>
<h2 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h2><p>StringBuilder和StringBuffer类功能基本相似，方法也差不多，主要区别在于StringBuffer类的方法是多线程安全的，而StringBuilder不是线程安全的，相比而言StringBuilder类会略微快一点。  </p>
<p><strong>题外话:</strong>现在很多互联网公司面试java的面试官都喜欢问这样一个问题,</p>
<blockquote>
<p>请你谈谈StringBuffer和StringBuilder的区别。  </p>
</blockquote>
<p>大多数人肯定会直接说前者是线程安全的而后者是非线程安全的。其实这个时候才是面试官真正想问的，他会顺着你的回答又问你，那请你谈谈什么是线程…balabalabala。哈哈，要想顺利通过面试，所以对知识的了解还是全面点吧～！  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。</p>
<hr>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p>  If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Mac用户如何将自己的代码上传至github托管]]></title>
      <url>http://codingxiaxw.cn/2016/04/09/2-mac%E7%94%A8%E6%88%B7%E5%A6%82%E4%BD%95%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E8%87%B3github%E6%89%98%E7%AE%A1/</url>
      <content type="html"><![CDATA[<p>  楼主刚开始试着想将自己的代码上传至github上的时候真的是个小白，google上面到处搜到处找资源。后来云里雾里的成功上传后，发现网络上介绍的大致有两种方法，一种方法是通过git命令行，另一种方法是通过下载github客户端。两种方法都很简单，也许你觉得我接下来介绍的很繁琐，但这是详细的表现，下面将详细介绍<strong>通过git命令行来上传自己的代码</strong>。</p>
<a id="more"></a>
<h2 id="通过git命令行。"><a href="#通过git命令行。" class="headerlink" title="通过git命令行。"></a>通过git命令行。</h2><p>其实git命令不用学太多，会基本的5、6个命令就好，经常用的有  </p>
<ol>
<li><strong>git init;</strong>(作用:初始化你的文件夹)</li>
<li><strong>git add;</strong>(作用：将你的仓库添加至远程)</li>
<li><strong>git commit -m “你想输入的信息”;</strong>(作用:将你的仓库提交至远程)</li>
<li><strong>git push origin master;</strong>(作用:将你的仓库推至github)<br>其实将你的代码上传至github上，按照这四个步骤便可以完成了，是不是很简单呢？  </li>
</ol>
<p><strong>请见详细步骤:</strong></p>
<p>首先，你想使用git总得在网页上下载个git吧？打开终端，输入以下命令并回车:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ruby -e &quot;$(curl -fsSL   https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;   </span><br><span class="line">brew install git</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">如何看你是否安装好git了呢？打开你的终端，并输入如下命令:</span><br><span class="line"> `git --version`</span><br><span class="line">若出现类似下面的代码则代表你的git客户端安装成功:</span><br></pre></td></tr></table></figure></p>
<p>git version 2.1.3.36.g8e36a6d<br>```<br>接下来分别通过下面两个步骤即可完成将你的代码上传至github上。  </p>
<p>  1.克隆你github上面的项目到本地仓库，在命令行输入以下代码：git clone url 然后回车。 这时你就可以看到你的电脑上多了一个以你仓库命名的文件夹啦。（其中url指你github上面仓库的地址，点开你的仓库就可以看到你仓库的地址啦。）<br>  如我的仓库名称是: <img src="http://od2xrf8gr.bkt.clouddn.com/%E4%BB%93%E5%BA%93%E5%90%8D%E7%A7%B0.png" alt=""><br>  我的project仓库的地址是 <img src="http://od2xrf8gr.bkt.clouddn.com/%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80.png" alt=""><br>  点击这个图标可以复制你仓库的url<br>  <img src="http://od2xrf8gr.bkt.clouddn.com/%E5%9B%BE%E6%A0%87.png" alt="">   </p>
<p>  2.首先要将你想上传的代码文件夹拖至这个新出现的仓库文件夹，然后在命令行输入:<br>  <code>cd 你的仓库文件夹名称</code></p>
<p>  如我的就在命令行中输入:  </p>
<p> <code>cd projects</code></p>
<p>  这时你命令行中的目录就会出现在你的仓库目录下。  </p>
<p>  接下来输入:  </p>
<p>   <code>git add 你想上传的代码文件夹名称</code></p>
<p>  或者是输入:<br>  <code>git add .</code><br>(add后面的‘.’代表你仓库中的所有内容)   </p>
<p>  然后输入:  </p>
<p>   <code>git commit -m &quot;你想交代的内容&quot;</code></p>
<p>  最后输入:<br>  <code>git push origin master</code></p>
<p>  一会儿后你就会在你github的仓库中看到你上传的代码文件夹啦。是不是都很简单呢！  </p>
<h2 id="2018-3-19更"><a href="#2018-3-19更" class="headerlink" title="2018.3.19更"></a>2018.3.19更</h2><p><strong>欢迎加入我的Java交流1群:659957958。群里目前已有1800人，每天都非常活跃，但为了筛选掉那些不怀好意的朋友进来搞破坏，所以目前入群方式已改成了付费方式，你只需要支付9块钱，即可获取到群文件中的所有干货以及群里面各位前辈们的疑惑解答；为了鼓励良好风气的发展，让每个新人提出的问题都得到解决，所以我将得到的入群收费收入都以红包的形式发放到那些主动给新手们解决疑惑的朋友手中。在这里，我们除了谈技术，还谈生活、谈理想；在这里，我们为你的学习方向指明方向，为你以后的求职道路提供指路明灯；在这里，我们把所有好用的干货都与你分享。还在等什么，快加入我们吧！</strong></p>
<p><strong>2018.4.21更:</strong>如果群1已满或者无法加入，请加Java学习交流2群：<strong>305335626</strong> 。群2作为群1的附属群，除了日常的技术交流、资料分享、学习方向指明外，还会在每年互联网的秋春招时节在群内发布大量的互联网内推方式，话不多说，快上车吧！</p>
<hr>
<h2 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h2><p> If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by clicking  these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开启我的博客之旅]]></title>
      <url>http://codingxiaxw.cn/2016/03/31/1-%E5%86%99%E5%8D%9A%E5%AE%A2%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E7%94%9F%E6%B4%BB%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>hello guys,I’m codingXiaxw,who decide to write my own blog while I’m coding.As far as I’m concerned, writing blog is also a part of life.Everytime I felt tired,I would stop coding to play macdown,and then writed my feelings and reviews in it.In this way can I deepen the knowledges in my brain and can also make me relaxing.  </p>
<p>Welcome to <a href="https://codingxiaxw.cn">codingXiaxw’s blog</a> website!Thank for you coming,and thank for your support.They are the energy to encourage me to move forward.  </p>
<p>Today I will begin my blog journey，and I will update it frequently.   </p>
<a id="more"></a>
<h3 id="为什么要写博客"><a href="#为什么要写博客" class="headerlink" title="为什么要写博客:"></a>为什么要写博客:</h3><p>在网上查找资料时，各种博客内容参差不齐，等自己了解透了便将自己的见解写出来，供自己以后的学习，也供他人日后的参考。</p>
<h3 id="现阶段"><a href="#现阶段" class="headerlink" title="现阶段:"></a>现阶段:</h3><p>研习 <strong>Android开发</strong>，正朝着进阶的方法加以奋斗。</p>
<p>2016.7.9号更:已从Android开发转战JavaWeb开发。</p>
<h3 id="个性签名"><a href="#个性签名" class="headerlink" title="个性签名:"></a>个性签名:</h3><p>Life is shot, just coding.</p>
<h3 id="坚信"><a href="#坚信" class="headerlink" title="坚信:"></a>坚信:</h3><ul>
<li>付出总会有回报</li>
</ul>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标:"></a>目标:</h3><ul>
<li>写好代码</li>
<li>学好算法</li>
<li>顺利进入BAT</li>
</ul>
<h3 id="联系"><a href="#联系" class="headerlink" title="联系"></a>联系</h3><p> If you have some questions after you see this article,you can tell your doubts in the comments area or you can find some info by  clicking these links.</p>
<ul>
<li><p><a href="http://codingxiaxw.cn">Blog@codingXiaxw’s blog</a></p>
</li>
<li><p><a href="http://weibo.com/u/5023661572?from=hissimilar_home&amp;refer_flag=1005050003_" target="_blank" rel="external">Weibo@codingXiaxw</a></p>
</li>
<li><p><a href="http://www.zhihu.com/people/e9f78fa34b8002652811ac348da3f671" target="_blank" rel="external">Zhihu@codingXiaxw</a>  </p>
</li>
<li><a href="https://github.com/codingXiaxw" target="_blank" rel="external">Github@codingXiaxw</a></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
